---
title: 3D游戏引擎入门课程1——概述
date: 2020-06-29 12:50
categories: [理论, 3D游戏引擎]
tags: [游戏引擎]
---

## 写在前面

本专栏内容均为学堂在线慕课《3D游戏引擎架构设计基础》中的内容。个人将其转化成文字和图片的版本（个人更加喜欢文字版本的教程，阅读速度更快很多），方便查阅。
原课程链接：[3D游戏引擎架构设计基础](https://next.xuetangx.com/course/SCUT00001001532/1515566?fromArray=learn_title)。
本文由整份的word文档转化而来，可选择阅读整份文档（转化成的web专栏阅读起来感觉会更加舒服）。链接放到最后。

## 导图

课程思维导图：
![在这里插入图片描述](https://picbed.olimi.icu//img/20200629160732842.png)
大图查看链接：[高清版](https://www.processon.com/view/link/5cc4837de4b09b16ffca4de3)
因此，本专栏将根据导图的索引，分为7个章节。

## 索引

- [概述](https://olimiya.github.io/posts/3D游戏引擎入门课程1——概述)
- [场景管理]((<https://olimiya.github.io/posts/3D游戏引擎入门课程2——场景管理>)
- [资源管理]((<https://olimiya.github.io/posts/3D游戏引擎入门课程3——资源管理>)
- [场景渲染]((<https://olimiya.github.io/posts/3D游戏引擎入门课程4——场景渲染>)
- [角色动画]((<https://olimiya.github.io/posts/3D游戏引擎入门课程5——角色动画>)
- [事件处理与脚本语言]((<https://olimiya.github.io/posts/3D游戏引擎入门课程6——事件处理与脚本语言>)
- [内存管理]((<https://olimiya.github.io/posts/3D游戏引擎入门课程7——内存管理与插件机制>)

## 概述

### 游戏引擎概述

> 定义：如果把游戏开发中的核心基础功能独立抽象出来，供游戏开发者调用，这样的组件被称为游戏引擎。使用游戏引擎开发游戏，能够提高游戏的开发效率和质量。在早期的游戏开发中，设计者们逐步地、不断地抽取出游戏设计的公共组件，将这些功能抽象化、模块化，形成了游戏引擎。随着游戏开发的不断成熟，游戏引擎的功能已经越来越强大。

![watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsZXphbg==,size_16,color_FFFFFF,t_70](https://picbed.olimi.icu//img/202303291858060.png)
其中开源的游戏引擎包括，Unreal Engine 4，OGRE，Panda3D等，流行的商业游戏引擎包括，Unity等。下文将主要通过OGRE和Panda3D进行举例。

### 游戏引擎框架概述

> 游戏引擎的需求分析，即游戏引擎应该包含的功能。
>
> 其中环境需求包括：

- 目标硬件

- 设备驱动

- 操作系统

- 第三方软件包和中间件

- 支撑引擎的平台独立层

> 功能需求包括：

- 引擎的核心基础模块

- 引擎资源管理

- 引擎场景管理和图形渲染

- 角色动画

- 声音

- 物理和碰撞检测

- 人工智能

- 图形用户界面GUI

- 脚本处理等

游戏引擎的设计原则包括：功能完善（多），运行效率高（快），性能稳定（好），同时具备良好的扩展性。

> 游戏引擎的架构设计，应将以下内容按照一定的方式组合在一起：

- 基础平台的支撑组件

- 第三方的基础库：数据运算、图形处理、数据结构等

- 引擎功能（如上面功能需求所述）

> 游戏引擎层次化组织架构：

![在这里插入图片描述](https://picbed.olimi.icu//img/202303291858026.png)
![在这里插入图片描述](https://picbed.olimi.icu//img/202303291858491.png)

### 功能游戏

功能游戏的分类：
![在这里插入图片描述](https://picbed.olimi.icu//img/202303291900925.png)

### 游戏引擎中的设计模式

> 创建型模式：

- 单例模式：系统中只存在一个实例，一般是全程存在的。

- 抽象工厂模式：为创建若干个有关联的工厂类提供接口，是抽象类，无需制定具体类。

- 工厂模式：提供若干个有关联对象的接口，是具体类，可以实例化。

> 结构性模式：

- 适配器模式：将一个类的接口转换成所希望的另外一个类的接口。让原本因接口不兼容而不能一起使用的那些类可以一起工作。通过该模式可以为第三方的基础库定义统一的接口。

> 行为性模式：

- 迭代器模式：顺序访问一个聚合对象中的各个元素，但不需要了解该对象的内部表示。

- 观察者模式：由多个观察者对象同时监听某个主体，当主体对象发生变化时，通知所有的观察者，并做成响应。

- 访问者模式：将一些操作封装，并施加于某种数据结构元素上，当修改封装的操作时，不会影响被施加的数据结构，即可以将不稳定的方法和稳定的数据结构隔离。如，将渲染算法封装为访问者模式的类，可将方法和数据隔离，如果某个数据结构的某个算法发生改变，则只需要修改算法，而不影响数据结构的元素。

## 文档链接

[金山文档] [3D游戏引擎基础.doc](https://kdocs.cn/l/cOwTZ8DVf)
