[ { "title": "命令行总结-Windows包管理器", "url": "/posts/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%80%BB%E7%BB%93-Windows%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/", "categories": "杂记, windows", "tags": "shell, 包管理器, windows", "date": "2022-11-18 20:46:25 +0800", "snippet": "前言前段时间搞Powershell在windows终端上支持一些常用的Linux命令使用了Cygwin，然后最近安装Ruby又必须提供MSYS2 and MINGW development tool chain. 最后就是xxx install xx_package这样的命令都不支持用了多少种。因此把windows上命令行相关包管理器等一起汇总总结以下。稍微吐槽以下：标准真的是个好东西，就像一种秩序，无论是多么糟糕的秩序，都比混乱强。因为Windows没有标准的命令行管理器（像ubuntu自带的apt、CentOS的yum等），就导致同样一个东西，百花齐放，分别维护，不同的东西喜欢依赖不同的工具。但对于用户来说这一堆东西并不感兴趣，能够提供一套一样的接口就好了。同理C++标准也是一样的。浅显的体会。越总结越发现依赖管理对于一个编程技术发展的重要性~命令行学习虽然动机以及操作背景是基于Windows，但最终使用的基本都是Linux标准的命令行（Shell）。因此学习的核心还是Linux的shell。一些很好的学习资料：（埋坑++） Effective Shell: 通俗易懂的从零开始从入门到放弃的Shell学习，从基础的文件、导航，到管道、作业，命令行技巧（这节很好），正则、脚本、Grep使用等。涉及知识挺多的，虽然最终还是躲不过有点枯燥.. 命令行的艺术：Quora中出现，许多人总结凝练的命令行知识，包括许多常用或不常用命令，内容不长，好评，应该时时习之。 MIT补充课程The Missing Semester of Your CS Education：包含额外的整个体系，包括Shell、Vim、命令行、Git、元编程、密码学等等。官方说法是11个大概1小时的讲座（对，有视频版）中文帮助man看帮助是个非常重要的事情，很多时候–help显示的提示信息非常少，Linux上的man-db会提供更多的帮助内容。奈何英语水平有限，慢慢阅读man的效率还不如google搜索别人总结的内容(二手shit)。所以还是改为使用中文man。btw，Powershell上查看帮助为：Get-Help command option. 要中文显示先要配置系统中文环境： # 最终显示效果$ localeLANG=zh_CN.UTF-8LANGUAGE=zh_CN:zhLC_CTYPE=\"zh_CN.UTF-8\"LC_NUMERIC=\"zh_CN.UTF-8\"LC_TIME=\"zh_CN.UTF-8\"LC_COLLATE=\"zh_CN.UTF-8\"LC_MONETARY=\"zh_CN.UTF-8\"LC_MESSAGES=\"zh_CN.UTF-8\"LC_PAPER=\"zh_CN.UTF-8\"LC_NAME=\"zh_CN.UTF-8\"LC_ADDRESS=\"zh_CN.UTF-8\"LC_TELEPHONE=\"zh_CN.UTF-8\"LC_MEASUREMENT=\"zh_CN.UTF-8\"LC_IDENTIFICATION=\"zh_CN.UTF-8\"LC_ALL=zh_CN.UTF-8 # 如果当前不是这个$ sudo apt-get install language-pack-zh-hans language-pack-zh-hans-base # 个人使用zshrc所以添加到这里$ nano ~/.zshrc# 在里面输入export LANG=\"zh_CN.UTF-8\"export LANGUAGE=\"zh_CN:zh\"export LC_NUMERIC=\"zh_CN\"export LC_TIME=\"zh_CN\"export LC_MONETARY=\"zh_CN\"export LC_PAPER=\"zh_CN\"export LC_NAME=\"zh_CN\"export LC_ADDRESS=\"zh_CN\"export LC_TELEPHONE=\"zh_CN\"export LC_MEASUREMENT=\"zh_CN\"export LC_IDENTIFICATION=\"zh_CN\"export LC_ALL=\"zh_CN.UTF-8\" 安装manpages-zh: sudo apt updatesudo apt install manpages-zh# 然后正常使用即可man bash 或者查看中文在线网站：Manpages of manpages-zh in Debian unstable — Debian Manpages模拟Linux终端类似于打开一个Linux终端进行使用，支持常见的Linux指令如ls等。但本质上并不是运行Linux应用，运行的应用还是windows的exe。包括有： Cygwin msys2 git-bash（安装时好像也可以选择msys2）等这些终端内部也有一些包管理器，用于管理安装在此终端内部使用的应用。比如Mingw，全局搜一下几十处地方都有，像cygwin、mysy2、git等等都会包含一套。（Windows不像apt一样有一个全局的依赖库，真难受呀） 对比分析：[Cygwin 与 MinGW/MSYS/MSYS2，如何选择？ ZRONG’s BLOG (zengrong.net)](https://blog.zengrong.net/post/cygwin_and_mingw/) 特点 Cygwin MinGW/MSYS MSYS2 是否GNU 否 是 是 更多软件支持？ 支持绝大多数的 GNU 软件 支持常用软件，git、Vim等软件需要独立支持(详细介绍见下方） 支持大多数 GNU 软件 更类Linux？ Cygwin在Windows中就好像Wine在Linux中 实现了Bash等主要的Linux程序 原生64/32bit支持 GCC编译 内含MingGW32交叉编译功能，既支持依赖cygwin1.dll的程序编译，也支持独立的Windows程序编译；可以直接编译Linux下的应用程序 支持独立的Windows程序编译 支持独立的Windows程序编译 中文支持 直接支持中文显示和输入法 需要配置才能支持中文显示和输入，删除一个中文字符需要删除2次 支持中文显示和输入法，中文帮助系统和中文提示（部分软件） 运行速度 慢 快 快 Cygwin动机：获得一个轻量级的类Unix终端，可以安装一些Linux工具，同时能够在Windows终端中获取一些简易Linux功能（比如在CMD中获取ls这个指令） Cygwin 是: 提供功能的大量 GNU 和开源工具 类似于Windows上的Linux发行版。 一个DLL（cygwin1.dll），它提供了大量的POSIX API功能。 不是： 一种在Windows上运行本机Linux应用程序的方法。你必须 如果您希望应用程序在 Windows 上运行，请从源代码重新生成应用程序。 一种神奇地使本机 Windows 应用程序了解 UNIX® 的方法 信号、PTY 等功能。同样，如果你想利用Cygwin的功能，你需要从源代码构建你的应用程序。 当然除去使用Cygwin，还有类似的msys2等工具，自行选择吧，个人这里就仅需要一些很简单的功能。更复杂的支持使用前面的WSL，这里再安装一个轻量级的就是因为WSL打开较慢，占用率较高，同时不能提供外界直接使用unix指令。安装安装就官网下载安装包一路安装即可。注意： 安装时选择一个源，推荐选择清华源：http://mirrors.ustc.edu.cn. 选择安装的包时，建议至少选择一个wget包。这里不用纠结安装哪些包，后续可以随时回来变更。 安装完成后，记得不要删除安装包。后续管理包都需要这个安装包，比如增加、卸载包。添加包不会覆盖原安装的包。包管理器关于包管理：就像前面说的，要通过安装包去管理包，这确实就是官方的途径。 除了安装程序之外，Cygwin中没有包管理。安装程序仅将更新应用于当前安装，它不会覆盖您已有的软件包（除非您明确说明）。 因此，请重新运行安装程序以安装新软件包。不过还是有一些第三方巩固，比如apt-cyg，提供类似于apt-get（但apt-cyg != apt-get，有时候出错了就乖乖用安装包维护吧）。apt-cyg安装：wget https://raw.githubusercontent.com/transcode-open/apt-cyg/master/apt-cyginstall apt-cyg /bin然后即可使用apt-cyg install nano安装。另外，可通过apt-cyg mirror指定安装源。apt-cyg mirror http://mirrors.ustc.edu.cn/cygwin/此时可能出现nano-4.9-1.tar.xz: 失败sha512sum: 警告：1 个校验和不匹配是由于wget导致的，换成lynx的话就会消失（安装lynx包卸载wget包），但是会导致更多的报错，所以还是愉快的当做看不到吧~关于包管理器，还看到用Chocolatey管理的choco install bash --source=cygwin个人不使用这个windows包管理器，就不尝试了。参考链接：updates - How to install new packages on Cygwin? - Super User使用配置把Cygwin添加到Windows Terminal中：打开WT设置，添加新配置文件，复制一个原有的比如Powershell，然后修改名称，命令，图标即可，命令修改为：D:\\software-dev\\cygwin\\bin\\bash.exe -i -l.然后为了其他终端获取unix命令，添加环境变量，将cygwin\\bin、cygwin\\sbin、cygwin\\usr\\local\\bin等加上，具体添加可自行选择一个或多个。MSYS2基本情况与上述Cygwin基本相同： MSYS2是MSYS的一个升级版,准确的说是集成了pacman和Mingw-w64的Cygwin升级版, 提供了bash shell等linux环境、版本控制软件（git/hg）和MinGW-w64 工具链。与MSYS最大的区别是移植了 Arch Linux的软件包管理系统 Pacman(其实是与Cygwin的区别)。安装可以到官网下载安装。个人是使用Choco完成的安装：choco install msys2 # 会选择是否包含mingw工具链，根据提示选择默认的[1,3]# 这里安装msys2时可能会卡在updating trust database，Ctrl+C取消然后重新运行一次即可 --force重新安装Choco安装会自动添加到PATH中，直接使用msys2等命令即可。包管理器：根据介绍，msys2中集成了pacman包管理系统，直接使用pacman安装管理包即可。Windows Terminal集成：基本操作同Cygwin，使用的命令为msys2_shell.cmd -defterm -no-start -use-full-path -here -mingw64，具体参考这个。轻度使用感觉Cygwin和MSYS2区别不大，但msys2自带包管理器还是更省心，同时可以打包Mingw工具链，由于个人使用Jekyll框架必须使用，所以改为使用MSYS2。大小上面差距不大，Cygwin 800M，MSYS2 900M（取决于安装包，MSYS2自带Mingw.）Windows包管理器类似于ubuntu上的apt，命令行获取应用，并处理应用的依赖关系，比如一个包可能会依赖于7zip，当环境中没有时，在install的时候会递归去下载这些依赖。包括有： winget。微软商店的网络有坑。 scoop chocolateyScoop安装： Scoop 默认使用普通用户权限，其本体和安装的软件默认会放在 %USERPROFILE%\\scoop(即 C:\\Users\\用户名\\scoop)，使用管理员权限进行全局安装 (-g) 的软件在 C:\\ProgramData\\scoop。如果有自定安装路径的需求，那么要提前设置好环境变量，否则后续再改不是一件容易的事情。所以先设置用户安装路径$env:SCOOP='D:\\Scoop'[Environment]::SetEnvironmentVariable('SCOOP', $env:SCOOP, 'User')然后以非管理员权限打开powershell# Change execution policySet-ExecutionPolicy RemoteSigned -scope CurrentUser# Download and install scoopiwr -useb get.scoop.sh | iex# Add useful buckets (resembles repos in apt)scoop bucket add extrasscoop bucket add versions之后就可以scoop install安装包，比如scoop install sudo.Chocolatey安装和配置过程如下： 首先安装Chocolatey。这里手动指定了安装路径。 # 指定 Chocolatey 本身的安装位置$env:ChocolateyInstall='E:\\Program_Files\\Chocolatey'[Environment]::SetEnvironmentVariable('ChocolateyInstall',$env:ChocolateyInstall,'Machine')# 在安装前应手动创建安装路径文件夹（若不存在） # 安装Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))# 如果已经有执行脚本权限可执行以下# iwr https://chocolatey.org/install.ps1 -UseBasicParsing | iex # 根据提示. $PROFILE choco使用 // 安装包choco install &lt;package&gt;// 如果使用 -version 可以指定版本 // 查看安装的包choco list -lchoco list -local-only // 包的更新，包括chocolatey本身choco upgrade &lt;packagename&gt; // 包的卸载choco uninstall // 包的搜索（我更喜欢去官网的Packages页上搜）choco search 指定包路径（对于到处拉屎的行为是坚决禁止的！）。Choco安装完成后会添加ChocolateyToolsLocation环境变量，将其修改为需要的路径即可（针对Choco1.2版本）。 CPP包管理器 vcpkg conan其他一些包管理器Ruby使用RubyGems和bundler进行依赖管理。bundler: 提供ruby依赖管理，跟踪并安装所需特定版本的gem，后面jekyll网站初始化时，bundle从Gemfile中安装所需的依赖。Rust" }, { "title": "旧配置笔记本更新windows11 Cpu不兼容", "url": "/posts/%E6%97%A7%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%9B%B4%E6%96%B0Windows11-CPU%E4%B8%8D%E5%85%BC%E5%AE%B9/", "categories": "", "tags": "", "date": "2022-11-13 00:00:00 +0800", "snippet": "前言之前一直不想更新win11，一个是觉得没太大必要，看起来不过是换皮罢了，另外是更新之处留下的恶劣印象，比如崩溃比较多，比如对A卡的恶劣态度。如今时间已经过去了快两年，迭代更新也很多版了，而且就算只是换皮，想想写的其他博客，不就是爱好为了这点效果折腾这样的人嘛。所以搞起，拥抱新变化。更新过程先放下最终成功和测试的配置：设备名称\tOlimi-PC处理器\tIntel(R) Core(TM) i5-7300HQ CPU @ 2.50GHz 2.50 GHz机带 RAM\t16.0 GB (15.9 GB 可用)设备 ID\t19BD7F44-7786-40A6-B087-3E10BB8261B1产品 ID\t00331-10000-00001-AA806系统类型\t64 位操作系统, 基于 x64 的处理器笔和触控\t没有可用于此显示器的笔或触控输入版本\tWindows 11 专业版版本\t22H2安装日期\t‎2022/‎11/‎12操作系统版本\t22621.819体验\tWindows Feature Experience Pack 1000.22636.1000.0一开始先用官方工具WindowsPCHealthCheckSetup测试一遍，发现不支持，提示问题是TPM没开启和CPU不兼容，按照提示打开了TPM（在BIOS中开启），然后就还是CPU不兼容。看了一下CPU兼容列表，发现主要都是支持10代以后的，7代CPU只支持一款，所以几年前的老配置都别想了。也可以用WhyNotWin11测试，易用性更强。其后针对CPU兼容性不足尝试了很多网上的做法，有些教程还是比较新的，不知道都是复制粘贴以前的教程，漏洞已经堵上了，还是针对我不行。大概的做法都是，先下载win11镜像，然后通过修改注册表（BypassTPMCheck、BypassSecureBootCheck、AllowUpgradesWithUnsupportedTPMOrCPU）、删除镜像安装包某个dll（appraiserres.dll），然后启动安装。测试结果是无论设置什么注册表，都无法绕过兼容性检查，删除这个dll，就会导致安装程序无法启动（提示：抱歉：我们在确定你的电脑能否运行Windows 11时遇到问题，请关闭安装程序，然后重试）。成功的做法：首先是参考的出处：NEW Way to Install Windows 11 22H2 on Unsupported Hardware - YouTube 下载Win11镜像，个人是通过MediaCreationToolW11，建议直接到官网下载镜像。下載 Windows 11 (microsoft.com)，选择下载Windows 11 磁碟映像（ISO） 然后把下面代码保存为Windows11.cmd，管理员权限运行。 @(set '(=)||' &lt;# lean and mean cmd / powershell hybrid #&gt; @' ::# Get 11 on 'unsupported' PC via Windows Update or mounted ISO (no patching needed)::# if wu download stuck at 0% use OfflineInsiderEnroll by whatever127 and abbodi1406::# V9+ rebased on cmd due to defender transgression; skip already patched media (0b) @echo off &amp; title get 11 on 'unsupported' PC || AveYo 2022.05.11if /i \"%~f0\" neq \"%ProgramData%\\get11.cmd\" goto setupset CLI=%*&amp; set SOURCES=%SystemDrive%\\$WINDOWS.~BT\\Sources&amp; set MEDIA=.&amp; set /a VER=11if not defined CLI (exit /b) else if not exist %SOURCES%\\SetupHost.exe (exit /b)if not exist %SOURCES%\\SetupCore.exe mklink /h %SOURCES%\\SetupCore.exe %SOURCES%\\SetupHost.exe &gt;nulfor %%W in (%CLI%) do if /i %%W == /InstallFile (set \"MEDIA=\") else if not defined MEDIA set \"MEDIA=%%~dpW\"set /a restart_application=0x800705BB &amp; call set CLI=%%CLI:%1 =%%&amp;;set /a incorrect_parameter=0x80070057 &amp; set SRV=%CLI:/Product Client =%&amp;;set /a launch_option_error=0xc190010a &amp; set SRV=%SRV:/Product Server =%&amp;;powershell -win 1 -nop -c \";\"if %VER% == 11 for %%W in (\"%MEDIA%appraiserres.dll\") do if exist %%W if %%~zW == 0 set AlreadyPatched=1 &amp; set /a VER=10if %VER% == 11 findstr /r \"P.r.o.d.u.c.t.V.e.r.s.i.o.n...1.0.\\..0.\\..2.[25]\" %SOURCES%\\SetupHost.exe &gt;nul 2&gt;nul || set /a VER=10if %VER% == 11 if not exist \"%MEDIA%EI.cfg\" (echo;[Channel]&gt;%SOURCES%\\EI.cfg &amp; echo;_Default&gt;&gt;%SOURCES%\\EI.cfg) 2&gt;nulif %VER% == 11 set CLI=/Product Server /Compat IgnoreWarning /MigrateDrivers All /Telemetry Disable %SRV%&amp;;%SOURCES%\\SetupCore.exe %CLI%if %errorlevel% == %restart_application% %SOURCES%\\SetupCore.exe %CLI%exit /b :setup::# elevate with native shell by AveYo&gt;nul reg add hkcu\\software\\classes\\.Admin\\shell\\runas\\command /f /ve /d \"cmd /x /d /r set \\\"f0=%%2\\\"&amp; call \\\"%%2\\\" %%3\"&amp; set _= %*&gt;nul fltmc|| if \"%f0%\" neq \"%~f0\" (cd.&gt;\"%temp%\\runas.Admin\" &amp; start \"%~n0\" /high \"%temp%\\runas.Admin\" \"%~f0\" \"%_:\"=\"\"%\" &amp; exit /b) ::# lean xp+ color macros by AveYo: %&lt;%:af \" hello \"%&gt;&gt;% &amp; %&lt;%:cf \" w\\\"or\\\"ld \"%&gt;% for single \\ / \" use .%|%\\ .%|%/ \\\"%|%\\\"for /f \"delims=:\" %%s in ('echo;prompt $h$s$h:^|cmd /d') do set \"|=%%s\"&amp;set \"&gt;&gt;=\\..\\c nul&amp;set /p s=%%s%%s%%s%%s%%s%%s%%s&lt;nul&amp;popd\"set \"&lt;=pushd \"%appdata%\"&amp;2&gt;nul findstr /c:\\ /a\" &amp;set \"&gt;=%&gt;&gt;%&amp;echo;\" &amp;set \"|=%|:~0,1%\" &amp;set /p s=\\&lt;nul&gt;\"%appdata%\\c\" ::# toggle when launched without arguments, else jump to arguments: \"install\" or \"remove\"set CLI=%*&amp; set IFEO=HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options&amp;;wmic /namespace:\"\\\\root\\subscription\" path __EventFilter where Name=\"Skip TPM Check on Dynamic Update\" delete &gt;nul 2&gt;nul &amp; rem v1reg delete \"%IFEO%\\vdsldr.exe\" /f 2&gt;nul &amp; rem v2 - v5if /i \"%CLI%\"==\"\" reg query \"%IFEO%\\SetupHost.exe\\0\" /v Debugger &gt;nul 2&gt;nul &amp;&amp; goto remove || goto installif /i \"%~1\"==\"install\" (goto install) else if /i \"%~1\"==\"remove\" goto remove :install::@prompt $H &amp; echo oncopy /y \"%~f0\" \"%ProgramData%\\get11.cmd\" &gt;nul 2&gt;nulreg add \"%IFEO%\\SetupHost.exe\" /f /v UseFilter /d 1 /t reg_dword &gt;nulreg add \"%IFEO%\\SetupHost.exe\\0\" /f /v FilterFullPath /d \"%SystemDrive%\\$WINDOWS.~BT\\Sources\\SetupHost.exe\" &gt;nulreg add \"%IFEO%\\SetupHost.exe\\0\" /f /v Debugger /d \"%ProgramData%\\get11.cmd\" &gt;nul::@echo off &amp; echo;%&lt;%:f0 \" Skip TPM Check on Dynamic Update V9+ \"%&gt;&gt;% &amp; %&lt;%:2f \" INSTALLED \"%&gt;&gt;% &amp; %&lt;%:f0 \" run again to remove \"%&gt;%if /i \"%CLI%\"==\"\" timeout /t 7exit /b :remove::@prompt $H &amp; echo ondel /f /q \"%ProgramData%\\get11.cmd\" &gt;nul 2&gt;nulreg delete \"%IFEO%\\SetupHost.exe\" /f &gt;nul 2&gt;nul::@echo off &amp; echo;%&lt;%:f0 \" Skip TPM Check on Dynamic Update V9+ \"%&gt;&gt;% &amp; %&lt;%:df \" REMOVED \"%&gt;&gt;% &amp; %&lt;%:f0 \" run again to install \"%&gt;%if /i \"%CLI%\"==\"\" timeout /t 7exit /b '@); $0 = \"$env:temp\\Skip_TPM_Check_on_Dynamic_Update.cmd\"; ${(=)||} | out-file $0 -encoding default -force; &amp; $0# press enter 上述大概大概是在骗windows在安装windows server。所以后面都会显示正在安装windows server。接下来一路根据提示安装即可。我是选择保留文件、设置和app，在更新完之后基本没发生什么改变。 所以其实本质上就是找了一个能用的脚本:)。过程图：Win11使用Win10逻辑（任务栏、开始菜单、右键菜单、多标签页）更新win11的第一件事其实就是检查与原win10的逻辑使用，主要针对于以下几个交互：任务栏、开始菜单、右键菜单，也是更新win11前比较担心的问题。 针对任务栏：主要是右键呼出任务管理器和回到桌面。 对于开始菜单：以前在win10是重度磁贴使用者，桌面是不会放东西的，软件都放在磁贴上，然后分门别类。 对于右键菜单，在文件资源管理器上，win11使用一个新的右键菜单，需移到最下点击显示更多选项才会恢复win10的右键菜单，而这个右键菜单往往也是很多软件去修改的，比如git、svn等等。先说主流的恢复的解决方案： Start 11软件(收费) StartALLBack软件(收费) 修改注册表(最新版本已经失效) 系统降级win10 ExplorerPatcher(开源免费)个人尝试了Start11和StartAllBack，使用一个功能肯定是付费版比免费版好用，先尝试一下是否真的需要这个功能嘛。结论是上述的基本都能恢复：任务栏、右键菜单，下载StartAllback，默认配置基本就恢复了，配置也很简单；开始菜单，Start11可以基本恢复到磁贴的效果，甚至于也能实现右键固定到开始菜单时，自动添加到它配置的磁贴页面。要完整恢复要综合两个软件一起使用，付费价格大概都是50RMB左右。当然也有破解版。这里就不给出相关链接和指南，因为本人最终一个也没用这些恢复的解决方案。v2ex某老哥说得好：为 windows11 新右键菜单添加自定义菜单 - V2EX 拥抱变化，而不是一味想切换回旧版。对于本人来说，更新本来就是自己主动去做的，新的变化未必不是好事，不用一味想着回归最熟悉的东西，这是沉迷舒适圈的表现，而程序员就是要不断走出舒适区。当然这仅是个人的哲学，针对没办法强制使用win11的同学，比如现在新买电脑预装的win11，没必要折腾新东西是可以理解的。同时个人认为针对上面这些交互逻辑，win11的表现也并没有吐槽的那么严重。 针对任务栏：要呼出任务管理器，可以通过右键开始菜单（Win+x），对应原本习惯右键任务栏的逻辑；或者通过快捷键Ctrl+shift+esc。Win11任务管理器怎么打开？四种方法教你打开Win11任务管理器 - 知乎 (zhihu.com)。而回到桌面直接点右下角更便捷。 针对开始菜单：说实话这确实是我最不太能接受的，毕竟原本磁贴那套逻辑对于我来说用的非常好，不是很需要优化。尝试一下。管理逻辑类似，都是将软件固定到开始菜单。比较不好的是没有磁贴那个组的概念，原本个人会分成社交软件、工具软件、游戏、编程、科研等几个组，后面就自由补充进去即可。现在没有这个概念只有文件夹了，稍微有点别扭。另外比较难受的是最下面必须有推荐的项目这个，只能设置其占用面积较少。最下面一行在电源键一排可添加设置、个人文件夹（这个比较实用，不需要从c盘路径索引进去）。总体来说，对于强迫症的整理习惯，是有点别扭，不过操作逻辑上，切换到win11默认居中的布局，也减少了一点原本需要移动到屏幕左下角的时间，毕竟鼠标一般是在屏幕中间左右的，再习惯实用win键，效果更高一点（安慰自己:)） 针对于右键菜单，个人觉得新UI挺好的，没有很大问题。之前其实一直觉得右键菜单很丑，有很多功能比较加上，但其实很多时候其实并没有用上，现在叠加一层并非不是好事。对于普通用户而言，默认的新UI完全够用：复制、粘贴、删除、重命名、管理员身份、属性、还有新增的复制文件地址，对于压缩包也会有提取按钮。毕竟自定义菜单多的还是玩电脑的人，反而骂的狠，参照上面的帖子，拥抱新变化，新的菜单UI也是提供了接口的，不过目前各种软件可能没有适配的那么快而已，一定想要做自己也可以实现。所以还有一个好处就是帮助普通人把一大堆天天挤到右键菜单去的流氓软件（某度说的就是你）过滤掉，这不是好事。而且还有折中的逻辑，需要使用原菜单的，按住shift+右键即可。 文件资源管理器多标签页，这个单独说：其实这个功能不能说是恢复。因为win10根本就不提供这个功能，但是对于本人来说，这个功能可谓是装机必备，之前一直在用QTTabbar。对比之后，卸载QTTabbar使用了一段时间win11（22h2版本以后更新）的多标签页功能，简直太智障了…不能分离单独的标签页、不能在地址栏、左侧导航栏添加新标签。基本上就是在文件夹选项添加了一个新标签页打开，可以通过快捷键中键点击打开（中键这个快捷键和QTTabbar冲突，所以是卸载QTTabbar后体验的)。用了一段时间实在受不了狗屁逻辑，有好的不用用不好的，而且非常习惯双击空白返回上一级。决定还是放弃这个功能，恢复使用QTTabbar吧。:)一些注意的操作： 卸载QTTabbar，通过重新运行原安装包可删除，如果没有原安装包，就全局搜索QTTabbar（一般在C:\\Program Files里），然后在任务管理器中关闭文件资源管理进程，然后通过everything删除QTTabbar文件夹。 关闭win11多标签页： # 下载vivitool:https://github.com/thebookisclosed/ViVe/releases# 然后运行，运行之后重启电脑vivetool /disable /id:36354489vivetool /disable /id:37634385 关闭win11的多标签页之后，发现qttabbar的多标签页也显示不出来了。之后卸载qttabbar，然后重新安装即可。 看了win11家的多标签页，倒是感觉UI是更好看一些，可以选择优化一下qttabbar默认的显示。成品图如下。主要修改点为：标签页放在上边（比放底部强）、调整字体（与系统字体同步，但不能通过NoMeiryoUI一键修改，个人使用Consolas 11号，标签页可以增加一号，这里是12号）、活动标签增加下划线、设置标签页大小（强行拉宽标签页，设置最小宽度为150）。 以上设置基本都在QTTabbar选项\\外观设置中修改。有个注意的操作是可以在标签页右侧的空白处右键进入QTTabbar选项设置界面。 在知道上面右键可以进入设置之前，我一直是通过：控制面板-&gt;F: 打开原win10样式的文件资源管理，然后查看-&gt;选项-&gt;QTTabbar Commandline-&gt;设置进入选项设置的，贼麻烦。在QTTabbar安装位置找了半天都没有进入设置的办法…这也是进入win10菜单的一种方法吧。 QTTabbar针对win11有一个版本。QTTabBar - QuizoApps (wikidot.com) 在 Windows 11 预览体验成员预览版中，没有用于在文件资源管理器窗口中启用 QTTabBar 和其他工具栏的 UI。运行 QTTabBar 启用器.exe 以保存和加载工具栏状态。它还可以恢复在文件夹视图顶部启用 QTTabBar 的初始状态。 Win11体验整体来说还是偏向于换皮..嗯，文件资源管理器、设置、右下角管理、任务管理器、应用圆角等等，功能其实区别不大，就是UI的变动，不过对于个人来说，感觉是更好看的，特别是比较喜欢浅色调，现在浅色的质感还是挺不错的。其他一些方面： 文件显示更宽了，但是有个紧凑视图，在文件夹选项中，个人比较喜欢这种更宽的（视力不好） 设置上UI感觉更合理。一股子弄弄的ubuntu上gnome桌面风格，包括登录界面也是，特别是哪个密码输入框。 增加了个专注功能，替代简易的番茄钟软件。 个性化上，内置主题更丰富，包括自带的微软输入法也有多套主题。这个是入坑的部分原因。但是发现微软输入法变得巨丑！职能说未来可期吧。 比较实用的新功能：新窗口布局。拖动一个窗口，顶部出现窗口布局提示。几种布局模式都挺实用的，代替了win10一些第三方工具。其他一些变更可参考：Windows 11 22H2 (2022) 正式版新功能特性汇总！升级前必看 - 异次元软件下载 (iplaysoft.com)总结整个帖子下来比起教程、经验、记录，更不如说是个人审美的絮絮叨，像是展现本人xp的过程。好了那就说到这。" }, { "title": "C++包管理器", "url": "/posts/C++%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/", "categories": "杂记, C++", "tags": "C++, 包, 工具", "date": "2022-11-08 20:18:43 +0800", "snippet": "CPP包管理器可选择如下。尝试通过包管理器简单完成项目依赖管理和编译工作。参考：打包一沓开源的 C/C++ 包管理工具送给你! - 削微寒 - 博客园 Vcpkg Conan：一个好东西中文博客 xrepo Conan个人体感仅开发windows应用用vcpkg，对于跨平台或者cmake项目首选Conan。搜索了一些基础库后发现conan包更齐，所以先用Conan.安装参考文档：Install — conan 1.53.0 documentation$ pip install conan这里有个问题： We strongly recommend using virtualenvs (virtualenvwrapper works great) for everything related to Python. (check https://virtualenvwrapper.readthedocs.io/en/stable/, or https://pypi.org/project/virtualenvwrapper-win/ in Windows) With Python 3, the built-in module venv can also be used instead (check https://docs.python.org/3/library/venv.html). If not using a virtualenv it is possible that conan dependencies will conflict with previously existing dependencies, especially if you are using Python for other purposes. 确实看到pip安装包就想到环境的问题，特别像python这种东西一个系统可能有数十份，每个python的sitepackages包像shit一样拉的到处都是。所以这里牵扯到一个题话外python虚拟环境。python虚拟环境之前对于python虚拟环境一般用的是Anaconda，也不是不行，但感觉Anaconda太臃肿了，还没开始用就几G到十几G，虽然确实配套的工具和各种包很齐全，但如果不是专业目的，只是为了一个python环境，完全没必要。所以，解决方案直接用：官方Python + pip virtualenvwrapper. 首先下载一个官方python（可能系统中原本有别的python，但下载一个自己首选的、自己管理的、干净的） 我个人会添加一个Python_Root环境变量手动切换各个地方各种版本的py（主要是某些项目需要必须用内部的python） get-command pythonn(Powershell)/where python(CMD)确认当前的python. 同时python -m site查看一下包的位置，发现安装位置是python目录下的LIB目录，不会到处拉屎。 搜索一下virtualenvwrapper，发现pip search没法用了。解决：pip install pip-search，pip_search xxx. 安装virutalenvwrapper-win $ pip install virtualenvwrapper-win 添加环境变量：WORKON_HOME -&gt; 指向{Python目录}/env 创建虚拟环境： $ mkvirtualenv conan$ workon conan # 命令必须在CMD而不能Powershell$ pip install conan 到此完成。virtualenvwrapper的一些命令：mkvirtualenv 、lsvirtualenv、rmvirtualenv 、workon、deactivate、cdproject、cdsitepackages、cdvirtualenv、virtualenvwrapper(列举上面命令). 额外：像上述说的virutalenvwrapper-win本身只支持CMD不支持Powershell，而Windows上默认终端Powershell，在某些IDE里面的终端切换成CMD更麻烦（CMD也更加难用），所以配置一下Powershell命令： $ git clone https://github.com/regisf/virtualenvwrapper-powershell ./$ ./install.ps1# 用法lsvirtualenv (alias: Get-VirtualEnvs) : List all Virtual environmentsmkvirtualenv (alias: New-VirtualEnv) : Ceate a new virtual environmentrmvirtualenv (alias: Remove-VirtualEnv) : Remove an existing virtual environmentworkon: Activate an existing virtual environmentGet-VirtualEnvsVersion: to display the current version. 需要Powershell能够执行脚本： $ Set-ExecutionPolicy RemoteSigned # 管理员权限 配置默认配置文件位置 ~/.conan/conan.conf，~表示用户目录，Windows为C:\\Users&lt;用户名&gt;.conan\\conan.conf配置文件中有详细的注释信息，根据自己的需要修改即可，我修改存储目录和下载缓存目录（默认包下载在.conan\\data目录下）[storage]# This is the default path, but you can write your own. It must be an absolute path or a# path beginning with \"~\" (if the environment var CONAN_USER_HOME is specified, this directory, even# with \"~/\", will be relative to the conan user home, not to the system user home)path = F:/Library/ConanPackagesdownload_cache = F:/Library/ConanPackages/cache使用关于Conan的学习参考官方文档和前面的中文翻译博客。这里记录一些实践中特别的地方。remote仓库注意新的仓库名称conan search poco --remote=conancenter测试使用Poco\\md5的例子测试，个人编译cmake项目使用CLIon，加载时cmake项目选择release模式。conan install默认下载release库。" }, { "title": "个人云服务器指南", "url": "/posts/%E4%B8%AA%E4%BA%BA%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8C%87%E5%8D%97/", "categories": "教程", "tags": "网站, web", "date": "2022-11-01 17:34:02 +0800", "snippet": "前言C++搞不知道有什么用的单机软件无聊死了，还是互联网好玩。（不过学C++跟搞互联网的都一起饿死了）简单记录一下简简单单的入门知识吧。选购国内和国外，但国外的还是会有支付银行卡的问题。那国内基本就阿里、华为、腾讯，还有别的一些小厂。体感跟看别人的说法，阿里做的最好，市场份额也最高。华为性价比还行，印象中感觉主要还是to G或者to B。腾讯云最low（身边有朋友还被黑了）。不过阿里云已经给实验室买了两个账户，没有新用户了。只能试试腾讯云了。选购链接： 阿里云：云小站_专享特惠_云产品推荐-阿里云 (aliyun.com) 华为云：特惠专区_云服务器_云主机_企业上云-华为云 (huaweicloud.com) 腾讯云：精选爆品抢购_云服务器秒杀_企业上云场景推荐-腾讯云 (tencent.com)个人开发者嘛，就一个字抠。所以嘛，搞公有云的也不图这几个钱，以前无论是新用户优惠还是学生领取，搞得都挺多的，图的可能就是培养一个用户习惯。然而这年头大家过的都难，这种看不到啥钱途的事情也不怎么爱做了。体感上面公有云这种业务可能也收缩了，看上去就是价格都不便宜了。有钱赚的还是像金蝶那种搞私有云的。上面稍微吐槽一下，唉，毕竟云这种概念对于开发者还是很有吸引力的。启动服务器买完之后基本按照指引一步一步完成即可。之前使用过几次阿里云都是装的Windows Server，如果是Windows基本没什么好说的，使用远程桌面登录即可。自己玩的话肯定还是用Linux服务器比较好玩，先装个ubuntu。首次登录需重置密码，然后使用ssh远程登录。更建议使用密钥登录，更加安全也能实现免密登录。密钥登录密钥登录可以使用云自带的密钥管理系统，会生成一对密钥，然后下载私钥保存起来，使用的时候添加密钥就会自动添加到服务器.ssh文件夹内，然后把私钥放到客户机.ssh文件夹下，添加Config文件：Host ubuntu HostName (your ip) Port 22 User ubuntu IdentityFile ~/.ssh/ubuntu.pem ServerAliveInterval 30 TCPKeepAlive yes具体免密登录参考：构建我的工作空间 Olimiubuntu配置进入系统首先sudo apt-get update、sudo apt-get upgrade更新。然后装些必备扩展比如zsh终端吧：Windows Terminal + WSL + Ubuntu + 图形化 总结 Olimi图形化界面试着装了一下，感觉不是特别有必要，一个是系统资源占用高，另外还比较卡，选Linux系服务器就是图一个系统资源性比价最高，需要图形化界面直接重装为Windows Server算了。访问github上述安装zsh过程碰到一个使用linux最大的问题，就是国内访问github巨慢的问题，什么时候吃过这种苦。解决途径： 针对这个问题主流的方案就是直接强改host，通过一些ip测速获取当前github的ip，手动设置host(/etc/hosts). 也有一些github项目一直会更新hosts：isevenluo/github-hosts: 🔥🔥🔥 本项目定时更新GitHub最新hosts，解决GitHub图片无法显示，加速GitHub网页浏览。 挂梯子。第一种方法亲测不太好使，有点神经刀，有时候好用有时候还是很慢。吃不得这种苦，还是挂梯子吧。服务器使用v2raya：Debian / Ubuntu - v2rayA大概的步骤：curl -Ls https://mirrors.v2raya.org/go.sh | sudo bash # 安装v2raysudo systemctl disable v2ray --now # 关掉v2ray服务wget -qO - https://apt.v2raya.mzz.pub/key/public-key.asc | sudo apt-key add - #添加v2raya公钥echo \"deb https://apt.v2raya.mzz.pub/ v2raya main\" | sudo tee /etc/apt/sources.list.d/v2raya.list # 添加v2raya软件源# 安装v2rayasudo apt updatesudo apt install v2rayasudo systemctl start v2raya.servicesudo systemctl enable v2raya.service # 可选，设置开机自动运行# 访问：127.0.0.1:2017，因为是远程服务器，所以要开放这个端口，远程访问，好处就是虽然是无图形化界面的服务器，也可以通过客户端访问图形界面起了v2raya服务之后添加梯子即可，其他说明参见官方文档。碰到一个坑爹的问题是：使用”防止dns污染“功能会导致无法识别mirrors.tencentyun.com这些内部域名。解决方案： 重启一下，服务器好像会自动重置网络。 找一下dns服务器地址，自行添加hosts、云服务器 内网服务-产品简介-文档中心-腾讯云 (tencent.com)端口维护管理云服务器最多的地方应该就是端口的交互了，为了安全起见服务器大部分端口都是关闭状态，比如起了一个3306的服务，但是外界默认是访问不到的。需要到控制台开通端口：玩转云服务入门上手云服务器并没有什么门槛，本质上跟自己电脑没什么区别，只是一台可以24小时不停机，且拥有公网资源的电脑而已。主要还是看自己怎么玩。搭建git服务器干这个事就是买服务器的初衷来着。虽然就是自己学习着玩，github完全更好用。之前调研gitlab，不太好使，配置要求太高，建议用gitea：Gitea步骤记录：参考如何在Ubuntu 18.04安装Gitea myfreax# 1. 准备sudo apt install sqlite3 git# 创建一个git用户，下文操作都是基于git用户权限sudo adduser --system --group --disabled-password --shell /bin/bash --home /home/git --gecos 'Git Version Control' git# 2.下载giteawget -O /tmp/gitea https://dl.gitea.io/gitea/1.17.3/gitea-1.17.3-linux-amd64 #选择并下载一个二进制版本sudo mv /tmp/gitea /usr/local/binsudo chmod +x /usr/local/bin/giteasudo mkdir -p /var/lib/gitea/{custom,data,indexers,public,log}sudo chown git: /var/lib/gitea/{data,indexers,log}sudo chmod 750 /var/lib/gitea/{data,indexers,log}sudo mkdir /etc/giteasudo chown root:git /etc/giteasudo chmod 770 /etc/gitea# 3.配置systemd服务sudo wget https://raw.githubusercontent.com/go-gitea/gitea/master/contrib/systemd/gitea.service -P /etc/systemd/system/sudo systemctl daemon-reloadsudo systemctl start giteasudo systemctl enable giteasudo systemctl status gitea正常情况下完成上述过程就可以打开ip:3000访问gitea网页，如果是远程服务器，这里ip填写公网ip并且记得打开3000端口。坑：第一次到这里的时候省略了第一步创建git用户，使用自己默认的用户，但是官网给的gitea.service脚本是基于git用户的，如果不按照默认的要更改脚本为匹配信息。其实创建一个专门管理git的用户也挺好的(省事)，补回来。信息看着填就行，后续都可以更改配置文件，数据库这里选择sqlite3，仓库路径/home/git/gitea-repositories.一路往下安装图形界面操作，跳转到登录界面首次注册的用户为管理员，创建仓库，就可以作为服务器供外界访问了。比如我的测试： git clone http://ip:3000/olimi/test.git.Nginx反向代理上面测试链接协议为http，是不太安全的，通过配置Nginx反向代理配置SSL加密。步骤记录:# 1.安装nginxsudo apt-get install nginx# 2.配置反向代理# 这里首先需要一个指向服务器ip的域名，如果没有域名，可以随便设一个域名，然后在需要使用的电脑，手动配置host指向该ipsudo nano /etc/nginx/conf.d/域名.confserver { listen 80; server_name 域名; proxy_read_timeout 720s; proxy_connect_timeout 720s; proxy_send_timeout 720s; client_max_body_size 50m; # Proxy headers proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Real-IP $remote_addr; # log files access_log /var/log/nginx/git.example.com.access.log; error_log /var/log/nginx/git.example.com.error.log; # Handle / requests location / { proxy_redirect off; proxy_pass http://127.0.0.1:3000; }}使用：sudo nginx -t测试语法问题。然后sudo systemctl restart nginx重启服务。接着修改gitea中的域名配置：```shell[server]DOMAIN = git.olimi.icuROOT_URL = https://git.olimi.icu/1```{: file=\"/etc/gitea/app.ini\" }Nginx配置SSL证书：因为域名是腾讯云买的，所以直接到腾讯云中申请免费的SSL证书(虽然一直还在审核中..)，大概过程是：参考链接：SSL 证书 Nginx 服务器 SSL 证书安装部署-证书安装-文档中心-腾讯云 (tencent.com)过程： 下载证书文件 上传到服务器，使用相对路径可放在nginx.conf同目录下 配置服务参考：server { #SSL 默认访问端口号为 443 listen 443 ssl; #请填写绑定证书的域名 server_name cloud.tencent.com; #请填写证书文件的相对路径或绝对路径 ssl_certificate cloud.tencent.com_bundle.crt; #请填写私钥文件的相对路径或绝对路径 ssl_certificate_key cloud.tencent.com.key; ssl_session_timeout 5m; #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #请按照以下协议配置 ssl_protocols TLSv1.2 TLSv1.3; ssl_prefer_server_ciphers on; location / { #网站主页路径。此路径仅供参考，具体请您按照实际目录操作。 #例如，您的网站主页在 Nginx 服务器的 /etc/www 目录下，则请修改 root 后面的 html 为 /etc/www。 root html; index index.html index.htm; }}server { listen 80; #请填写绑定证书的域名 server_name cloud.tencent.com; #把http的域名请求转成https return 301 https://$host$request_uri; }SSL证书前面配置Nginx反向代理已经提及证书，Nginx可以帮助我们管理SSL通讯，只需要提供证书到Nginx并完成配置即可。不过前面步骤申请的SSL证书，免费的只针对单个域名，无法提供通配符适配，比如只能申请olimi.icu，不能申请*olimi.icu，所以每个子域名就得单独申请证书，较为麻烦。方案：使用Let’s Encrypt申请证书（Github.io的证书就是这个签发的）。Let’s Encrypt renew出现“Challenge failed for domain xxxx” - tlanyan (itlanyan.com)CentOS 7 上使用Certbot申请通配符证书-阿里云开发者社区 (aliyun.com)Web知识实践过程就会碰到许多web相关的知识，很多都有所耳闻，或者大概了解过，通过与实践结合，可以深入了解互联网中各种技术的原理。因为主要是埋个坑，所以放在这个博客中的一部分。TLS原理SSL/TLS 原理及抓包详解 - 腾讯云开发者社区-腾讯云 (tencent.com)反向代理原理终于有人把正向代理和反向代理解释的明明白白了！ - 腾讯云开发者社区-腾讯云 (tencent.com)DNS系统LeanCloud Blog: 域名背后那些事" }, { "title": "C++新项目学习-逆向工程之使用Doxygen", "url": "/posts/C++%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E4%B9%8B%E4%BD%BF%E7%94%A8Doxygen/", "categories": "杂记, C++", "tags": "记录", "date": "2022-07-28 16:01:09 +0800", "snippet": "前言学习C++项目，无论是调用的C++库，亦或者查看一个别人的项目，再或者接手一个老项目（shishan），直接硬撸源码是不太现实的。有些库文档写得不好，看文档不如直接看源码了。这个时候，如果我们手上已经有了源码，那使用逆向工程生成一些比较适合阅读的输出文档、图表就是一个自然而然的念头。对于C++来说，doxygen应该是个较为通用的解决方案。汇总 doxygen visual paradigm rational rose start umlvisual paradigm: How to generate UML from C++ - Visual Paradigm (visual-paradigm.com)doxygen: Doxygen + Graphviz + Htmlhelp, 成为文档好手 - maxweii - 博客园 (cnblogs.com)后面两个在UML领域也比较出名（虽然可能比较菜觉得不太好用）。都试用一遍，绘图工具主要专注于某种图的生成，最有性价比的选择还是doxygen.Doxygen生成使用doxywizard.exe非常傻瓜式，根据向导一步步选择即可。环境安装参考上述一个链接，主要就是下载doxygen, 需要合成chm的再安装个htmlhelp, 图表生成更好看的话增加graphviz。单纯就doxygen就可以。下面是我的一些步骤记录。关键步骤 第一步必填的一些信息，其他信息根据喜好添加。 第二步选择。 勾选分析的对象选择All Entity：让Doxygen分析所有内容。因为并不见得所有的代码都按Doxygen的注释方式进行了注释，为保证不会漏掉东西，所以选此项。这就是Doxygen的优势，兼容非doxygen注释（或者根本没有注释）的工程，一样可以看到一些结构信息。 “Include cross-referenced source code in the output”：简单来说就是把源代码也放到生成的文档中。个人比较喜欢选择这一项，虽然会导致API文档体积增大，但在以后查阅API文档时，可以直接看到源代码，不用专门去打开相应的源代码文件了。 第三步输出。 第四步图表。 Build. “FILE_PATTERNS”：告诉Doxygen需要分析哪些文件。这里要注意OSG和osgEarth的头文件都是没有扩展名的，所以这里加了个“*”，以确保Doxygen能扫描到这些头文件。 输入。这里输入的patterns，可在输出完成后，检查有什么信息少的或者不必要的，再回来补充。 Dot。如果勾选了Dot，需指定路径。 同理htmlhelper也是。 可选步骤 图标。在第一步选择icon后在expert张也加上。 不知道为什么在Wizard中设置的logo切换到Expert下就没有了，所以在这里又设置了一次。同样，如果不想在文档中显示图片logo，不填这一项就可以了。 Expert：HTML。 “HTML_DYNAMIC_SECTIONS”：让Doxygen产生可以显示/隐藏的动态块。生成的所有图片初始都是隐藏状态，需要哪个展开来看就是了，个人比较喜欢这个功能。 “CHM_FILE”：指定要生成的chm文档路径及名称。如果不加“../”生成的文件在“Doc/HTML”下，里面文件太多了不好找，加上“../”让Doxygen放到“Doc”下。 “HHC_LOCATION”：告诉Doxygen用于编译chm的工具hhc.exe在哪儿。这个工具是生成CHM的关键，通常在“C:/Program Files/HTML help workshop”路径下，如果没有就到网上找一个。 搜索引擎。使用index.html查看时的搜索框和htmlhelper不能共用。所以使用index查看就要禁止生成htmlhelp. " }, { "title": "从男性角度看唐山女权", "url": "/posts/%E5%A5%B3%E6%9D%83/", "categories": "随笔", "tags": "漫谈", "date": "2022-06-12 15:50:51 +0800", "snippet": "前言(快考试了又可以写小作文了)我，男的，蹭热度，讲讲唐山事件中的女权问题，不吐不快。尽量不输出情绪，尽量概括最简明扼要的观点。大概会从以下方面讲，1.从性别暴力角度看唐山事件；2.为什么要谈性别议题；3.女权？尊重；4.方法论；5.QA。虽然只是不成熟的小作文，但还是非常非常希望各位能驻足翻阅一下，就是第一部分也好。如果能产生一点点影响，也是非常大的反馈（您好先生请允许我向您介绍一下我们的教主.jpg）。另外有些话可能不太好听，碰到反对和不认可的，欢迎讨论。如果觉得毫无意义甚至想笑，那可以把我向你的输出屏蔽，日后好相见。从性别暴力角度看唐山事件关于唐山事件性别问题的讨论铺天盖地，就连我小小的朋友圈也能看到两种泾渭分明的观点冲突，在我的角度总结，一言以蔽之，(大部分)女生是受害者视角，(大部分)男生是旁观者视角。性别暴力角度最直观的表现就是恐惧分化。具体一点说，对于女生来说，这就是一直悬挂在头上的达利克摩之剑还是(或者说又)落下来，这种恐惧来源于从小到大一直被灌输的观念，”女孩子要保护好自己”“女孩子不要做什么什么，很危险的”“(某些男性)会攻击你的”，这些描述(以及相关事实)清晰地构建了一种恶意，这种恶意与生活形影不离，一直藏在阴影之处，让人如芒在背，带来的压迫与压抑是长久的。试着打个比方。就类似于《三体》里面的质子，它绝大多数时间对所有地球人是没有影响的，但只要它露出了恶意的獠牙，就能随时将你吞噬。这种恶意，是来源于猜疑链、黑暗森林，来源于种族矛盾、非我族类其心必异，来源于奴役和压迫。试想一下这样一个场景，美满幸福的一家三口，父亲是出色的尖端科学家，孩子从小立志也成为一名推动文明发展的科学家。然后就是父亲太优秀，质子轻松执行自己的任务将其狙杀。当孩子看着父亲冰冷的尸体，哭着向母亲问到，“为什么他们要这么对我们？我很优秀的，我长大了也可以对他们有帮助，为什么二话不说就要我把我父亲杀掉？”为什么，因为没有自由。对不起故事可能编得很烂，只是想说明一种无时不在的恐惧威慑有多么恐怖，相关的作品其实不胜枚举，在此抛砖引玉了。具备这样的想象力以后，具体讲讲唐山事件。分享一下我个人的心路历程，在性别暴力问题上，两个角度我都站过，在某个女性朋友朋友圈下面，我就直言询问过，“为什么要在这次事件上强调性别问题，带来了什么收益，是利大于弊的吗”。一开始是直接看了原版视频，确实很有共鸣感，也是狠狠冲击了幼小的心灵，主要震撼有两点。第一点是作为旁观者的无能为力，属实是能力边界了。这种处于弱势者的直观想法是大部分人都会有的，就像罗翔老师说的，“我们为什么对这个案件生气与愤怒。因为我们同情他人，同情自己，因为我们希望法律能够保护自己不成为下一个热点案件的被害人”。所以，对于这起事件中反黑社会的立场大部分人都有，大部分人都能感同身受于自己的无能为力。震撼的第二点是间接受害者的共鸣。因为之前很多次，比如跟女朋友约会，各自回家时有时候忘记回我信息，体会过很担忧的心情，因为喜欢胡思乱想，也会想象过一些不好的画面。所以看视频的时候就设想到我女朋友跟闺蜜吃饭（很日常的一个场景）碰到这种事情。于是对受害者的同理心就自然而然。而这个震撼，对于大部分女生来说，都是非常下意识就能代入进去，所以那种委屈、愤怒、崩溃可想而知，跟真正受害者是一样的。想反问的一点就是，认为这件事没有性别元素的朋友，特别是男性同胞，在看视频的时候真的能设身处地想象自己身处于那个被打女性的位置，真的感受到了“自己随时可能被揍到毁容乃至生命垂危”的威慑吗。我自问是没有的，在我仍然认为这此事件就是纯粹的黑社会问题，纯纯的暴力事件的时候。因为无论如何，我都无法想象自己身处公共场合(无论是什么样的危险时间、无论身着什么样的奇装异服)都不会因为被调戏然后被暴力对待。如果承认了这一点，为什么不能承认这个事件里面包含的性别暴力元素？男性从事件感受到了暴力、女性从事件中感受到了暴力和性别歧视，这不恰恰又论证了事件中的性别歧视吗？有些压迫，没有切身体会是很难想象，所以某云可以随口说出”996是福报”，我甚至可以相信这是他的真心话。但女性同胞不是其他的阶级，就是我们身边的人，我们最亲近的人，我们拥有一样的社会阅历和经历，拥有一样的记忆，只要愿意去理解，是可以体会到作为人，所能体会到的不公与压迫。同理心，就是我们通过性别暴力视角看待唐山问题，获取到最宝贵的东西。图1是启发想法最重要的来源，《从丰县到唐山》，文章写得很好，在此基础上表达了在我角度的看法。（图太长都放到最后）为什么要谈性别议题基础是建立在同理心之上，然后希望努力争取一个我们、我们后代所能生存的更文明、更进步、更公平的一个世界。人是有懒惰倾向的，姑且不论是否属于人的劣根性，但人对于与自己没太大利益关系的事情是不太关心的。那为什么要谈性别议题，很简单就是因为与你我息息相关。对于女性角度，旁观者就不多提，有压迫就有反抗。站在男性的角度，我提的动力(也是写小作文的动力)，最直接来源就是因为我有我的亲人、我的朋友，她们就处于这样的压迫和囚禁之中。我不想，再每次叮嘱、担忧女朋友的安危，虽然每个人的安全都值得被关注，但女生的安全却需要被更多的关注；我不想，当我有了自己的孩子，如果是个女生，需要从她童年开始，到她长大成人，甚至直至我老去，都要一直囚禁她的自由，不允许她跟同龄男生做一样的事，去一样的地方；我不想，在每次社会新闻，甚至有可能在某天某时，看到的某个女性、某个女性朋友，因为性别而经历可怕的遭遇。我们自诩文明，追求进步，那看到更不文明、更加不公之时，为何不敢仗义执言，为何不敢发声，为何不敢支持，做一点力所能及的事情。还有另外一点思路，怕冲过头了稍微表达一下。是，当下中国，贫穷、不公、欺凌、阶级矛盾，一直都存在，也没看到改善多少的曙光，所以前面的性别歧视，说的是更不文明、更加普遍。而另外，正是因为更加普遍，根据压迫带来反抗，所以反抗的声音和能量不应该也是更加普遍、更加浩荡。也确实如此，女权或者说讨论女权，在互联网一直都占据一席之地。追求文明是我们的期望，追求公平是我们的诉求，目标一致，为什么不加入争取女权的队伍。换个角度，如果这样说得上最大规模(潜在群体至少占了中国一半人口)的反抗都看不到希望，还想往什么方向努力和抗争？从头到尾， 我都是是站在食利群体(男性)的角度，因为确实很难真的切身体会到长久的压迫和压抑，屁股就决定了我肯定不属于争取女权的核心团体。但根据革命的理论，即使不属于同一党派，但为了达到一定的共同目的，还是可以”团结一切可以团结的力量”(–毛主席)吧。前面说的是我个人感觉比较直接的，像更深远一些的理由，父权制度下对男性、女性的标签化、思想禁锢，这些都都不说了。图2，3再引用一下看到比较深刻的发声，以及女性朋友的诉求。方法论说了这么多，到底能做些什么、应该做些什么呢？总结：搞清诉求，坦言、影响、输出，让问题得到承认，把罪恶暴露在阳光之下，谨代表我自己的思考。四句话分为三个层次，搞清诉求是指导思想，可分为长期、中期、目前的诉求，指引了进步的道路；坦言、影响、输出是做法，主要立足于社会文化层面的努力，是可以长期坚持的努力之道；最后是期望达到的目标，希望能从中得到反馈。书到用时方恨少。从大的层面上讲，其实还是很迷茫，应该怎么做、分哪些步骤、什么事情用什么样的解决方案、到底有没有用，这些问题都很难回答。所以目前是缺乏清晰的指导思想的，从个人的调研、跟朋友的讨论中得到的这样的反馈。往好了想，就是处于百家争辩的前期，处于大思变的初步，大家都有看法，大家都提出理论，只是还没有成熟，所以迷茫是正常的，但绝不是一时之间无法达成目标、看不到终点就视而不见！我提出我自己的简单做法。目前的主要目标是”让问题得到承认”，要解决一个问题，首先就要把这个问题说好，定义好。“提一个好问题与找到一个好答案一样重要”。我前面试图用自己的角度和经验去定义出这个问题来，但不一定做得好了(如果有许多人能看到这里，可能就做到一定程度的好吧)。所以把问题说出来、把问题说好了、让这个问题大家都在说，就是艰难的第一步。做到这点没有捷径，就是要坚持“坦言、影响和输出”。要影响全社会，就从影响身边的人开始。根据六度分割理论，只要把这个影响成功六次，就可以影响全世界(理想)。具体一点的指导思想就是，沿用前面说的阶级（群体）矛盾是剧烈的 所以脚踏实地的一点一点做起就是从团结更多可以团结的力量开始?按照这个指导思想，要用各种方法争取一切可以争取到的力量，对内部，团结女性力量，搞清诉求，当然最好有统一的纲领和目标，如果没有，求同存异，不要内部”割席”。对外，不要设置假想敌，客观理性地以理服人，就算是相对的外部，也属于一个更大的整体。我们都是人类。非我族类其心必异，但我们本不是异族，所以可以有同理心。强调差异不如寻找共鸣。再强调一下为什么现阶段目标就是“承认问题”。当一个职场上10个人里面有9个人都坚信着所谓的男子气概和潜规则，那剩下一个人，即使觉得这样不对，也很容易被裹挟着做这样的事情，久而久之，习惯和根深蒂固的念头就养成了。但是如果10个人里面有5个人都觉得这样是不对的，这是有问题的，那就可以坚持自我，甚至反向影响其他的5个人。这就是从社会风气上，达成某种观念倡导的重要意义。当然根据图2的第2点，“就可能大家确实有时候做不到很理性讨论了，…挺多妹子都很崩溃”(女性朋友)，我觉得可以理解，但问题就是问题，解决问题就是痛苦的，GM不是请客吃饭，是要流血流泪的。就像男女朋友吵架，你可以无理取闹，听之任之，也可以理性分析，共同进步，但是其他人、社会都不是你的男/女友，不是那么愿意接受情绪的输出。这确实很残忍。作为男生我也能审视到自己的情绪，有时候人在家中坐，锅从天上来，忽然被咬一口肯定是不爽的。但更多时候我们收到的都没有这么恶劣的报复性情绪。身边正常人，正常女生的输出，就当做路边崩溃女孩的哭诉好了。兴许有时候觉得有点烦，兴许有时候特别同情，兴许有时候想做点什么，至少，至少，能做到不打扰吧。因为在这次事情里面，我接受到女权讨论的观点，主要就是集中在希望正视性骚扰和暴力中的性别差异，有理有据，诉求合理，所以很容易就能接受。前面的方法论总结也就是建立在这个经历之上。女权？尊重总结：Let’s Think! 这部分属于情绪输出，可选择跳过。因为题为谈女权，所以我先站在女性角度讲。从一直看唐山事件漫天的讨论，到看朋友圈朋友们的一些输出，到感到困惑向女性朋友的询问、讨论，到最后自己总结的一点东西，有一股强烈的愤怒和情绪，不吐不快。即使这件事比较简单，争论最多只在于强调性别问题，这样的质疑也包括我自己。但是回想、看到这些质疑和不尊重，还是非常的愤怒。啊真是骄傲自大，真是以自我为中心，看不下其他东西。真的好想让柊老师狠骂一遍。一个两个都是人渣啊只要自己得救了，别人什么样都无所谓吗为什么你们只会产生这么狭隘的想法呢你们不太正常啊丧失道德 总以自我为中心总而言之 你们只是一群空壳而已正是过去的自己 才造就了现在的自己所以逃避过去的你、你 、还有你才会像小孩一样极其幼稚 停止成长就你们这样一帮人毕业 到底是毕的什么业！–柊一飒刀子戳进去，血会流出来，还会感到疼痛，有时候甚至会夺走性命，这是理所当然的事情。可是如今这个社会在不停地匆忙运转，让人们甚至无暇注意到这么理所当然的事情。做什么样的事会伤害对方，别人对我做什么会让我痛苦…我不希望你们，长大之后都变成注意不到这些事情，情感麻木的人。你们要发挥想象力，对自己的言行负责，在做决定之前要暂时停下来，严肃地问自己，这样做是不是真的是对的？道理大家都懂，但是却没人能做得到。我就是希望你们能明白，思考有多么重要。–柊一飒为什么这么不了解，就能这么不尊重的反驳别人？能不能保持思考，看到更多的可能性，而不是只选择看自己想看到的东西？骂的是我自己，如果对号入座了不好意思。然后说一下男性角度的不尊重。我知道很多人想说，也有很多人在说的就是打拳的事情，以张某雨为首的，吸引了大量的火力。我的评价就是在鹅城里张麻子想为民做事，黄四郎派人套上麻子头套也能随意以张麻子的名义做奸淫掳掠之事。不能简单用“思潮中的鱼龙混杂”来搪塞过去，确实属于一个思想运动中良莠不齐的老鼠屎，GM队伍中的不纯洁也会导致失败。但反过来以偏概全，只愿意用自己想看到的事情代替事情的全貌，应该也是不对的。我没有足够的智慧指点这种事情，我自己的观点就是，看到NC直接不管，一律当做50W了事。据说是某精英的尚方宝剑，我借用一下满足我个人的啊Q相信没什么问题，我也没有随意攻击。然后关于“拳”的更多看法，可以参考一下路温的B站视频BV号：BV1Qf4y1k7df。总结一下，静、思、定，思考，思考，思考。QA其实前面忍不住基本都回答了。QA就简单写写。如果有讨论，随时再补充。个人思想、文笔都不够成熟，有瑕疵和不对的地方非常非常欢迎讨论，感谢看到这里。Q1：为什么谈性别歧视？A1：回去看第一部分。Q2：为什么在这个事件大谈性别问题（因为还有很多其他问题，比如黑社会、暴力治理、腐败等等）A2：只要一个问题是好问题，任何时候都应该提。这个问题问过一位朋友，她的答复：“这次可能是因为他们的罪孽过于深重了，性骚扰+暴力+黑社会。而且这些女性似乎可以是我们身边的所有人包括我自己。…这次烧烤店的年轻女孩，她们完完全全是我们普通的每一个女孩，我感觉我的同龄人们会很有共鸣..”。如果GM必须流血流泪，既然血已经流了，那就好好利用这件事（这么说虽然不太好，当事人不是自愿的）。我们讨论一个悲剧就是不希望下一个悲剧上演。A2：关于这件事里面的其他问题，也很有意义。比如罗翔老师的视频、比如政事堂深挖行为，都有关注，也希望更多人关注。还是那句话，问题都能提，为什么只能你说话，不能别人说话。每个人根据立场、经历、视角就是有不同的看问题的角度，好的问题和思想就应该有影响力。Q3：说什么女权，女性迫害男性不也多的是。A3：说实话，无论男女，都没必要一件一件的去把一些事情列举出来攻击对方群体，小学生斗嘴吗。小样本不能说明问题的普遍性（当然了，性别对立，至少网络上性别对立是挺普遍的了，我也不知道怎么办）。说哪个女的干了啥啥啥的，建议审视一遍周围的朋友，看有没有人有行动力、有这种反社会人格对你做这种事情的，如果有，及时断交，男性也要保护好自己。开玩笑的，确实有不少能列举出来的女性迫害男性的事件，有些官方判决还一言难尽，确实有不好的影响。还是那句话，就事论事，不要以你看到的事情以偏概全（虽然我觉得看看这种枚举确实挺能挑起情绪，挺让人愤怒的）。官方示例是有很不好的影响，这个咱们也没办法。但也不要只拿女性迫害男性被轻判了说事，反过来难道没有吗，小样本不能说明普遍性。如果有详细数据分析，深入调研，得出这样的结果的话，我打脸。就算从普遍性角度分析，确实是女权运动(或好的或坏的)掀起女性意识崛起，部分人采用了过激的方式反抗，或是仅以女权为借口为自己谋利益，那不更应该参与到女权运动中，争取男性的话语权，探讨更文明、更可以接受的方式推进。Q4：我能做什么？“女性不需要男性保护”，“又那么多男的没一个上去帮忙的”A4：关于唐山事件中，见义勇为的问题。跟女性朋友聊过。这个问题属于是最具争议性的话题吧应该。结论就是，各有各的道理。为什么，因为一开头说的，(大部分)女生是受害者视角，(大部分)男生是旁观者视角。自己品一下就知道站在不同角度得出的说法不同。但我的评价是，求同存异。可以愤怒，但不要谴责，不要不解，但不要讽刺。另外，争取男女平权就是有一系列矛盾要处理，基本生理情况就是一种矛盾（再比如生孩子）。矛盾都是很复杂的，属于方法论里面扩展的许许多多的内容，我也还没有什么智慧提出好方法。但是理想是理想，理想是男性不会(使用生理优势)迫害女性，所以女性不需要男性保护，这是我们的希望。后者没有男的帮忙，希望有男的帮忙，是现状，包括让女性掌握种种“注意事项”，也是对现状的妥协。当然谴责是容易导致思想滑坡的，我不赞成。从构建最理想状况，即男女即使有生理差异，但这种差异不会被歧视，在女性需要男性生理力量，男性愿意挺身而出，在男性需要及时救治，女性也不会因为生理差异回避，为达到这样的理想，一定的谴责也是有道理的。但是“步子大了，可能会扯到蛋”。A4：至于具体可以做什么呢，从现在开始接受、关注、输出，从力所能及做起，从转发这篇文章开始。笑。拜谢。以上。图一图二图三图四" }, { "title": "中国新闻-资源地址", "url": "/posts/%E8%B5%84%E6%BA%90%E9%93%BE%E6%8E%A5/", "categories": "杂记", "tags": "记录", "date": "2022-06-05 18:12:49 +0800", "snippet": "使用飞书作为视频\\音频等资源图床。中国新闻追踪链接：跟踪清单 - 飞书云文档 (feishu.cn)" }, { "title": "致自己", "url": "/posts/%E8%87%B4%E8%87%AA%E5%B7%B1-%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90/", "categories": "随笔", "tags": "影评", "date": "2022-06-02 08:46:57 +0800", "snippet": "致自己——《天气之子》评论 即使如此依旧用力想要抓住的我们 样子丑陋吗 还是说十分美丽呢 回答我啊天气之子上映独自在影院里看时，是年纪轻轻的我整个二十几年人生里最低谷的时候。虽然第一次看的时候的感觉，跟那片记忆一样，都是浅淡而苍白，像一杯白开水，像一卷陈旧的胶卷。也许那就是被深渊和绝望吞噬后的虚无吧。不过比较真实、比较好笑的记忆是，在电影院独自看完几部电影后，一个挣扎的念头是想休学。无论做些什么好，外出旅游？宅在家里？什么都好。当然没荒诞到离家出走的念头，因为这个挣扎就消弭在痛苦地纠结于要不要给家里人打出这个电话，在电话里应该怎么交代。在快三年后的今天，非常庆幸、感激、充满幸福于在第二次观看天气之子时，已经完全从这个低谷爬了起来。这个时候啊也已经跟女朋友在一起快两年了呢，笑，虽然第二次看还是一个人看的。对了想说些什么来着，对自己。天气之子，是送给理想主义者的美丽的赞歌。曾经的我就是个彻头彻尾的理想主义者。第二次看天气之子，因为对剧情已经很熟悉，所以关注重心基本都没有放在这有些经受诟病的剧情展开上，当透过看到的意象，深入感受到导演传达的温柔的话语，于是收获了第一次所没有的热泪盈眶。帆高最开始从岛上、从家人身边的离家出走，作为第一个意象，传达的就是在被迷茫和虚无吞噬前的挣扎和反抗。作为理想主义者，打从心底的相信，人生，不会就是为了这么活下去吧。人，这么努力的活着，到底是为了追逐些什么呢。而且信息化，科技工具越发普及的当下，现实愈发地叩问年轻的心灵。“在这已经放弃的人与聪明的人才是胜者的时代，我要在哪里喘息”。什么是浪漫？浪漫就是理想主义者为了坚信的理念，又或许只是不肯放弃而苦苦攥紧的心愿，而奋不顾身地追逐那束光的勇气。对于当事人，那也许算不上什么奋不顾身，只是“我还能做的事情”。帆高来到东京后开始转晴的生活也很有意思。无论讨论何种意义的理想主义，只要在人的范畴内，都需要置于填饱肚子之后。但帆高在事务所内开始的繁忙的生活、拼命的生活，还是有一点不同，也就是影片中持续最大的矛盾碰撞，帆高、夏美他们的青年组，和小圭、警察代表的大人组的冲突。也许年轻、也许仍怀有梦想或者说幻想，所以青年组中，帆高会在工作之余回到刚到东京那个地方(很远)找那只猫，喂养、收留那只猫，会在再一次碰见阳菜时根据自己的猜想和第一反应立刻做出行动，所以夏美、帆高在做报道的过程中，会根据自己的性格，或相信、或探索地去挖掘做的事情，而小圭更多只是看做一份工作，所以夏美才会在警局外遇见帆高时第一时间选择加入逃亡计划。当然讨论这个冲突不是我，或者也不是导演的责任，导演仍然选择用温柔的口吻，温柔的笔触，给了许多铺垫、给了小圭一个转变。生活的面貌，也不是我感兴趣的。但我觉得不假思索、不考虑后果的做一件事，还是非常浪漫。（这部分参考了不少天气之子下面，安瑞不会飞的评论）忽然想到一个有意思的补充一下，其实帆高的生活技能很强，完全不是那种无病呻吟的士大夫，不仅有很强的动手能力、很强的行动力，也有敏锐的观察力、聪明的大脑，可以做出详细的计划和安排，碰到问题懂得根据自己的渠道寻求答案（虽然在网上提问不大靠谱），有点子，或者说年轻人那种爱玩、不怕尝试，比如第一时间就提出晴女计划，建好网站，迅速解决了部分客观问题。最核心的，当然是，“爱能做到的还有什么”。最美的浪漫，岂不是爱情吗。帆高和阳菜之间是爱情吗，这个问题其实反而不太重要。帆高在阳菜最痛苦的人生低谷(虽然阳菜非常坚强、非常乐观、是个天使)，给予了她为何活着的意义，属于她的人生价值就是带给他人的笑容，是那份施与所收获的感动。而阳菜给予帆高的，除了初次见面，那份人生中最好吃的晚餐，成为美好的一束白月光以外，更是阳菜那乐观、坚强性格，能够一直为别人祈祷，持续向外界释放善意和光芒。这个光芒，就是帆高所一直追逐的啊。所以最后帆高发现阳菜隐瞒了年龄，一直充当小小三人组中的大姐头，一直为所有人背负最大的压力，这神圣的光辉就发挥到了最大的作用。帆高从此再也不迷茫，他想要成为的她的光，他想要成为她的“没问题”。当帆高奔跑在电车轨道上时，也是我心中的感动第一次绷不住的时候。为什么是不是爱情这个问题不重要。因为相互的喜欢是毋庸置疑的。然后就跟小凪说的，勇敢果断的做出选择就行了，剩下的就交给命运。帆高和阳菜的相互选择，成就了，他肯定她的全部，她是他的勇气。“比起晴天，我更想选择阳菜“，她为所有人祈祷，他只为她祈祷。当帆高和阳菜坠落的时候手牵手一起祈祷，成为了我心中第二深刻的印象。”这是仰慕，还是爱恋，心中明知无法圆满“。爱、感情、情绪，除了爱情，也有延伸的更宽泛的讨论。人，为什么活着呢。或者，人靠什么活着呢。片中小篇幅展现的，晴女业务的事件，跳蚤市场、婚礼、社团活动、烟花展、盂兰盆节，展示的主要是种种事件背后人们的心情，借帆高之口所说的，“人的内心真是神奇，像是只要早上看到窗外的晴天，就能精神百倍，只要天空一片蓝色，就能感叹活着真好，能感觉自己更喜欢身旁的人了”。晴天只是一个意象，常见的意象。人总是要怀揣着某些东西才能生存，或称为感情，或称为希望，或称为光（烟花展上那束光芒真美啊）。2022的现在看这部片子，无论是我还是其他观众们，应该都有更深的体会。在后疫情时代，疫情带走了很多东西，也在持续影响着许多东西（没想到这片子还有点预言家的味道）。非必要不流动，成为每件事情第一道门槛。但人活着只需要必要的东西吗？当然人是坚强的生物，总能找到一种生存策略。我自己的思考是，总有一些，高于其他，我爱逻辑，更爱人性。最后，是我想告诉自己的什么。影片最后，是帆高思考三年找寻的答案，答案是“是我做出了选择，选择了她，选择了这样的世界，选择了要活在这里”。其实看了两遍都不太理解这个结局，特别是第一次看，感觉最后的问题，不如碰面的一个拥抱，有种引而不发的不痛快感。一直到写自己的总结，写到最后，才明白了导演的温柔。最后这个问题，正是导演对理想主义最后的回答，避免了天气之子成为一部纯粹的幻想故事。这个回答就是，每个人都有选择自己想要的生活的权利，每个人都可以追逐那个Ta，每个人都应该被钟爱，自己选择的、自己爱的世界，才是最浪漫、最理想的世界。同时结尾的大段铺垫，就是为了说明，即使心中已经怀揣了最重要的信念，身边已经有了最重要的人，但仍然要一直拷问自我，要努力地牢记初心。最美丽的，是用尽全力抓住美好的我们，最可惜的，是最美好从手中的一掠而过。写此文时，是我人生中最幸福的时候（当然可以越来越幸福）。此时的我，从从前一味追逐光、然而只是饮鸩止渴的我，成长为了有勇气去发光，相信自己，怀抱幻想。我也有了我的她，我的勇气。怀有梦想、抱有希望，这就是爱能做到的事情。所以，我？也许未来的我已完全放弃了自己的理想主义，但请牢记自己初心，牢记曾经的理想主义，燃烧成为一粒种子，诞生了勇气的花朵，支撑起了生存的动力。其实全片完整的感动，都在每次听《爱能做到的还有什么》中感受到。写的真的太妙太好，最美丽的情诗莫过于此，所以在听了一次又一次这首歌之后就开始沮丧于自己动笔这件事。实在没有自信能写出胜于这首歌的意境。其实这也是最后那个追问的意义吧，别人告诉的事情很多，自己的经历随着年龄增长也会越来越丰富，但属于自己的、自己初心只有自己知道，而任何感情都没有高低之分，对于自己来说（因此本文名为致自己）。最后谨以此歌，赠以我和我的她。​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t2022年6月1日 写于宿舍《爱能做到的还有什么》爱能做到的还有什么我一无所有便来到了这世上在永恒的缝隙间痛苦挣扎在这已经放弃的人与聪明的人才是胜者的时代里 我要在哪里喘息支配者与神 都一副事不关己的样子但其实他们心中应该很明白勇气 希望 羁绊 这些魔法毫无用处 所以大人们都避而不看即使如此 那一天的你如今依然存在于我所有正义的正中心即使全世界都与你背道而行此刻你也会在此对抗整个世界爱能做到的还有什么我能做到的还有什么是你曾给予我勇气所以我想要为你而勇敢是只属于你和我的爱如果不是你一切便没有意义爱能做到的还有什么我能做到的还有什么所谓命运就是骰子显示的数字又或许是神明的一时兴起选择与被选择 脱不掉的铠甲遥远却坚定不移的一致无法实现的心愿 无法兑现的再会无法消弭的误解 不断累积的憎恶相互谅解的声音 相互紧握的双手这颗星球今天仍旧拥抱着这一切 坦然生存爱能做到的还有什么我能做到的还有什么是你曾给予我勇气所以我想要为你而勇敢是只属于你和我的爱如果不是你一切便没有意义爱能做到的还有什么我能做到的还有什么为何要让一无所有的我们怀抱梦想为何要让我们对有限的人生抱有希望为何给予我们的一切都只会在手中一掠而过即使如此依旧用力想要抓住的我们样子丑陋吗还是说十分美丽呢 回答我啊爱的颂歌已经唱尽了在诸多电影中已经讲述尽了降生在这样荒野中的我和你即使如此爱能做到的还有很多我能做到的还有很多" }, { "title": "Markdown语法及测试", "url": "/posts/Markdown/", "categories": "教程", "tags": "Markdown", "date": "2022-04-20 21:02:58 +0800", "snippet": "前言总结一下常用的一些MD语法，以及针对于Chirpy主题渲染的一些指令。同时对各个MD Snippets在VSCode、Typora中分别测试一下快捷键和使用。使用的环境：本地Typora、Web端Jekyll+Chirpy主题MD语法教程：https://www.runoob.com/markdown/md-tutorial.htmlChirpy 语法讲解 效果个人将分别从写法、显示的效果以及快捷方式三个方面进行总结。标题 写法# h1## h2### h3#### h4 效果：效果就是这个blog的标题的效果。 快捷方式：个人最喜欢就是# + 空格的方式。 段落 写法# 一段话这是一段话 (两个空格)下一段话这是一段话(或者使用空行)下一段话# 字体格式**粗体***斜体*~~删除线~~&lt;u&gt;下划线&lt;/u&gt; 效果 这是一段话下一段话 粗体 斜体 删除线 下划线 快捷方式：直接打字就行了。在Typora中无需自行补空格。在VSCode中想开启下一行则记住补两个空格，或者中间加一个空行。字体格式常用的是粗体和斜体，快捷键为Ctrl+B和Ctrl+I. 且基本为各平台公认的快捷键，删除线和下划线根据平台为准。 列表 写法# 有序列表1. list12. list2# 无序列表- one- two# 任务列表- [ ] task 1- [x] task 2# 描述列表\\* Chirpy适用：Sun: the star around which the earth orbitsMoon: the natural satellite of the earth, visible by reflected light from the sun 效果 有序列表： 首先 第二 第三 无序列表： 章节 部分 段楼 任务列表： task 1 task 2 描述列表*： Sun the star around which the earth orbits Moon the natural satellite of the earth, visible by reflected light from the sun 快捷方式：数字 + 空格 = 有序；- + 空格 = 无序列表；任务列表我个人设置为了Ctrl+T(Typora)，与表格的冲突了(感觉表格使用频率不高，通过工具栏添加)，自己看着办。实现分层效果只要按一下Tab即可(顺便吹一下Typora在列表的交互逻辑真的非常棒，无论是想加一个列表，还是列表终止，还是列表继续，还是分层，使用都非常方便)。 链接 写法：纯URL：&lt;https://olimiya.github.io/&gt;文字上加超链接: [Olimi](https://olimiya.github.io/)使用链接变量（如果同一个链接使用很多遍，可以使用一个变量来定义该链接）：[Olimi][1][1]:https://olimiya.github.io/（这句话是看不见的） 效果：纯URL: https://olimiya.github.io/文字上加超链接：Olimi 链接变量：Olimi 快捷方式：先复制链接。在Typora中Ctrl+K粘贴链接，并输入文字（默认为文字加超链接）；在VSCode中先输入文字，然后选中文字Ctrl+V(在Markdown All in One的插件支持下)。 代码 写法# 代码块```cppint main(){ return 0;}```# 内联代码`hello，world!`# 内联代码：突出强度文件路径 *`/path/to/a/file.extend`{: .filepath} 效果int main(){ return 0;}hello，world!/path/to/a/file.extend（Chirpy主题） 快捷方式：Typora中，使用Ctrl+Shift+B添加代码块，Ctrl+Shift+`设为内联代码(这个快捷键感觉不太好按，一般还是直接打`)；在VSCode中，可以使用code关键字，或者打```后自动弹出语言选择(docs-markdown插件)。表格 写法：省略。。手打也太难了。参考一下即可：| Column1 | Column2 || ------- | ------- || Row1 | test || Row2 | aaa || Row3 | bb || Row4 | cc | 效果： Column1 Column2 Row1 test Row2 aaa Row3 bb Row4 cc 快捷方式：Ctrl+T,Typora默认快捷键。VSCode在docs-markdown插件支持下可自定义快捷键。图片 写法：![文字](url)如：![hello-world](https://miro.medium.com/max/1400/1*veRna0Vbw1_4OUnzW9rSzA.jpeg)* Chirpy. 程序窗口的截图可以考虑显示阴影效果，在light模式下会看到阴影：![Desktop View](https://raw.githubusercontent.com/cotes2020/chirpy-images/main/posts/20190808/window.png){: .shadow }test next 效果： 快捷方式：可以看到与普通链接区别就在于前面多了一个!，所以操作基本与普通链接一样即可。 特殊：对于图片处理，在写MD时算是一个比较大的问题，因为根据上述的语法，添加图片需要一个url(比如我上面用的是互联网上随便找的一个url)，但是自己写的时候，比如随便截的一个图，如何获取url呢。一个思路是将图片保存到本地(比如写的文章的同级目录)然后使用局部路径索引的URL。这个思路有两个不足，其一是对每张图片都要手动保存，较为麻烦，能否直接读取粘贴板；第二是局部的URL在文章发布时，图片索引的那个局部URL肯定是不对的，怎么将图片也一同发布到互联网可索引到的URL。针对第一个问题，提供两个平台的解决方案：第一，使用Typora，对于粘贴板的图片直接粘贴即可，可选地自动将图片保存到文章同级目录或TEMP目录或文章目录下新建的一个$(filename).assets目录等。第二，使用VSCode+Paste Image插件，使用Ctrl+alt+v粘贴图片(默认)，同样会自动把图片拷贝到当前目录，可对保存路径、插入路径等进行设置，详细设置在工具贴中再进行介绍。针对第二个问题，这里也提两个解决方案：第一，博客部署的相对路径。主要是针对写的文章是要发布到个人博客网站上去的，写的文章也处于博客项目的路径中(比如使用Hexo框架或Jekyll框架等)。这时图片保存到框架中特定目录，如assets/img中，即可随同文章一同发布。第二，使用Typora+PicGo+图床。详细的配置这里省略。主要过程是，首先使用本地图片，在发布时，一键将图片上传至图床(个人使用Github)，然后引用图床的互联网可访问URL。// TODO：上述写得太啰嗦了..不应该放在MD语法教程中展开，需要整理放入一个工具贴中。引用(Quote) 写法&gt; block&gt; 引用内容 效果： 引用内容 支持嵌套，以及和列表等一起使用 内层引用 第一 第二 快捷方式：&gt;加一个空格，实现嵌套使用Tab.提示(Prompt)*这个是基于引用的Block实现的，属于Chirpy对Block渲染的一种优化显示而已， 写法&gt; Example line for prompt.{: .prompt-info }(可选prompt-tip、prompt-info、prompt-warning、prompt-danger) 效果（普通MD看不出来啦，要在Chirpy主题中渲染才会显示效果）： Example line for prompt. Example line for prompt. Example line for prompt. Example line for prompt. 快捷方式：与引用基本一致。眉批(Front Matter)* 写法---title: Markdown语法及测试 # 标题 （使用时将注释删除）date: 2022-04-20 21:02:58 +0800 # 时间categories: [TOP_CATEGORIE, SUB_CATEGORIE] # 分类，最大两层tags: [TAG] # TAG names should always be lowercase，可以有无数个标签description: . # 描述author: # 作者信息 name: Full Name link: https://example.comtoc: false # 关闭目录comments: false # 关闭评论math: true # 加载数学功能mermaid: true # 启用Mermaidpin: true # 置顶帖子---为yaml语法(缩进表示层次关系)，是用于标识该MD文件的元参数。便于博客框架识别文章的相关描述和属性配置。这里标注的属性特指在Jekyll框架中使用的。脚注 写法\"从前有座山，山里有个和尚。\"[^Olimi][^Olimi]: Olimi是个童话故事作家。（既然说是脚注，这个注释一般放在文章最后，有的MD渲染器会自动放到最后） 效果 “从前有座山，山里有个和尚。”1 快捷方式：这个语法本质上跟前面定义的链接变量一样，使用[]定义一个变量。用的不多，用的时候手动打即可。Typora中工具栏有这个命令。 数学使用 KaTeX 或者 MathJax 来渲染数学表达式。 写法# 内联公式$x+y$# 公式块$$\\begin{Bmatrix} a &amp; b \\\\ c &amp; d\\end{Bmatrix}$$$$\\begin{CD} A @&gt;a&gt;&gt; B \\\\@VbVV @AAcA \\\\ C @= D\\end{CD}$$ 效果：$X+Y$\\[\\begin{Bmatrix} a &amp; b \\\\ c &amp; d\\end{Bmatrix}\\]\\[\\begin{CD} A @&gt;a&gt;&gt; B \\\\@VbVV @AAcA \\\\ C @= D\\end{CD}\\] 快捷方式：直接打$。技巧 HTML元素：不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。如：使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑​\t使用 Ctrl+Alt+Del 重启电脑. 转义：Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠(\\)转义特殊字符。如： **文本加粗** \\*\\* 正常显示星号 \\*\\* ​\t文本加粗​\t** 正常显示星号 **.​\t需要转义的字符包括：\\ 反斜线` 反引号* 星号_ 下划线{} 花括号[] 方括号() 小括号# 井字号+ 加号- 减号. 英文句点! 感叹号MermaidMermaid是图表生成工具，可以用来绘制流程图、时序图、甘特等。 写法，类似于代码块。Chirpy中要渲染需要开启Mermaid:true。横向流程图```mermaidgraph LRA[方形] --&gt;B(圆角) B --&gt; C{条件a} C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图]``` 效果：graph LRA[方形] --&gt;B(圆角) B --&gt; C{条件a} C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图]更多的示例参考：https://www.runoob.com/markdown/md-advance.html小结总结过程时间有点紧张，并不是每个语法都进行了深入研究和使用，部分语法平时用的较少(集中在后面集中高级语法)。形成文章较为粗糙，在后续使用过程将完善和补充。 Olimi是个童话故事作家。 &#8617; " }, { "title": "Linux常用命令总结", "url": "/posts/Linux%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE/", "categories": "教程", "tags": "Linux编程", "date": "2022-04-12 00:00:00 +0800", "snippet": "参考API网址：Linux 命令大全Linux资源配置查看汇总查看系统配置，汇总信息CPU、内存、硬盘、网络等等：sudo lshw | grep less输出：olimi-pc description: Computer width: 64 bits capabilities: smp vsyscall32 *-core description: Motherboard physical id: 0 *-memory description: System memory physical id: 1 size: 12GiB *-cpu product: Intel(R) Core(TM) i5-7300HQ CPU @ 2.50GHz vendor: Intel Corp. physical id: 2 bus info: cpu@0 width: 64 bits capabilities: fpu fpu_exception wp vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp x86-64 constant_tsc rep_good nopl xtopology cpuid pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 movbe popcnt aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single pti ssbd ibrs ibpb stibp fsgsbase bmi1 avx2 smep bmi2 erms invpcid rdseed adx smap clflushopt xsaveopt xsavec xgetbv1 xsaves md_clear flush_l1d arch_capabilities *-display description: 3D controller product: Microsoft Corporation vendor: Microsoft Corporation physical id: 0 bus info: pci@cd21:00:00.0 version: 00 width: 32 bits clock: 33MHz capabilities: bus_master cap_list configuration: driver=dxgkrnl latency=0 resources: irq:0 *-scsi physical id: 3 logical name: scsi0 *-disk:0 description: EXT4 volume product: Virtual Disk vendor: Linux physical id: 0.0.0 bus info: scsi@0:0.0.0 logical name: /dev/sda version: 1.0 serial: 3255683f-53a2-4fdf-91cf-b4c1041e2a62 size: 256GiB capabilities: journaled extended_attributes large_files huge_files dir_nlink recover 64bit extents ext4 ext2 initialized configuration: ansiversion=5 created=2019-04-11 00:35:05 filesystem=ext4 lastmountpoint=/swap logicalsectorsize=512 modified=2022-04-10 11:06:59 mounted=2022-04-10 11:06:59 sectorsize=4096 state=clean *-disk:1 description: EXT4 volume product: Virtual Disk vendor: Linux physical id: 0.0.1 bus info: scsi@0:0.0.1 logical name: /dev/sdb logical name: / version: 1.0 serial: 3255683f-53a2-4fdf-91cf-b4c1041e2a62 size: 256GiB capabilities: journaled extended_attributes large_files huge_files dir_nlink recover 64bit extents ext4 ext2 initialized configuration: ansiversion=5 created=2019-04-11 00:35:05 filesystem=ext4 lastmountpoint=/distros logicalsectorsize=512 modified=2022-04-10 11:07:01 mount.fstype=ext4 mount.options=rw,relatime,discard,errors=remount-ro,data=ordered mounted=2022-04-10 11:07:01 sectorsize=4096 state=mounted *-network:0 DISABLED description: Ethernet interface physical id: 1 logical name: bond0 serial: 6e:14:5b:8f:54:0e capabilities: ethernet physical configuration: autonegotiation=off broadcast=yes driver=bonding driverversion=5.10.16.3-microsoft-standard-WS firmware=2 link=no master=yes multicast=yes *-network:1 DISABLED description: Ethernet interface physical id: 2 logical name: dummy0 serial: ea:b4:ca:e1:ed:db capabilities: ethernet physical configuration: broadcast=yes driver=dummy driverversion=5.10.16.3-microsoft-standard-WS *-network:2 description: Ethernet interface physical id: 3 logical name: eth0 serial: 00:15:5d:08:47:9a size: 10Gbit/s capabilities: ethernet physical configuration: autonegotiation=off broadcast=yes driver=hv_netvsc driverversion=5.10.16.3-microsoft-standard-WS duplex=full firmware=N/A ip=192.168.33.43 link=yes multicast=yes speed=10Gbit/s信息显示太多，可以单独只输出某个部分，比如：$ sudo lshw -c cpu -c memory *-memory description: System memory physical id: 1 size: 12GiB *-cpu product: Intel(R) Core(TM) i5-7300HQ CPU @ 2.50GHz vendor: Intel Corp. physical id: 2 bus info: cpu@0 width: 64 bits capabilities: fpu fpu_exception wp vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp x86-64 constant_tsc rep_good nopl xtopology cpuid pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 movbe popcnt aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single pti ssbd ibrs ibpb stibp fsgsbase bmi1 avx2 smep bmi2 erms invpcid rdseed adx smap clflushopt xsaveopt xsavec xgetbv1 xsaves md_clear flush_l1d arch_capabilitiesCPU单独的一些查看，CPU(静态信息):cat /proc/cpuinfo | grep model\\ name\t内存内存Memory(动态信息)：$ free -mh total used free shared buff/cache availableMem: 12G 263M 12G 64K 74M 11GSwap: 4.0G 241M 3.8G free - Display amount of free and used memory in the system硬盘查看硬盘信息(动态)：$ df -lh Filesystem Size Used Avail Use% Mounted on/dev/sdb 251G 8.7G 230G 4% /tmpfs 6.2G 0 6.2G 0% /mnt/wsltools 118G 61G 57G 52% /initnone 6.2G 0 6.2G 0% /devnone 6.2G 8.0K 6.2G 1% /runnone 6.2G 0 6.2G 0% /run/locknone 6.2G 0 6.2G 0% /run/shmnone 6.2G 0 6.2G 0% /run/usertmpfs 6.2G 0 6.2G 0% /sys/fs/cgroupdrivers 118G 61G 57G 52% /usr/lib/wsl/driverslib 118G 61G 57G 52% /usr/lib/wsl/lib# 我这是WSL df - report file system disk space usage显卡显卡：$ lspci cd21:00:00.0 3D controller: Microsoft Corporation Device 008e# 我这还是WSL设置虚拟内存下面是Linux上设置虚拟内存的方式(在Linux中需要做的是设置交换文件，即swap) 执行“sudo swapon -s”命令，查看是否已经存在swap file 如果第一步存在swapfile则需要先禁用 sudo swapoff /swapfile 修改swap 空间的大小为8Gsudo dd if=/dev/zero of=/swapfile bs=1M count=8192 设置文件为“swap file”类型sudo mkswap /swapfile 启用swapfilesudo swapon /swapfile链接：https://www.jianshu.com/p/e656bead51ee注意(坑)：以上操作必须一起完成！！否则在swapoff了原本的swapfile之后会导致无法开机。因为系统没办法挂载原本的swapfile。如果中间没完成，记得重新把/swapfile挂载回去！然后如果是使用WSL，配置方式：添加文件.wslconfig，文件路径为 C:\\Users\\&lt;UserName&gt;\\.wslconfig.文件内容：# Settings apply across all Linux distros running on WSL 2[wsl2]# Sets amount of swap storage space to 8GB, default is 25% of available RAMswap=40GB注意如果是动态修改不能更改swap位置，否则不能生效(这里跟上面linux同理，不能更改系统原本的swapfile文件，否则会导致系统损坏，或者不起效)。要更改swap位置，必须重装或新安装时就指定。" }, { "title": "windows 反流氓", "url": "/posts/%E5%8F%8D%E6%B5%81%E6%B0%93/", "categories": "杂记, windows", "tags": "windows", "date": "2022-04-10 00:00:00 +0800", "snippet": "算是挖的坑还是搞完..问题1：Clash查看日志之狂发流量 鲁大师 云盘 解决：再见了您，进沙盒待着吧。问题2：偷偷看的后台服务 AntiCheatExpert：腾讯安全，反作弊，还算正当理由吧。关了别想玩TX系游戏了。 QQProtect：保护QQ运行的服务（bingdu） 解决：UWP版的QQ试试？TIM也是一样的。 VMWare：把VM开头的服务禁了。然后写了个启动的脚本，第一次运行VMware前先运行脚本。发现很不方便，故放弃。 进沙盒： 腾讯系：腾讯会议（测试这个会导致麦克风权限等出问题，懒得折腾，还是弄回来了）" }, { "title": "windows内存占用解决", "url": "/posts/windows%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/", "categories": "杂记, windows", "tags": "windows", "date": "2022-04-10 00:00:00 +0800", "snippet": "Windows开机内存占用超过30%（6G/18G）,Come on:Round 1 msconfig-&gt;常规：有选择的启动-&gt;服务-&gt;隐藏所有Microsoft服务，全部禁用。Ban了再说。需要的自己单独启。 可能有很多服务启不来了，比如vmware的服务。所以这个还是算了吧。很麻烦，没多大好处。 发现触摸板配置没了（主要是连接外部设备时禁用触摸板的设置），查找刚刚关闭的服务，是SynTPEnhService(制造商：Synaptics)，开启它。设置以后记得点击应用才会生效。 添加虚拟内存，设置-&gt;系统-&gt;关于-&gt;高级系统设置-&gt;高级-&gt;性能：设置-&gt;更改，改成8192G. 建议位置放在非C盘。 重新审视一下自己设置自启动的软件：任务管理器-&gt;启动。将没必要的禁用。有些服务是偶尔想要使用一次，但日常百分之八十时间都没用，没必要一直挂着，用的时候再手动启动就行了。个人把像everything、搜词这样的都关了。个人自启动的有：Clash(代理)、Ditto(粘贴板，Windows有自带的，在设置-&gt;系统-&gt;剪贴板中开启，个人觉得不够好用，不能缓存如图片等)、Traffic Monitor(占用率监视)等。 经过前三步。重启后内存占用仅20%以下（2G左右) Round 2重启后再打开任务管理器瞧瞧，看下有哪些好康的. Vmmen：每次开启占用很高。是安装WSL使用的Hyper-v导致的。不过一段时间后就消失。WSL不用时最好还是shutdown了，关注window + hper-v +docker可能有坑：https://zhuanlan.zhihu.com/p/277825426。 secure system：一直都存在。名字可疑的像病毒..解释是：由于启用内存完整性需要启用虚拟化，以便可以打开 Hyper-V 虚拟机以包含核心 Windows 操作系统组件。又是Hyper-v，真麻烦。动不了，留着吧。 开始：开始菜单。留着 Windows Modules Installer Worker：windows更新。可以在设置-&gt;更新中，暂停更新，或者关闭自动更新。 MoUSO Core Worker Process：管理 Windows 更新的安装。同Windows更新。不过这几个都是开机一会就没了。一般可以不用管，除非占用大量资源。 Microsoft Text input Application：设置-&gt;隐私-&gt;墨迹书写和键入个性化 Microsoft Office Click-to-Run (SxS)：Microsoft Office自带的东西。一直会留着，没占用太多不管。 然后是后台服务。任务管理器-&gt;服务，一个一个看看。主要挑前几个占用较高的吧。参考：https://www.zhihu.com/question/36192602 服务主机UtcSvc(Connected User Experiences and Telemetry): 微软用于改进 Windows 平台的体验和质量的。干掉。 服务主机WindowsEventlog：大概是事件日志，留着吧。 windowsUpdate：这个也是开机一段时间就没了。想干掉可以干掉。 Diagnostic：断你的系统错误，反馈给微软，帮你自动解决。屁用。干掉。 还有好多懒得一个一个去找了… 更多服务解释：https://blog.51cto.com/u_13762952/3628967 虚拟机装个win10虚拟机，卡死人了。 服务主机 SysMain 它的工作是随着时间的推移维护和改善系统性能 services.msc 关掉SysMain antimalware service executable Windows Defender扫描杀毒(你才是最大的毒，烦死我的毒)。 用dControl干掉Defender，或者至少关掉实时防护。 Microsoft Compatibility Telemetry Microsoft 兼容性遥测是 Windows 10 中的一项服务，其中包含有关 Windows 设备及其相关软件如何工作的技术数据，并定期将此数据发送给 Microsoft，以通过修复发生的潜在问题来增强用户体验。 在 TaskScheduler 窗口中，转到此路径：Task Scheduler Library\\Microsoft\\Windows\\Application Experience。查找“Microsoft Compatibility Appraiser” 禁用 微软小娜 Cortana 关闭：gpedit.msc 计算机配置 -&gt; 管理模版 -&gt; Windows组件 -&gt; 搜索，双击 “允许使用 Cortana” -&gt; 已禁用 -&gt; 确定。 Get-AppxPackage -allusers Microsoft.549981C3F5F10 Remove-AppxPackage System占用高 关闭Superfetch服务，可能就是SysMain 还有很多没找着没发现，看到再说吧。一般就是开机时特别卡，卡一会就好了。这样的话可以考虑把快速启动关了。总结看下来就是傻逼windows，东西贼多，问题贼大(上述每个都可能出现问题，导致占用一下子飙升到70以上)。真想搞个纯净版。看到个很欢乐的：找绿色软件 ：带来许多问题使用services.msc ：解决一些问题换linux ：解决更多问题使用轻量级发行版比如Manjaro(Xfce4) ：解决大多数问题……更往下的一档是……从0开始编译Gentoo/LFS ：带来许多问题就这样吧。win10开机占个3、4G内存很正常。所以说那些买4G内存的电脑怎么能不卡(很多朋友一问说新买的电脑很卡，都不用说，肯定是4G内存..)既然内存占用低了，那可多整点活了，来开个wallpaper engine吧~更多：https://www.zhihu.com/question/36192602https://blog.csdn.net/hyongilfmmm/article/details/116134977" }, { "title": "Linux大内存应用进程被杀-读写4GB文件记录", "url": "/posts/Linux%E5%A4%A7%E5%86%85%E5%AD%98%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E8%A2%AB%E6%9D%80-%E8%AF%BB%E5%86%994GB%E6%96%87%E4%BB%B6%E8%AE%B0%E5%BD%95/", "categories": "杂记, Linux", "tags": "Linux编程", "date": "2022-04-10 00:00:00 +0800", "snippet": "前言最近搞MPI实验，与其说在搞并行计算，还不如说在搞操作系统…入门最大的问题还不是MPI编程，就是搞系统优化就够呛的。无论是Windows还是Linux，对于吃超大内存的应用都不是十分友好，以往没有什么超大规模数据处理、大内存应用的处理经验。故此记录一般。问题简单描述一下简单的应用场景：需要生成一大批随机数据(float类型，大小在0-1之间)，最大大小位4GB。然后从文件中读取数据，使用qsort对数据进行排序。问题：4GB float数据，需要至少16G的内存空间，差不多超出了物理RAM的大小。强行执行的话，会在运行一段时间后，程序被杀掉。xxx(进程ID) is killed。解决在开始聊解决方案之前，先来过一下Linux操作系统的一些配置请求命令。Linux查看配置 查看系统配置，汇总信息CPU、内存、硬盘、网络等等： sudo lshw | grep less输出：olimi-pc description: Computer width: 64 bits capabilities: smp vsyscall32 *-core description: Motherboard physical id: 0 *-memory description: System memory physical id: 1 size: 12GiB *-cpu product: Intel(R) Core(TM) i5-7300HQ CPU @ 2.50GHz vendor: Intel Corp. physical id: 2 bus info: cpu@0 width: 64 bits capabilities: fpu fpu_exception wp vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp x86-64 constant_tsc rep_good nopl xtopology cpuid pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 movbe popcnt aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single pti ssbd ibrs ibpb stibp fsgsbase bmi1 avx2 smep bmi2 erms invpcid rdseed adx smap clflushopt xsaveopt xsavec xgetbv1 xsaves md_clear flush_l1d arch_capabilities *-display description: 3D controller product: Microsoft Corporation vendor: Microsoft Corporation physical id: 0 bus info: pci@cd21:00:00.0 version: 00 width: 32 bits clock: 33MHz capabilities: bus_master cap_list configuration: driver=dxgkrnl latency=0 resources: irq:0 *-scsi physical id: 3 logical name: scsi0 *-disk:0 description: EXT4 volume product: Virtual Disk vendor: Linux physical id: 0.0.0 bus info: scsi@0:0.0.0 logical name: /dev/sda version: 1.0 serial: 3255683f-53a2-4fdf-91cf-b4c1041e2a62 size: 256GiB capabilities: journaled extended_attributes large_files huge_files dir_nlink recover 64bit extents ext4 ext2 initialized configuration: ansiversion=5 created=2019-04-11 00:35:05 filesystem=ext4 lastmountpoint=/swap logicalsectorsize=512 modified=2022-04-10 11:06:59 mounted=2022-04-10 11:06:59 sectorsize=4096 state=clean *-disk:1 description: EXT4 volume product: Virtual Disk vendor: Linux physical id: 0.0.1 bus info: scsi@0:0.0.1 logical name: /dev/sdb logical name: / version: 1.0 serial: 3255683f-53a2-4fdf-91cf-b4c1041e2a62 size: 256GiB capabilities: journaled extended_attributes large_files huge_files dir_nlink recover 64bit extents ext4 ext2 initialized configuration: ansiversion=5 created=2019-04-11 00:35:05 filesystem=ext4 lastmountpoint=/distros logicalsectorsize=512 modified=2022-04-10 11:07:01 mount.fstype=ext4 mount.options=rw,relatime,discard,errors=remount-ro,data=ordered mounted=2022-04-10 11:07:01 sectorsize=4096 state=mounted *-network:0 DISABLED description: Ethernet interface physical id: 1 logical name: bond0 serial: 6e:14:5b:8f:54:0e capabilities: ethernet physical configuration: autonegotiation=off broadcast=yes driver=bonding driverversion=5.10.16.3-microsoft-standard-WS firmware=2 link=no master=yes multicast=yes *-network:1 DISABLED description: Ethernet interface physical id: 2 logical name: dummy0 serial: ea:b4:ca:e1:ed:db capabilities: ethernet physical configuration: broadcast=yes driver=dummy driverversion=5.10.16.3-microsoft-standard-WS *-network:2 description: Ethernet interface physical id: 3 logical name: eth0 serial: 00:15:5d:08:47:9a size: 10Gbit/s capabilities: ethernet physical configuration: autonegotiation=off broadcast=yes driver=hv_netvsc driverversion=5.10.16.3-microsoft-standard-WS duplex=full firmware=N/A ip=192.168.33.43 link=yes multicast=yes speed=10Gbit/s 信息显示太多，可以单独只输出某个部分，比如： $ sudo lshw -c cpu -c memory *-memory description: System memory physical id: 1 size: 12GiB *-cpu product: Intel(R) Core(TM) i5-7300HQ CPU @ 2.50GHz vendor: Intel Corp. physical id: 2 bus info: cpu@0 width: 64 bits capabilities: fpu fpu_exception wp vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp x86-64 constant_tsc rep_good nopl xtopology cpuid pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 movbe popcnt aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single pti ssbd ibrs ibpb stibp fsgsbase bmi1 avx2 smep bmi2 erms invpcid rdseed adx smap clflushopt xsaveopt xsavec xgetbv1 xsaves md_clear flush_l1d arch_capabilities 单独的一些查看，CPU(静态信息): cat /proc/cpuinfo | grep model\\ name\t 内存Memory(动态信息)： $ free -mh total used free shared buff/cache availableMem: 12G 263M 12G 64K 74M 11GSwap: 4.0G 241M 3.8G free - Display amount of free and used memory in the system 查看硬盘信息(动态)： $ df -lh Filesystem Size Used Avail Use% Mounted on/dev/sdb 251G 8.7G 230G 4% /tmpfs 6.2G 0 6.2G 0% /mnt/wsltools 118G 61G 57G 52% /initnone 6.2G 0 6.2G 0% /devnone 6.2G 8.0K 6.2G 1% /runnone 6.2G 0 6.2G 0% /run/locknone 6.2G 0 6.2G 0% /run/shmnone 6.2G 0 6.2G 0% /run/usertmpfs 6.2G 0 6.2G 0% /sys/fs/cgroupdrivers 118G 61G 57G 52% /usr/lib/wsl/driverslib 118G 61G 57G 52% /usr/lib/wsl/lib# 我这是WSL df - report file system disk space usage 显卡： $ lspci cd21:00:00.0 3D controller: Microsoft Corporation Device 008e# 我这还是WSL Linux与windows不同(大部分情况下没有图形界面)，主要是在命令行界面中，查看单独某一个信息比汇总的信息舒服，所以记忆一下主要几种资源的查看方式还是有好处的。编程对于程序语言中的高级接口来说，一般不需要考虑调用接口的数据大小。数据读写由接口内部缓冲机制来保证。比如C语言中，fwrite和fread，一般来说可以直接相信它们能够正确调用(而无论数据的大小)。如果是特别大的文件，在Linux中启用64位文件偏移(默认32位，即long类型长度)，则可以添加CFLAGSS，-D_FILE_OFFSET_BITS=64示例：gcc make_data.c -o make-data -D_FILE_OFFSET_BITS=64另外，如果从高层考虑数据大小(或者程序空间的大小，堆空间、栈空间等)，可以考虑把数据切块： // handle big data unsigned long handled_number = 0; unsigned long number_of_Gb = 1073741824; while (N &gt; number_of_Gb) { fwrite(data + handled_number, sizeof(float), number_of_Gb, file); handled_number += number_of_Gb; N -= number_of_Gb; } fwrite(data + handled_number, sizeof(float), N, file);但是对一般排序算法，数据需要一起加载，则无法使用。系统配置要使上述的程序顺利完成，在最恶劣情况需要将4GB数据、float类型，读取到内存中，对于程序来说，4G*4，至少需要16GB的逻辑内存(不一定需要这么强的物理资源)。我们的物理资源，即内存条可能只有8G、或者16G，在虚拟机中不一定能分配到这么大的资源。这个时候就需要虚拟内存的技术。只要保证虚拟内存+RAM大于程序需要的逻辑内存即可。反过来，如果虚拟内存+RAM小于程序需要的逻辑内存，那么程序必然会访问超出逻辑地址空间的资源，导致程序被杀掉。所以程序不能跑起来一定要检查内存是不是被吃光了。下面是Linux上设置虚拟内存的方式(在Linux中需要做的是设置交换文件，即swap) 执行“sudo swapon -s”命令，查看是否已经存在swap file 如果第一步存在swapfile则需要先禁用 sudo swapoff /swapfile 修改swap 空间的大小为8Gsudo dd if=/dev/zero of=/swapfile bs=1M count=8192 设置文件为“swap file”类型sudo mkswap /swapfile 启用swapfilesudo swapon /swapfile链接：https://www.jianshu.com/p/e656bead51ee注意(坑)：以上操作必须一起完成！！否则在swapoff了原本的swapfile之后会导致无法开机。因为系统没办法挂载原本的swapfile。如果中间没完成，记得重新把/swapfile挂载回去！然后如果是使用WSL，配置方式：添加文件.wslconfig，文件路径为 C:\\Users\\&lt;UserName&gt;\\.wslconfig.文件内容：# Settings apply across all Linux distros running on WSL 2[wsl2]# Sets amount of swap storage space to 8GB, default is 25% of available RAMswap=40GB注意如果是动态修改不能更改swap位置，否则不能生效(这里跟上面linux同理，不能更改系统原本的swapfile文件，否则会导致系统损坏，或者不起效)。要更改swap位置，必须重装或新安装时就指定。更多设置和解释：WSL高级设置配置-官网Understanding your WSL2 RAM and swap - Changing the default 50%-25%配置完成后，实测4GB数据能够正常运行，4GB float数据排序，需要时间：1.310827E+03(排序时间)。意外在VMWare虚拟机配置swap过程中，踩了一个坑，就是上面提到swapoff之后没完成整个过程就关机了，导致无法启动。整个过程主要是，在分配swap10GB空间时，磁盘刚好满了。然后就想关机扩展磁盘空间。然后扩展磁盘空间又必须把快照删了…然后就启动不了(原因在上面提了)。寄。咋办呢。解决：开启时，查看下方一行提示，按ESC进入高级选项，选择ubuntu recovery mode，选择root，进入命令行。把原本占满磁盘空间的swapfile改小一点，重新挂载上swapfile，重启即可(具体命令参见上面)。扩展磁盘的方式：VMWare，点击磁盘大小，将最大大小改大，启动后使用gparted挂载空间(这是图形化方式，不能用图形化用自带的fdisk)" }, { "title": "VMWare虚拟机网络探讨-桥接、NAT、仅主机配置", "url": "/posts/VMWare%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%81%94%E7%BD%91%E9%97%AE%E9%A2%98-%E6%A1%A5%E6%8E%A5-NAT-%E4%BB%85%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE/", "categories": "教程", "tags": "VMWare, 虚拟化技术", "date": "2022-04-10 00:00:00 +0800", "snippet": "前言今天搞实验把工作环境搬来搬去的过程中，把带着VM环境的移动硬盘弄掉了好几次，VMWare里面的虚拟机终于不堪折磨宕机掉了，磁盘文件损坏。还好之前留了快照可以恢复（所以定期备份快照很重要，特别是重要，配置了很多东西的虚拟机，不是说重装就重装的）。然后切换工作环境，网络环境变更啥的，搞得脑子晕了，一时上不了网就直接把虚拟机网络编辑里面的东西全重置了。重置就重置吧，重新配置呗。问题就是以前配过的东西全忘光了。果然工作不总结的话就会出现重复工作，一个问题没记住解决方案就会导致一直是问题。。借此机会把虚拟机的网络配置这块好好总结一下。结合看的多篇写得较好的中文博客，把网络配置问题形成自己的理解。VMWare网络配置VMware网络配置就是设置虚拟机网络虚拟化的方式，目的是将虚拟机连接到网络上，实现虚拟机的联网或者主机与虚拟机的连接或者虚拟机局域网之间的互联。在VMWare中有三种模式，分别是桥接模式、NAT模式和主机模式。物理机网络IP示例：无线局域网适配器 WLAN: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::61d3:e211:e09:c336%15 IPv4 地址 . . . . . . . . . . . . : 10.44.11.54 子网掩码 . . . . . . . . . . . . : 255.255.0.0 默认网关. . . . . . . . . . . . . : 10.44.255.254 以太网适配器 VMware Network Adapter VMnet1: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::852:80cf:9d6b:f9dc%6 自动配置 IPv4 地址 . . . . . . . : 169.254.249.220 子网掩码 . . . . . . . . . . . . : 255.255.0.0 默认网关. . . . . . . . . . . . . :以太网适配器 VMware Network Adapter VMnet8: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::1c9b:6567:f003:9d42%4 IPv4 地址 . . . . . . . . . . . . : 192.168.1.1 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . :桥接模式桥接模式解释桥接模式的理解： 桥接模式就是将主机网卡与虚拟的网卡利用虚拟网桥进行通信。类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中，所以所有桥接下的网卡与网卡都是交换模式的，相互可以访问而不干扰。在桥接模式下，虚拟机IP地址需要与主机在同一网段，如果需要联网，则网关与DNS需要与主机网卡一致。原文链接：https://blog.csdn.net/qq_39192827/article/details/85872025这里的虚拟机和物理主机就是平等的地位，相当于网络中间的一台新主机(通过物理主机这个交换机接入网络)。所以虚拟机中上网的方式与物理主机相同。物理主机怎么上网，虚拟机就怎么上网。比如物理主机使用WIFI无线连接，DHCP自动分配IP。那虚拟机联网也一样，向WIFI的路由器请求DHCP分配IP和DNS，完成后即可上网。如果物理主机使用有线网连接，那虚拟机内也要配置相应的IP地址(这个IP一般就是组织内分配的静态IP)。这里的核心问题就是，虚拟机能否像物理机一样请求到同样的资源。比如DHCP分配的IP可能有限，有线网的静态IP可能对于个人也是唯一的。比如个人在校园网内使用，无线网可能可以多终端登录，有线网则必然不行。于是这就是桥接模式的特点： 可以将虚拟机看做一台新电脑，接入了宿主机所在的网络。 虚拟机允许访问宿主机所在网络的其他电脑 虚拟机允许访问Internet互联网（当然宿主机必须可以访问互联网才行）。 主机和虚拟机通过单位局域网，互联互通。(原文链接：https://segmentfault.com/a/1190000024580532)第二第四点特点决定了，当我们想将多台虚拟机(部署在一台或多台电脑上)连成一个局域网时，桥接模式就是首选。这种方法配置起来和使用起来也是较为方便，是VMware的默认配置。结合一个具体例子：比如物理主机(宿主机)的IP地址为10.44.11.54，那虚拟机连接后自动分配的IP可能为：10.44.11.128。因为获取方式与物理主机相同，所以网段也一致。桥接模式下的所有虚拟机都是和主机是在同一网段的，可以把它们看成是”平等”的关系，这就会带来一些麻烦，比如192.168.1段下只有254个主机地址，所以桥接模式下虚拟机和物理的总数不能超过这个数字！桥接模式配置 进入VMware-&gt;Workstation-&gt;编辑-&gt;虚拟网络编辑器。 需要管理员权限或者点击右下角更改设置。 在网络列表中选择“VMnet0”,如果没有，可以点击“添加网络”按钮增加，VMnet0是VMWare默认设置，当然是用其他网卡也是可以的。 选择宿主机访问外部网络的物理网卡。连有线网时就选择有线网，连无线网时选择有线网。网卡名称可在右下角右键网络状态显示图。 然后修改虚拟机网络适配器为桥接模式。 关于这里复制物理网络连接状态的选项： 如果在笔记本电脑或其他移动设备上使用虚拟机，请选择复制物理网络连接状态。 当您在有线或无线网络之间进行移动时，该设置会导致 IP 地址续订。 续订IP是指网卡从路由器的DHCP服务器获得IP地址的过程。网卡通过DHCP对IP都有租定时间，等到了一定的时间，你的电脑会自动续订IP，以方便继续使用。不选择复制物理网络连接状态选项： 如果采用DHCP的方式来分配IP地址，当电脑网络从有线或无线网络之间进行移动时，DHCP会重新分配ip地址，即虚拟机IP地址会发生变化。选择复制物理网络连接状态选项: 复制网络连接状态仅用于笔记本电脑在有线网络与无线网络之间切换时进行IP地址续订，虚拟机IP地址不变原文链接：https://blog.csdn.net/qq_41638851/article/details/105214736 ​\t一般就不用勾了。 确定保存之后，重启(开启)虚拟机即可使用桥接模式。 虚拟机内部。如果是使用无线联网，那一般系统会默认选择DHCP自动分配IP，无需自行配置。若是有线联网，则需自行配置IP和DNS等。配置方式根据自己虚拟机系统和版本，以及连接方式，自行搜索即可。如：ubuntu18.04：https://blog.csdn.net/u014454538/article/details/88646689桥接模式的选择 默认选择，配置较少，如果处于网络信任度较高、网络较自由(自己家)，不用考虑如何登录上网这些问题时，可首选使用。 如果有登录问题，就不要用了。信任度不高的也是，外部网络可以直接访问该虚拟机。 第二点也意味着，如果想把虚拟机暴露给外界。比如远程登录虚拟机，就需要使用桥接模式(或者NAT+内网穿透)。再比如暴露虚拟机中的web服务等。NAT模式NAT模式解释NAT(网络地址转换)，是一种在IP数据包通过路由器或防火墙时重写来源IP地址或目的IP地址的技术(wiki)。 比如192.168.0.123这个地址要访问internet，它的数据包就要通过一个网关或者路由器，而网关或者路由器拥有一个能访问internet的ip地址，这样的网关和路由器就要在收发数据包时，对数据包的IP协议层数据进行更改（即 NAT），以使私有网段的主机能够顺利访问internet。原文链接：https://blog.csdn.net/zlfing/article/details/76943895也是网络管理中常用的方式了。优点在于NAT内部局域网与外界隔离，较为安全。内部地址空间也是独立进行维护，与公网IP分离，有效降低IP地址空间不足的问题。缺点是数据包都要经过NAT设备(路由器或网关)更改源和目的IP，重新查询NAT地址转换表，降低了通信效率。在VMWare中也一样。 在NAT模式中，主机网卡直接与虚拟NAT设备相连，然后虚拟NAT设备与虚拟DHCP服务器一起连接在虚拟交换机VMnet8上，这样就实现了虚拟机联网。VMware Network Adapter VMnet8网卡是为了实现主机与虚拟机之间的通信。 可见NAT模式下主机更像是虚拟机们的”路由器”。所以虚拟机和主机不再同一网段下，可以理解为主机是虚拟机的”上级”。————————————————原文链接：https://blog.csdn.net/qq_39192827/article/details/85872025同样举个例子，比如物理主机的IP是10.44.11.54，虚拟机分配到的IP可能是192.168.1.128(具体网段是什么是自己设置的)，但可以看到网段是不一致的。关于NAT模式，可以看到主机内有一个Adapter VMnet8网卡，这个网卡是为了实现主机和虚拟机之间的通信。有了这个网卡，主机和虚拟机之间就可以通信。主机可以ping通虚拟机的IP，虚拟机可以ping通主机的IP。比如上面的例子，主机可以ping通192.168.1.128，虚拟机可以ping通10.44.11.54，也可以ping通192.168.1.1(虚拟网卡VMnet8的IP)。如果禁掉这个网卡。则192.168.1.1和192.168.1.128之间无法通信。但虚拟机仍可连接外网，同时也能ping通10.44.11.54，原因是虚拟机是通过Vmnet8交换机与主机网卡(10.44.11.54)连接，只要主机可以联网(10.44.11.54能用)，虚拟机自然也可以使用。(这里有个比较疑惑的地方：按道理禁掉Vmnet8，主机应该是无法访问虚拟机的，但个人测试的情况是主机能够ping通192.168.1.128，参考下面的测试结果)这里要区分，虚拟网卡的概念，虚拟网卡是一个系统内部的设备，即使它不是物理上存在的，只是逻辑上的资源。看上图的含义就是，Adapter VMnet8和VMnet8交换机，是分别处于两个框内，属于不同系统的资源。前者属于Windows，后者属于VMWare的HyperVisor。这也是使用桥接模式时，主机内看不到VMnet0的原因。因为主机和虚拟机在网络上就是平等的地位，无需在主机内部构建一个虚拟网卡资源来进行通信。另外，NAT内部网络之间都属于同一个网段，也是可以相互访问和通信的。测试样例：主机：以太网适配器 VMware Network Adapter VMnet1: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::852:80cf:9d6b:f9dc%6 自动配置 IPv4 地址 . . . . . . . : 169.254.249.220 子网掩码 . . . . . . . . . . . . : 255.255.0.0 默认网关. . . . . . . . . . . . . :以太网适配器 VMware Network Adapter VMnet8: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::1c9b:6567:f003:9d42%4 IPv4 地址 . . . . . . . . . . . . : 192.168.1.1 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . :以太网适配器 以太网 3: 媒体状态 . . . . . . . . . . . . : 媒体已断开连接 连接特定的 DNS 后缀 . . . . . . . :无线局域网适配器 WLAN: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::61d3:e211:e09:c336%15 IPv4 地址 . . . . . . . . . . . . : 10.44.11.54 子网掩码 . . . . . . . . . . . . : 255.255.0.0 默认网关. . . . . . . . . . . . . : 10.44.255.254$ ping 192.168.1.128正在 Ping 192.168.1.128 具有 32 字节的数据:来自 192.168.1.128 的回复: 字节=32 时间&lt;1ms TTL=64来自 192.168.1.128 的回复: 字节=32 时间&lt;1ms TTL=64来自 192.168.1.128 的回复: 字节=32 时间&lt;1ms TTL=64来自 192.168.1.128 的回复: 字节=32 时间&lt;1ms TTL=64虚拟机：$ ip addr ...2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 00:0c:29:e3:1c:15 brd ff:ff:ff:ff:ff:ff inet 192.168.1.128/24 brd 192.168.1.255 scope global dynamic noprefixroute ens33..~ ⌚ 22:46:44$ ping 192.168.1.1PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.64 bytes from 192.168.1.1: icmp_seq=1 ttl=128 time=0.256 ms64 bytes from 192.168.1.1: icmp_seq=2 ttl=128 time=0.330 ms64 bytes from 192.168.1.1: icmp_seq=3 ttl=128 time=0.416 ms^C主机：VMnet8关闭以太网适配器 VMware Network Adapter VMnet1: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::852:80cf:9d6b:f9dc%6 自动配置 IPv4 地址 . . . . . . . : 169.254.249.220 子网掩码 . . . . . . . . . . . . : 255.255.0.0 默认网关. . . . . . . . . . . . . :无线局域网适配器 WLAN: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::61d3:e211:e09:c336%15 IPv4 地址 . . . . . . . . . . . . : 10.44.11.54 子网掩码 . . . . . . . . . . . . : 255.255.0.0 默认网关. . . . . . . . . . . . . : 10.44.255.254 $ ping 192.168.1.128正在 Ping 192.168.1.128 具有 32 字节的数据:来自 192.168.1.128 的回复: 字节=32 时间&lt;1ms TTL=64来自 192.168.1.128 的回复: 字节=32 时间&lt;1ms TTL=64 虚拟机：$ ip addr ...2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 00:0c:29:e3:1c:15 brd ff:ff:ff:ff:ff:ff inet 192.168.1.128/24 brd 192.168.1.255 scope global dynamic noprefixroute ens33..~ ⌚ 21:59:22$ ping 10.44.11.54PING 10.44.11.54 (10.44.11.54) 56(84) bytes of data.64 bytes from 10.44.11.54: icmp_seq=1 ttl=128 time=0.684 ms64 bytes from 10.44.11.54: icmp_seq=2 ttl=128 time=0.644 ms64 bytes from 10.44.11.54: icmp_seq=3 ttl=128 time=0.589 ms^C--- 10.44.11.54 ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 2037msrtt min/avg/max/mdev = 0.589/0.639/0.684/0.038 ms~ ⌚ 21:59:28$ ping 192.168.1.1PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.^C--- 192.168.1.1 ping statistics ---2 packets transmitted, 0 received, 100% packet loss, time 1010msNAT模式配置 进入VMware-&gt;Workstation-&gt;编辑-&gt;虚拟网络编辑器。 在网络列表中选择“VMnet8”,如果没有，可以点击“添加网络”按钮增加，为什么是VMnet8呢，这个应该是VMWare默认设置，当然是用其他网卡也是可以的。 选择“NAT模式”，确定选中“将主机虚拟适配器连接到此网络”和“是用本地DHCP服务将IP地址分配给虚拟机”选项 子网IP:192.168.1.0，子网掩码：255.255.255.0，为了与“仅主机模式”区分，我习惯将“NAT模式”的子网网段配置为“192.168.1.0”，这个可以根据自己的喜好来设置。(比如NAT设置20网段、仅主机设置30网段，根据自己网段习惯来即可) 修改虚拟机设置，将网络适配器修改为“NAT模式” 看上图可以看到，NAT有一个虚拟的DHCP服务器。所以默认就是通过DHCP动态分配IP的，所以虚拟机内部一般无需配置。检查一下是否选择的是默认的DHCP分配即可。 NAT模式的选择NAT模式的特点： 虚拟机和宿主机组成小局域网，做到互联互通。 虚拟机通过宿主机访问外部网络（此时宿主机起到路由器作用），但外部网络不能访问虚拟机 虚拟机允许访问Internet互联网（当然宿主机必须可以访问互联网才行）第一点的实现，对于虚拟机来说，都处于NAT内网，自然就是一个局域网内，然后宿主机是通过Adapter VMnet8加入到这个局域网中。第二点外部网络不能访问，就是NAT的特性，既是优点也是缺点。需要解决这个缺点可以考虑使用内网穿透。那什么时候选择NAT呢： 不能选择桥接模式时。 虚拟机内不能获取宿主机一样的上网条件。 IP地址紧张。 选择自动分配IP，懒得为静态IP做配置。NAT模式端口转发当我们必须使用NAT模式，又需要暴露虚拟机内部的服务，又不想使用内网穿透时，可以考虑配置NAT端口转发。配置路径在：VMware-&gt;Workstation-&gt;编辑-&gt;虚拟网络编辑器，选择VMne8，NAT设置，端口转发添加规则。仅主机模式主机模式用的较少。仅主机模式可有看成是NAT模式去除了虚拟NAT设备，然后使用VMware Network Adapter VMnet1虚拟网卡连接VMnet1虚拟交换机来与虚拟机通信的，Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只与主机相互通讯。将上图与NAT模式的图对比，主要区别就在于去除了虚拟NAT设备，使用Vmnet1将主机网卡和虚拟机隔离开来。仅主机模式是指只有虚拟机和主机之间互相通信，但虚拟机也可以访问外界网络，只是不能收到外界网路的访问。所以该模式最大特点就是安全吧。同样有DHCP服务器，所以虚拟机IP也是自动配置。配置方式： 进入VmWare-&gt;主菜单-&gt;虚拟网络编辑器 在网络列表中选择“VMnet1”,如果没有，可以点击“添加网络”按钮增加，为什么是VMnet1呢，这个应该是VMWare默认设置，当然是用其他网卡也是可以的。 选择“仅主机模式” 并选择“将主机虚拟适配器连接到此网络”和“是用本地DHCP服务将IP地址分配给虚拟机”选项 子网IP:10.10.10.0，子网掩码：255.255.255.0，我习惯将“仅主机模式”的子网网段配置为“10.10.10.0”，这个可以根据自己的喜好来设置。 然后修改虚拟机设置，将网络适配器修改为“仅主机模式”小结一些错误的说法： 桥接模式：如果物理网卡可以上网，那么桥接的软网卡也没有问题了，这就是桥接上网的原理了。 （物理网卡能上网不代表虚拟机也能用同样方式上网） NAT模式：主机更像是虚拟机们的”路由器”，通过VMnet8虚拟网卡为虚拟机分发地址。(虚拟机分发地址不是通过VMnet8，是虚拟DHCP服务器) NAT模式：所以虚拟机能ping到主机的IP，但是主机ping不到虚拟机的IP。(虚拟机和主机可以相互ping) 仅主机模式：提供的是主机和虚拟机之间的网络互访。只想让虚拟机和主机之间有数据交换，而不想让虚拟机访问Internet，就要采用这个设置了。(仅主机模式同样可以上网)关于ping(即主机与虚拟机的连接情况)： 桥接模式下，主机与虚拟机随便ping，毕竟就是一个网络内不同主机。如果ping不通，就是被主机主动拦截了，检查防火墙的情况，选择关闭或设置允许进入的网段。 NAT模式下，主机和虚拟机也可以通过VMnet8互相ping通。 区别1、这三种模式都可以访问外网，只是访问方式不同2、这三种模式都可以自动获取ip，手动填写的ip需要注意， 桥接模式，虚拟机当成主机旁，同一网段下的主机配置即可。 NAT模式，配置的虚拟DHCP网段，ip、网关、DHCP网段在同一网段下。禁用VMnet8网卡后，可连外网、不可连主机。 仅主机模式，配置的虚拟DHCP网段，ip、网关、DHCP网段在同一网段下。禁用VMnet1网卡后什么都连不上了。 选哪个1、最省事的，选桥接模式，直接选择就可以用2、NAT模式自动获取IP也很方便，需要注意开启VMnet8网卡3、仅主机模式一般很少用，但是它安全，需要注意开启VMnet1网卡————————————————原文链接：https://blog.csdn.net/a__int__/article/details/111208626其他情况如前言中提到，我是使用使用着重置了网络配置重新设置。并不是从零开始安装。因此碰到了更多一些情况。 NAT模式无法使用。NAT根据上述配置完成后仍无法使用。WIN+R，services.msc，检查一下VM开头的服务，发现没有VMWare NAT Service服务(这个应该就是NAT模式中那个虚拟的NAT设备吧)，类似地那个VMWare DHCP Service可能也是。搜索了一下。解决方案：在虚拟网络编辑器中还原默认设置，然后重启电脑。即可恢复。如果还不行，再来一遍。(个人在这里卡了很久，因为我一开始就是还原默认设置之后开始配置NAT的，结果就是没有NAT服务。不太相信，结果还是重启试试解决的)。 类似第一点，VM这几个服务似乎会常驻后台。在不需要的情况下可自行关闭。不建议设置为手动，手动开启。个人试了一段时间，每次开VMvare前都忘记开一次，太麻烦了。关闭的脚本： net stop VMAuthdServicenet stop VMnetDHCPnet stop \"VMware NAT Service\"net stop VMUSBArbServiceecho VM所有服务已关闭 WSL的网络配置WSL2默认使用的是NAT模式。因此也存在上述NAT模式的一些问题。使用、配置和解释，先挖个坑在这里。总结本文总结过程参考了多篇博客，有许多优秀的大佬总结得已经非常出色。重新写一遍主要是因为一个是形成自己的理解，另外是每篇博客都集中在某一个方面，个人在阅读、理解和测试之后汇总、总结了一遍。在文章中引用了许多大佬的文章，大部分都标注了链接。如有侵权，请联系我删除。完整的引用：配置参考：https://segmentfault.com/a/1190000024580532原理参考：https://blog.csdn.net/qq_39192827/article/details/85872025https://blog.csdn.net/zlfing/article/details/76943895https://blog.csdn.net/a__int__/article/details/111208626" }, { "title": "Windows Terminal + WSL + Ubuntu + 图形化 总结", "url": "/posts/Windows-Terminal-+-WSL-+-Ubuntu-+-%E5%9B%BE%E5%BD%A2%E5%8C%96-%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93/", "categories": "教程", "tags": "Windows Terminal, WSL", "date": "2022-03-27 19:49:00 +0800", "snippet": "前言最近上高级操作系统的研究生课，又开始折腾Linux系统。虽然我挺菜的，但就是差生文具多。所以先折腾折腾一个舒适的Linux环境吧。配置Linux环境大致分为三种： 双系统：划分一块硬盘空间，通过U盘等作为安装盘从镜像开始构建系统。最彻底最真实的Linux环境。好处就是更能折腾、自由度更高，不会出现各种兼容性问题。缺点是配置起来比较麻烦，不能自由切换windows与linux。 虚拟机：使用VMVare或VBox等软件，直接加载一个系统镜像启动虚拟机，硬盘分配可以是动态的。好处就是最方便快捷，也便于迁移（直接把整个虚拟机拷贝或复制到其他地方就能实现系统的迁移、移动或者复制），缺点是虚拟机运行效率不高，资源占用率高，可能会比较卡。 WSL：windows10开始内置的Linux子系统，是windows从内核层开发进行支持的GNU/Linux环境，优点是不会产生传统虚拟机或双启动设置开销，效率高，配置、使用起来也较为方便，非常适合用来进行轻量级的Linux开发。缺点是，并不是真正的Linux系统，使用范畴和使用方式还有所约束（比如硬件交互、图形化方式等等）。但好的地方在于，毕竟是微软爸爸推的东西，更新迭代还是可以期待的。总结一下本人的需求跟使用情况，以上三种我都有尝试跟使用。双系统对于我来说最主要的问题就是耗电速度太快了！不插电源的情况下是百分之20百分之20的掉，虚拟机则是又不方便用起来又low，于是开始尝试一下WSL。除了关于WSL整个配置过程，在使用Windows Terminal过程的一些问题和配置情况也会进行记录。之前发过了一次，重新发一次是因为，CSDN富文本编辑器是真滴难用！！每次回来补充记录就是折磨。故此重新弄一份MD的取代原本的。Linux子系统WSL启动方式：​​​​​​​​​​​​​​启动后忘记要不要重启了，最好重启一下吧，windows是这样的。重启后在powershell输入：wsl --install即可进行安装。默认会安装Ubuntu 20.04的系统（当前）。可以使用wsl --list --online查询可以安装的系统。或者也可以通过Microsoft store微软商店中搜索WSL，安装需要的系统。但这种安装方式似乎是默认使用C盘进行安装的，好像强行改路径会出问题。Microsoft store微软商店中安装的软件可以在设置-&gt;应用和功能-&gt;搜索应用-&gt;移动，去修改路径。于是本人使用的安装方式是手动安装的方式，就是先手动安装WSL2，下载系统镜像，直接安装系统镜像包。整个流程大概：# 1 启用适用于 Linux 的 Windows 子系统 启用过了可以不运行这个dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart# 2 启用虚拟机功能dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart# 3 下载WSL2安装 https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi# 4 设置WSL2wsl --set-default-version 2# 5 下载Ubuntu镜像包 https://wslstorestorage.blob.core.windows.net/wslblob/CanonicalGroupLimited.UbuntuonWindows_2004.2021.825.0.AppxBundle# 6 把它解压，解压两次，运行Ubuntu.exe安装 或者可以使用这个命令Add-AppxPackage .\\app_name.appx更新+1：安装、下载、卸载、更改目录的操作可以参考一下：$ wsl -l -v NAME STATE VERSION* Ubuntu Running 2 Ubuntu-18.04 Running 2$ wsl --export Ubuntu-18.04 d:\\wsl\\ubuntu18.04.tar$ wsl --unregister Ubuntu-18.04$ wsl --import Ubuntu-18.04 d:\\wsl\\ubuntu\\Ubuntu-18.04 d:\\wsl\\ubuntu18.04.tar --version 2$ del d:\\wsl\\ubuntu18.04.tar上述整个过程的官方文档：安装WSL|Microsoft Docs​旧版 WSL 的手动安装步骤更新+2：输入：wsl --set-default-version 2之前，需启动BIOS虚拟化：bcdedit /set hypervisorlaunchtype auto然后重启电脑。否则会显示： 请启用虚拟机平台 Windows 功能并确保在 BIOS 中启用虚拟化。Windows Terminal安装就直接通过Microsoft store安装即可（这里本人碰到个问题是，挂着代理的情况下连不上Microsoft store，要关掉代理，还试过连上了但一直显示无法连接Internet没办法安装，这时换一个网络，比如手机热点，就解决了）。安装完之后可以到设置里面更改位置，本人是放在D盘，更改方式：设置-&gt;应用和功能-&gt;搜索应用-&gt;移动另外，设置-&gt;系统-&gt;存储-&gt;更改新内容的保存位置，可以修改应用保存位置，但本人改了之后并没有什么反应。更新：关于安装路径：在新电脑安装，安装完成后无法移动位置。但是设置-&gt;系统-&gt;存储-&gt;更改新内容的保存位置，倒是可以在重装之后装到指定磁盘去。个人装到了D盘，就是多出了很多文件夹有点难看。关于右键菜单：似乎安装在D盘，自动添加的右键菜单也没了。不过没事，刚好可以自定义。方法：使用ContextMenuManager添加。-d 是指定目录为当前目录。可以再添加多级菜单，选定打开的终端实例。 更多命令行参数：[Windows 终端命令行参数 Microsoft Docs](https://docs.microsoft.com/zh-cn/windows/terminal/command-line-arguments?tabs=windows) 本人的Windows Terminal主要添加了CMD、Power Shell、Git Bash、Ubuntu这几个终端。具体的使用和配置已经非常人性化了，可自行摸索。更新：摸了一段时间，发现主题还是好难看，又摸索了一下。先放一下最终成果图。 CMD Power Shell Ubuntu其实首要的需求是清晰看到命令行信息，对比度高，不要特别沉闷（默认的CMD），几个终端之间有一定区分度。只要满足这些条件即可。最终选定的配置是： CMD：One Half Dark主题，开亚克力，不透明度0.8. Power Shell：AdventureTime主题，开亚克力，不透明度0.7. Ubuntu：Contrast Light主题，不开亚克力（个人建议背景图和亚克力不要一起开），加背景图（注意背景图整体色调跟选择的主题保持一定的相性，比如亮色主题选择浅色一点的背景图），背景不透明度0.25.主题网站主流主题的介绍更新+1 Git Bash使用了一段时间，win端普通使用喜欢用git-bash，将git-bash设为了默认。要几个要注意的是： 命令使用：GIT安装目录\\bin\\bash.exe –login -i (bash命令与WSL的bash冲突，指定完整路径，添加后面两个option)； git-bash中文问题：在GIT安装目录\\etc\\bash.bashrc最后添加：export LANG=”zh_CN.UTF-8”export LC_ALL=”zh_CN.UTF-8” 更新+2 Git-Bash闪烁Git更新以后（Git建议还是可以持续更新的），GitBash终端在按删除键跟type补全时老会闪烁，闪烁这个不是Bug，就是个功能（不怕瞎的人才会用吧），在Windows Terminal中高级-&gt;铃声通知样式可以设置。GitBash要关闭这个，创建~/.inputrc，添加：set bell-style none。即可。最后配置文件懒得放了，天天改。更新+3 管理员权限参考：windows terminal使用管理员权限打开_qq_30262407的博客-CSDN博客_windows terminal 管理员更新：WT更新以后，似乎可以通过勾选设置里的”以管理员身份运行此配置文件“，即可获得管理员权限打开终端。不过为windows安装一个sudo也是件好事。个人采用Gsudo方案： 安装Gsudo $ PowerShell -Command \"Set-ExecutionPolicy RemoteSigned -scope Process; iwr -useb https://raw.githubusercontent.com/gerardog/gsudo/master/installgsudo.ps1 | iex\"$ Set-ExecutionPolicy RemoteSigned #允许执行脚本$ Import-Module 'C:\\Program Files (x86)\\gsudo\\gsudoModule.psd1' # 添加sudo别名 配置WT的setting.json // 这行改成这样\"commandline\": \"sudo powershell.exe\", PowershellWindows上自带的终端来说还是powershell比较好用，虽然语法感觉更复杂。那也自定义增强一下。运行执行脚本：$ Set-ExecutionPolicy RemoteSigned #允许执行脚本手动刷新环境变量制作一个命令RefreshEnv：# 制作一个存放RefreshEnv这种小脚本的文件夹，添加到环境变量PATH。New-Item $env:USERPROFILE\\Documents\\bin -itemtype directory | Out-NullSet-ItemProperty `\t-Path \"HKCU:\\Environment\\\" `\t\t-Name \"Path\" ` -Value ((Get-ItemPropertyValue -Path \"HKCU:\\Environment\\\" -Name \"Path\") +`\t\t\t\";\" + ($env:USERPROFILE) + \"\\Documents\\bin;\")\t\t# 刷新环境变量脚本Invoke-WebRequest -Uri \"https://raw.githubusercontent.com/chocolatey/choco/master/src/chocolatey.resources/redirects/RefreshEnv.cmd\" -OutFile (\"$env:USERPROFILE\"+\"\\Documents\\bin\\RefreshEnv.cmd\")Windows包管理器Windows安装软件基本都是通过安装包方式，但繁多的小功能软件自行管理会显得很麻烦，所以如果有一个类似ubuntu的apt系统也挺好的。windows有一个自带winget，但是个人使用一直显示源报错，其中一个源是msstore，而微软商店在国内网络经常抽风。所以选择另一个管理器scoop。安装： Scoop 默认使用普通用户权限，其本体和安装的软件默认会放在 %USERPROFILE%\\scoop(即 C:\\Users\\用户名\\scoop)，使用管理员权限进行全局安装 (-g) 的软件在 C:\\ProgramData\\scoop。如果有自定安装路径的需求，那么要提前设置好环境变量，否则后续再改不是一件容易的事情。所以先设置用户安装路径$env:SCOOP='D:\\Scoop'[Environment]::SetEnvironmentVariable('SCOOP', $env:SCOOP, 'User')然后以非管理员权限打开powershell# Change execution policySet-ExecutionPolicy RemoteSigned -scope CurrentUser# Download and install scoopiwr -useb get.scoop.sh | iex# Add useful buckets (resembles repos in apt)scoop bucket add extrasscoop bucket add versions之后就可以scoop install安装包，比如scoop install sudo.on-my-posh类似于zsh和oh-my-zsh（Linux装机必备），在powershell中获取类似主题体验。oh-my-posh新版本不能使用powershell的module安装方式，许多21年以前的博客安装说明已失效。以官方说明为准：Windows Oh My Posh安装：# scoopscoop install https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/oh-my-posh.json# powershell脚本Set-ExecutionPolicy Bypass -Scope Process -Force; Invoke-Expression ((New-Object System.Net.WebClient).DownloadString('https://ohmyposh.dev/install.ps1'))然后： 安装字体（Nerd字体），因为很多主题使用图标，需要图标字体支持。 配置字体到终端使用，用的是Windows Terminal在全局设置即可。 配置终端使用oh-my-posh. notepad $PROFILE # profile中输入：oh-my-posh init pwsh | Invoke-Expression 配置和可能碰到的问题：# 缺少这个可能导致上面$profile加载失败Install-Module -Name PSReadLine -AllowPrerelease -Force # PSReadLine# 如果上面这行出错，执行以下Install-Module -Name PackageManagement -Repository PSGallery -ForceInstall-Module -Name PowerShellGet -Repository PSGallery -Force# 重启终端Install-Module -Name Az.StorageSync -AllowPrerelease -AllowClobber -Force# posh-git 作用是powershell中集成git相关环境，帮助主题能够显示git项目的状态Install-Module posh-git -Scope CurrentUser 为添加命令历史记录、tab补全、搜索历史记录等功能，配置profile文件，完整如下：Import-Module posh-git # 引入 posh-gitoh-my-posh init pwsh --config \"$env:POSH_THEMES_PATH\\cobalt2.omp.json\" | Invoke-ExpressionSet-PSReadLineOption -PredictionSource History # 设置预测文本来源为历史记录Set-PSReadlineKeyHandler -Key Tab -Function Complete # 设置 Tab 键补全Set-PSReadLineKeyHandler -Key \"Ctrl+g\" -Function MenuComplete # 设置 Ctrl+d 为菜单补全和 IntellisenseSet-PSReadLineKeyHandler -Key \"Ctrl+z\" -Function Undo # 设置 Ctrl+z 为撤销Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward # 设置向上键为后向搜索历史记录Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward # 设置向下键为前向搜索历史纪录上面可以看到主题配置，个人选择了cobalt2主题，主题选择可查看：Themes Oh My Posh.然后字体高亮上面可以配置$pshome\\profile.ps1实现，个人不想折腾这个，直接使用Window Terminal自带的主题方案得了。还有一些像conda配置关联的问题，没碰到先不管了。参考： Windows Terminal + PowerShell 的配置 - 丏谷 Miangu Blog (zhangtianrong.github.io) Window终端 Powershell zsh同款 - 知乎 (zhihu.com) Scoop 安装使用 - 知乎 (zhihu.com)Cygwin动机：获得一个轻量级的类Unix终端，可以安装一些Linux工具，同时能够在Windows终端中获取一些简易Linux功能（比如在CMD中获取ls这个指令） Cygwin 是: 提供功能的大量 GNU 和开源工具 类似于Windows上的Linux发行版。 一个DLL（cygwin1.dll），它提供了大量的POSIX API功能。 不是： 一种在Windows上运行本机Linux应用程序的方法。你必须 如果您希望应用程序在 Windows 上运行，请从源代码重新生成应用程序。 一种神奇地使本机 Windows 应用程序了解 UNIX® 的方法 信号、PTY 等功能。同样，如果你想利用Cygwin的功能，你需要从源代码构建你的应用程序。 当然除去使用Cygwin，还有类似的msys2等工具，自行选择吧，个人这里就仅需要一些很简单的功能。更复杂的支持使用前面的WSL，这里再安装一个轻量级的就是因为WSL打开较慢，占用率较高，同时不能提供外界直接使用unix指令。安装安装就官网下载安装包一路安装即可。注意： 安装时选择一个源，推荐选择清华源：http://mirrors.ustc.edu.cn. 选择安装的包时，建议至少选择一个wget包。这里不用纠结安装哪些包，后续可以随时回来变更。 安装完成后，记得不要删除安装包。后续管理包都需要这个安装包，比如增加、卸载包。添加包不会覆盖原安装的包。包管理器关于包管理：就像前面说的，要通过安装包去管理包，这确实就是官方的途径。 除了安装程序之外，Cygwin中没有包管理。安装程序仅将更新应用于当前安装，它不会覆盖您已有的软件包（除非您明确说明）。 因此，请重新运行安装程序以安装新软件包。不过还是有一些第三方巩固，比如apt-cyg，提供类似于apt-get（但apt-cyg != apt-get，有时候出错了就乖乖用安装包维护吧）。apt-cyg安装：wget https://raw.githubusercontent.com/transcode-open/apt-cyg/master/apt-cyginstall apt-cyg /bin然后即可使用apt-cyg install nano安装。另外，可通过apt-cyg mirror指定安装源。apt-cyg mirror http://mirrors.ustc.edu.cn/cygwin/此时可能出现nano-4.9-1.tar.xz: 失败sha512sum: 警告：1 个校验和不匹配是由于wget导致的，换成lynx的话就会消失（安装lynx包卸载wget包），但是会导致更多的报错，所以还是愉快的当做看不到吧~关于包管理器，还看到用Chocolatey管理的choco install bash --source=cygwin个人不使用这个windows包管理器，就不尝试了。参考链接：updates - How to install new packages on Cygwin? - Super User使用配置把Cygwin添加到Windows Terminal中：打开WT设置，添加新配置文件，复制一个原有的比如Powershell，然后修改名称，命令，图标即可，命令修改为：D:\\software-dev\\cygwin\\bin\\bash.exe -i -l.然后为了其他终端获取unix命令，添加环境变量，将cygwin\\bin、cygwin\\sbin、cygwin\\usr\\local\\bin等加上，具体添加可自行选择一个或多个。Ubuntu文件系统基于WSL使用Ubuntu，最方便的一点是，两个系统是直接互通的，什么意思呢？在WSL里面输入pwd.exe，可以看到结果为：$ pwd.exe//wsl$/Ubuntu/home/olimi所以在Windows里面可以直接使用这个路径访问WSL里面的文件。可以在文件系统右键我的电脑添加一个网络映射器，固定上述路径：​反过来在WSL中可以直接使用cd访问windows文件，注意windows的硬盘是通过mnt挂载~ ⌚ 20:13:03$ cd /mnt/c//mnt/c ⌚ 20:13:05$ pwd/mnt/c这里还有一个需求是希望每次打开时自动进入用户目录，windows terminal提供了startingDirectory的选项，但如果设置为上述那个路径，类似于//wsl$/Ubuntu/home/olimi，会出现一个问题时，开机时因为不会自动启动WSL（一般也不需要开机启动），所以这个时候访问上面的路径是无法访问的，这就出现先有鸡还是先有蛋的问题，是先要启动WSL再能进入WSL。解决方案：在ubuntu的终端脚本（.bashrc、.zshrc等）添加一句命令，cd ~.后续因为集成到文件目录右键菜单，直接在此处打开WSL，所以取消了这个设置。确实没啥必要。真要过去直接输入~就行了。zsh上面这里截取的命令可以看到，命令行提示跟默认的终端不一致，是因为我配置了zsh shell。这是非常建议使用的一个终端，非常强大（至少大神都是这么说的）。 目前常用的 Linux 系统和 OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh， 这货绝对是马车中的跑车，跑车中的飞行车，史称『终极 Shell』，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」，Github 网址是：https://github.com/robbyrussell/oh-my-zsh。这玩意就像「X天叫你学会 C++」系列，可以让你神功速成，而且是真的。​安装也非常简单： 安装zs1.先看下自己有哪一些 shellcat /etc/shells2.如果没有 zsh 需要安装sudo apt-get install zsh #Ubuntu Linux 记得先升级下 apt-getsudo yum install zsh #Redhat Linux3.安装完成后设置zsh 为默认shellchsh -s /bin/zsh #安装完成后设置当前用户使用 zsh 并重启 wsl 安装oh my zshwget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.shsh install.sh 添加插件和修改主题# 安装 Oh My Zsh 插件\t1.安装 zsh-syntax-highlighting（代码高亮）\tgit clone https://github.com/zsh-users/zsh-syntax-highlighting $ZSH_CUSTOM/plugins/zsh-syntax-highlighting\t2.安装 zsh-autosuggestions（自动建议）\tgit clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions\t3.安装 zsh-completions（自动补全）\tgit clone https://github.com/zsh-users/zsh-completions $ZSH_CUSTOM/plugins/zsh-completions\t4.zsh-com­ple­tions 插件需要将 autoload -U compinit &amp;&amp; compinit 添加到.zshrc，输入命令可一键添加：\t[ -z \"`grep \"autoload -U compinit &amp;&amp; compinit\" ~/.zshrc`\" ] &amp;&amp; echo \"autoload -U compinit &amp;&amp; compinit\" &gt;&gt; ~/.zshrc\t5.把需要启用的插件写入到配置文件中，使用 sed 命令一键操作：\tsed -i '/^plugins=/c\\plugins=(git sudo z zsh-syntax-highlighting zsh-autosuggestions zsh-completions colored-man-pages)' ~/.zshrc\t\t6.最后应用配置\tsource ~/.zshrc以上几种插件是需要额外安装，其他一些插件在./plugins中有，可直接启用。oh my zsh 本人使用主题是amuse，可以在https://github.com/ohmyzsh/ohmyzsh/wiki/Themes这里查看各种主题。贴个成品图：​​​服务器图形用户界面-远程桌面登录使用VNC的解决方案。 在官网：[RealVNC® - Remote access software for desktop and mobile RealVNC](https://realvnc.com/) 下载服务端和客户端。其中服务端是收费的。自行搜索一个破解码即可。安装完之后记得重启一下电脑，windows是这样的*2…但有个问题是这个破解码是每次重启后就失效了。没有深究这个的原因，简单在.zshrc脚本中，添加如下命令：alias sudo='sudo env PATH=$PATH 'alias vncinit=\"vnclicense -add BQ24G-PDXE4-KKKRS-WBHZE-F5RCA\"然后先调用sudo vncinit来解决。另外还有像xrdp+远程连接的解决方案，个人尝试后觉得比较卡，就不赘述了。还有类似于MobaXTerm软件的解决方案，内置了XServer，但跟上面xrdp一样卡，也不赘述了。更新： 之前一次弄到最后没什么精力了，所以将这部分偷懒了。有时间把这部分补充完整。要远程控制ubuntu桌面，主要就是就是通过VNC或RDP协议。相关概念参考ubuntu远程桌面连接方式(vnc、xrdp、vino、xorg等概念) – late哥哥笔记 (lategege.com).需要远程桌面登录肯定需要一个桌面系统，ubuntu桌面版自带gnome，ubuntu服务端默认没有桌面。关于ubuntu的桌面系统： ubuntu的图形化界面主要有几种:unity\\gnome\\xfce\\kde 其中unity在ubuntu早期版本中常用，新版本ubuntu默认桌面是gnome,而如果安装的是ubuntu server系统，需要在图形化操作，一般安装xfce，它非常轻量，kde在ubuntu中不常用。VNC第一种最简单是安装的ubuntu带有默认的桌面系统，内置有VNC服务端，这里用的是WSL没有默认的桌面系统就不进行尝试了。同样的道理优先选择轻量级的xfce(不过即使是轻量级也有2-3G，穷人的辣鸡云服务器就不敢装了). VNC服务默认端口为5900端口，注意同时只能有一个vnc服务，端口占用无法共存。 安装桌面 # 首先更新sudo apt-get updatesudo apt-get upgrade # 安装要选择桌面管理环境gdm3或lightdm，这里选的轻量级lightdmsudo apt-get install xubuntu-desktop # 这里有个小问题是安装会自动安装locate，会扫描磁盘建立索引方便查找文件，问题是在WSL里会把挂载的外部windows文件系统也一同扫描，速度可能相当慢，可使用以下方式省略扫描windows：add /mnt to PRUNEPATHS in /etc/updatedb.conf# 或者尝试以下命令sudo apt-get install xorgsudo apt-get install xfce4 安装VNC Server。这里的选择很多，VNC是一种协议，有许多实现版本，比如开源的vnc4server、tightvncserver，付费的realvncserver（有破解码）. # 多选一sudo apt-get install vnc4server # 这个在默认源中没有，要在/etc/apt/sources.list中添加deb http://cn.archive.ubuntu.com/ubuntu/ bionic universe sudo apt-get install tightvncserver https://downloads.realvnc.com/download/file/vnc.files/VNC-Server-6.11.0-Linux-x64.deb 启动 vncserver# 输出You will require a password to access your desktops. Password:Verify:Would you like to enter a view-only password (y/n)? nxauth: file /home/olimi/.Xauthority does not exist New 'X' desktop is Olimi-PC-541:1 配置。默认配置启动连接会一片灰白。 vncserver -kill :1 # 结束前面启动的窗口1# 备份原来的配置文件mv ~/.vnc/xstartup ~/.vnc/xstartup.bak# 编辑新的配置文件nano ~/.vnc/xstartup# 输入以下内容 #!/bin/sh # Uncomment the following two lines for normal desktop:unset SESSION_MANAGER# exec /etc/X11/xinit/xinitrc [ -x /etc/vnc/xstartup ] &amp;&amp; exec /etc/vnc/xstartup[ -r $HOME/.Xresources ] &amp;&amp; xrdb $HOME/.Xresourcesxsetroot -solid greyvncconfig -iconic &amp;x-terminal-emulator -geometry 80x24+10+10 -ls -title \"$VNCDESKTOP Desktop\" &amp;startxfce4 &amp; # 授予可执行权限chmod u+x ~/.vnc/xstartup 重新启动 vncserver # 或vncserver -geometry 1920x1080 :1 使用VNC Viewer工具访问。RealVNC下载Viewer，还是付费软件好用，虽然只是server付费。输入：IP:端口号。VNC默认端口为5900，每建立一个连接，VNC 端口号 +1。比如第一个VNC窗口，开放的端口就是5901. 也可以用MobaXterm软件连接。 （经典死老鼠） RDP关于RDP： rdp是windows系统专用的远程连接方式，但是ubuntu等linux系统下可以通过移花接木的方式，也就是xrdp, xrdp本身不具备桌面服务功能，需要和图形化桌面配合，这个提供桌面能力的其实就是xorg，xorg在ubuntu中默认存在，所以通过xrdp连接远程桌面默认会选择xorg，xorg为xrdp提供桌面服务，xrdp本身提供远程连接能力。如果你安装了GNOME, 那xorg就将GNOME桌面远程提供给你，如果你安装了xfce,xorg就将xfce桌面提供给你。可以说xorg是远程桌面服务的中间件，但是xorg和gnome配合不是很好，往往会有问题，但是网上也有解决方案，最佳的配合还是xfce+xorg+xrdp，由于xorg是ubuntu默认存在的图形化能力，所以只要在ubuntu中安装上xrdp，如果你的桌面系统是xfce就能直接使用远程桌面。 安装桌面系统同上。 安装xrdp sudo apt-get install xrdp 安装完成后，Xrdp服务将自动启动。没启动可以自行启动。 sudo systemctl status xrdp # 查看状态# WSL不能执行systemctl，可以使用service命令sudo service xrdp statussudo service xrdp start 默认情况下，Xrdp会读取使用/etc/ssl/private/ssl-cert-snakeoil.key文件，但该文件仅由ssl-cert组的成员读取。 因此你需要运行以下命令以将xrdp用户添加到ssl-cert组： sudo adduser xrdp ssl-cert # 添加用户组sudo systemctl restart xrdp # 重启服务 Xrdp配置文件位于：/etc/xrdp/xrdp.ini。可自行配置。 *可选。远程桌面连接测试时黑屏，闪退：rdp session has been disconnected. 解决： echo \"startxfce4\" &gt; ~/.Xsessionchmod +x ~/.Xsessionsudo service xrdp restart windows可以通过远程桌面客户端连接了，xrdp的端口和rdp一样都是3389，所以可以直接使用windows自带的远程桌面连接工具，连接口弹出窗口，默认选中了xorg，输入ubuntu用户名密码就可以登录. 当然，xrdp不仅可以选择xorg，还能选择vnc-any，也就是选择了这个，你可以连接vnc服务端，也就是 xrdp不仅可以和xorg配合，也能和vnc4server、vino、tightvncserver等vnc服务端配置使用。（这里因为没指定分辨率，而电脑屏幕是4k屏，没放缩的情况下显得很小）X11+SSH转发X Window System 常被简称为X11或X，其功能包括窗口的绘制、移动，以及与鼠标、键盘等输入设备的交互。X Window采用的是X11协议。X11 中的 X 指的就是 X 协议；11 指的是采用 X 协议的第 11 个版本。关于什么是X11 它采用C/S模型：一个X server 和多个应用程序（client）通信。server接收client的请求绘制窗口，并将来自鼠标、键盘等设备的输入传递给client。X server和client可以位于同一计算机上，就类似于平时使用的Windows操作系统；当X server和client不在同一计算机时，使用本地的X server 进行绘制、交互，就变成了远程桌面。举个例子：前者是你在披萨店点了一份披萨，店员在你旁边帮你做好拿给你（这家店相当于同一台计算机）；后者是你在网上叫了一份披萨，店员接单后到你家帮你做了一份披萨（注意：VNC是使用店里厨房，做好给你送过来；X转发是使用你家厨房做披萨）一般Xserver默认不允许直接网络传输，这时候就可以借助ssh通道进行显示。进一步的原理：流程： sshd接受请求建立连接，并将本次ssh会话的DISPLAY指定为hostname:10.0，这里需要注意的是DISPLAY环境变量格式为hostname:displaynumber.screennumber,若hostname为空，则表示Xserver运行在本机，当以tcp连接时，displaynumber的值为实际连接的端口减去6000，即本次的监听端口为6010，而6010的监听者就是sshd程序。 在ssh会话中执行图形程序，ssh客户端本质上只负责输入和显示，程序的执行在sshd上。假设在命令行上运行xclock，这在pstree查看sshd进程可以看到sshd(822369)---bash(822539)---xclock(1014618)。xclock的父进程为bash。该程序与6010进行TCP通信，将X11协议数据发送到6010,sshd再将该数据放入ssh通道与ssh客户端进行通信。 ssh运行在客户端，该端同时运行Xserver.ssh与Xserver建立连接，将ssh通道中的X11协议数据发送到Xserver。实践：最简单的方案就是使用MobaXterm，自带内置的X Server，可以直接接管远程系统的图形化绘制请求。在连接ssh时默认会勾选x11-forwarding，就可以接收x11转发请求。剩下的是X11 Client端的配置。如果登录时显示这个界面，就需要配置连接的远程客户端： 安装X认证包：apt install xorg-x11-xauth 打开ssh转发：编辑/etc/ssh/sshd_config： #AllowAgentForwarding yesAllowTcpForwarding yes #这里打开#GatewayPorts noX11Forwarding yes #这里原本就是打开的#X11DisplayOffset 10#X11UseLocalhost yes#PermitTTY yes service sshd restart 以上是看来的未亲测。用云服务器测试（未安装桌面，小、穷、破），连进去就可以用：以下是个人配置：~ ⌚ 22:28:52sudo dpkg -l | grep x11ii libx11-6:amd64 2:1.6.9-2ubuntu1.2 amd64 X11 client-side libraryii libx11-data 2:1.6.9-2ubuntu1.2 all X11 client-side libraryii libx11-xcb1:amd64 2:1.6.9-2ubuntu1.2 amd64 Xlib/XCB interface libraryii x11-apps 7.7+8 amd64 X applicationsii x11-common 1:7.7+19ubuntu14 all X Window System (X.Org) infrastructureii x11-utils 7.7+5 amd64 X11 utilitiesrc x11-xserver-utils 7.7+8 amd64 X server utilities~ ⌚ 22:29:07$ cat /etc/ssh/sshd_config | grep AllowTcpForwarding#AllowTcpForwarding yes# AllowTcpForwarding no使用命令测试：xclock# 如果找不到则安装sudo apt-get install x11-apps总结：可以发现，这种途径是使用远程系统，需要使用GUI，但系统默认未安装图形界面时，最简便的途径。特别是一般情况下服务端空间宝贵，资源珍贵，使用GUI机会少，用X11转发流量是非常有性价比的行为。References： ubuntu20.10中设置桌面共享的三种方式(任选其一) - 星宇x - 博客园 (cnblogs.com) [如何在Ubuntu 20.04上安装Xrdp服务器 myfreax](https://www.myfreax.com/how-to-install-xrdp-on-ubuntu-20-04/) ubuntu远程桌面连接方式(vnc、xrdp、vino、xorg等概念) – late哥哥笔记 (lategege.com) [Ubuntu 18.04 中安装 Xfce 和 SVN 开启远程桌面访问 Ethan’s Blog - 记录和思考 (ethanblog.com)](https://ethanblog.com/tips/enable-remote-desktop-in-ubuntu-18-04-with-xface-and-svn.html) (11条消息) 【华为云】用VNC远程连接Ubuntu20.04图形界面_Desny的博客-CSDN博客_vnc远程连接ubuntu桌面 通过VNC搭建Ubuntu 18.04和20.04图形界面 (aliyun.com) remote desktop - Xrdp on Ubuntu 20.04 - Ask Ubuntu 忘掉VNC/RDP，拿起手中的MobaXterm轻松上手远程桌面 - 思兼 - 博客园 (cnblogs.com) ssh X11 Forwarding机制浅析 - 掘金 (juejin.cn) 您需要了解的有关 X11 转发的信息 (goteleport.com)后述在玩的过程有碰到什么有意思的再补充吧。" }, { "title": "构建我的工作空间", "url": "/posts/%E6%9E%84%E5%BB%BA%E6%88%91%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/", "categories": "杂记, windows", "tags": "记录", "date": "2022-03-23 23:13:00 +0800", "snippet": "前言配置n遍新电脑的新环境之后：文档记录果然是个好东西；同步这个功能果然也是好东西。本文主要是关于工作环境相关的记录，其他装机软件相关使用总结：Feishu Sheet。总结 终端环境：WT+WSL配置 同步：Git Git：自动集成右键菜单、WT，自行配置代理加速 git config --global http.proxy http://127.0.0.1:7890git config --global https.proxy https://127.0.0.1:7890 编辑器：VSCode、Typora Typora：图片自动上传图床。使用PicCore+图床（暂时仍然使用github）.配置文件 PicGo-Core { \"picBed\": { \"current\": \"github\", \"github\": { \"repo\": \"Olimiya/PicBed\", \"branch\": \"main\", \"token\": \"xxxx\", \"path\": \"\", \"customUrl\": \"\" } }, \"picgoPlugins\": {}} VSCode：安装完成后使用settings sync完成同步。在setting sync设置里在找到之前的token、gist ID，复制过来。把原本的上传，新的下载即可。问题：可能碰到有些插件无法下载，就会下载失败，此时到gist处把有问题的插件删掉，重新下载。 远程服务器ssh免登录1、服务器端开启密钥登录模式/etc/ssh/sshd_config# 开启公钥认证PubkeyAuthentication yes# 存放登录用户公钥的文件位置# 位置就是登录用户名的家目录下的 .ssh# root 就是 /root/.ssh# foo 就是 /home/foo/.sshAuthorizedKeysFile .ssh/authorized_keys2、用户端创建自己的秘钥对ssh-keygen -t rsa -C \"your@email.com\"cd ~/.ssh/# 查看公钥cat id_rsa.pub# 配置登录别名 省去输 ip 麻烦vi config# 以下注释的部分不要复制进去Host examp # 登录的服务器别名 ssh examp 就可以了 HostName 233.233.233.233 #要登录的服务器ip Port 22 User root #登录名 IdentityFile ~/.ssh/id_rsa #你的私钥路径 ServerAliveInterval 30 TCPKeepAlive yes3、将你的公钥添加至服务器端的公钥凭证echo 你的公钥内容 &gt;&gt; ~/.ssh/authorized_keys4、用户端即可免密登录ssh exmap参考：https://segmentfault.com/a/1190000023074072" }, { "title": "Git", "url": "/posts/Git/", "categories": "教程", "tags": "Git", "date": "2022-03-18 10:18:19 +0800", "snippet": "Git ReferenceGit教程：https://www.liaoxuefeng.com/wiki/896043488029600Git 教程Pro：https://gitee.com/progit/（推荐）Git基础常用命令仓库# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]配置# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name \"[name]\"$ git config [--global] user.email \"[email address]\"增加/删除文件# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]代码提交# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ...分支# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]标签# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag]查看信息# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat \"@{0 day ago}\"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog远程同步# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all撤销# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop其他# 生成一个可供发布的压缩包$ git archiveFrom 阮一峰老师的博客文章《常用 Git 命令清单》Git仓库与Git仓库打交道一般有两种方式。第一种是已有云端项目(开源项目或者项目组的项目)，拉取下来进行二次开发；第二种是有一个本地仓库，开发完成后(或者维护中)发布到类似于Github等云端仓库。但是要明确的是，Git是一种分布式版本管理系统，它并不依赖于云端仓库的存在。因此以本地仓库，从零开始进行Git仓库管理。首先，创建一个空的文件夹(或者把一个已有的路径作为仓库)，在此处打开终端，输入git init如果是第一种情况，从云端拉取项目开始，只需要改为git clone url.此时可以看到文件夹中增加了一个.git文件夹，该文件夹即git维护本地仓库的储存路径，里面将包含该仓库所有的信息，包括不同版本、各分支、提交记录等全部信息。如果我们使用git clone命令，观察一下该命令，举例：git clone https://github.com/Olimiya/olimiya.github.io.git可以看到本质上就是从xxx.git从取出相应的数据和信息进行拷贝分发。回到我们空的目录。添加文件README，把它放入版本控制中：git add READMEgit commit -m \"init repository\"对于已有的文件夹，要添加所有已有的文件，使用匹配符，git add .此时我们得到了一个Git版本控制仓库。状态、变更和回退进一步理解Git版本变更的处理，以便于加以控制。使用git status查看一下仓库现在的状态：$ git statusOn branch masternothing to commit, working tree cleanOh clean，让人喜悦的描述。修改一下已有的README(比如在最后加一个hello world)，再查看一次：$ git statusOn branch masterChanges not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git restore &lt;file&gt;...\" to discard changes in working directory) modified: READMEno changes added to commit (use \"git add\" and/or \"git commit -a\")修改文件使该文件变成了modified，并且由于修改后没有提交，所以是Changes not staged for commit。我们使用git add提交一下，再查看状态：On branch masterChanges to be committed: (use \"git restore --staged &lt;file&gt;...\" to unstage) modified: README文件还是modified，但是已经属于Changes to be committed。再次修改README，然后查看状态。$ git statusOn branch masterChanges to be committed: (use \"git restore --staged &lt;file&gt;...\" to unstage) modified: READMEChanges not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git restore &lt;file&gt;...\" to discard changes in working directory) modified: README可以看到文件的两次修改都出现了，第一次被记录为Changes to be committed(由于使用了add)，第二次被记录为Changes not staged for commit(未使用add)。Git中的状态是面向修改的，本质上是提交的操作把修改文件存入.git中。第一次修改完使用add把修改后的README存入staged空间(.git中)，第二次修改没有add前，仅仅在工作目录中存在，文件的状态迁移如图所示：此时使用commit命令，仅仅会将staged空间中的文件写入版本数据库(即第一次修改)，而第二次修改不会写入(仍保留在工作目录)，这是因为上图中commit命令的箭头仅仅是staging area指向git directory。最后再试试新建一个文件，查看状态：$ git statusOn branch masterChanges to be committed: (use \"git restore --staged &lt;file&gt;...\" to unstage) modified: READMEChanges not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git restore &lt;file&gt;...\" to discard changes in working directory) modified: READMEUntracked files: (use \"git add &lt;file&gt;...\" to include in what will be committed) test可以看到Git仓库中有三种状态存在： Changes to be committed Changes not staged for commit Untracked files所有复杂的版本控制就是由这三种状态迁移构成。状态迁移。了解了上述三种状态，我们也可以使用一些操作实现状态的迁移。正向的迁移，即从Untracked files-&gt;Changes not staged for commit=&gt;Changes to be committed，就是上面验证的顺序，即新建文件-&gt;add, commit-&gt;modified-&gt;add的过程。我们看看逆向的迁移，即回退的操作。首先，从Changes to be committed到Changes not staged for commit，即如何将存入staged空间的数据返回工作目录。使用git reset或者git restore --staged：$ git statusOn branch masterChanges to be committed: (use \"git restore --staged &lt;file&gt;...\" to unstage) modified: README$ git reset HEAD READMEUnstaged changes after reset:M README$ git statusOn branch masterChanges not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git restore &lt;file&gt;...\" to discard changes in working directory) modified: READMEno changes added to commit (use \"git add\" and/or \"git commit -a\")git reset HEAD将该文件回退到提交的最近一个版本，M代表的是Modifed。可以看到现在已经回退到Changes not staged for commit。然后是从Changes not staged for commit回退到修改前。使用git restore:$ git restore README/mnt/f/program/test/git on  master ⌚ 22:14:50$ git statusOn branch masternothing to commit, working tree clean重新回到了Clean，Great！(仔细看上面的输出，其实使用git status时已经提示了如何回退啦！)总结一下：回退可以只使用git restore，也是git推荐的用法，其中加上–staged将staged提交回退到工作目录，没加–staged是回退工作目录到修改前。另外还有git reset指令和git checkout -- file。前者可以用来回退add(以及commit，后文讲)，后者也可以用来回退工作目录的修改。至于几个命令有什么区别，先抛个链接在这里：https://stackoverflow.com/questions/58003030/what-is-the-git-restore-command-and-what-is-the-difference-between-git-restor。容我们后文再议。Git远程分支Git branch git checkoutGit进阶Git玩法Git CLI在终端使用ubuntu的时候想，很多大佬玩编程、管理项目的时候会用纯命令行终端的方式，这种情况下要如何维护管理Github(或者Gittee)这种云端仓库呢。比如说，将本地开发的一个项目发布到云端。要实现这个需求，我们一般是怎么做的。 在云端(github)点击创建仓库，填写相关信息，创建一个空的仓库； 在本地仓库，git clone、git remote add-url，关联上云端仓库(如果没有配置登录用户先配置https登录或ssh)。 然后git push提交。这里面最大的问题就是没办法在终端打开云端进行图形化操作，那要实现命令行管理(装B)怎么做呢，答案就是使用GIT CLI(以往HUB的继任者)。在Github克隆代码时，可以看到三个选项：HTTPS、SSH和Github CLI，我们要使用的就是这第三个。GIT CLI的使用：https://cli.github.com/manual/，参考官网教程。首先安装CLI，基于ubuntu:curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpgecho \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main\" | sudo tee /etc/apt/sources.list.d/github-cli.list &gt; /dev/nullsudo apt updatesudo apt install gh然后配置登录信息，gh auth login，依照提示进行，本人的选项：? What account do you want to log into? GitHub.com? What is your preferred protocol for Git operations? SSH? Generate a new SSH key to add to your GitHub account? Yes? Enter a passphrase for your new SSH key (Optional) ****? How would you like to authenticate GitHub CLI? Login with a web browser? How would you like to authenticate GitHub CLI? Paste an authentication tokenTip: you can generate a Personal Access Token here https://github.com/settings/tokensThe minimum required scopes are 'repo', 'read:org', 'admin:public_key'.? Paste your authentication token: ****************************************- gh config set -h github.com git_protocol ssh✓ Configured git protocol✓ Uploaded the SSH key to your GitHub account: /home/olimi/.ssh/id_ed25519.pub✓ Logged in as Olimiya需要到github.com获取一个token，访问路径为https://github.com/settings/tokens(哈哈还是需要访问github的browser，不过只需要一次)。之后就可以使用gh repo create命令行创建云端仓库。再使用git进行管理。别名提高git易用性的技巧，最早不喜欢git的原因就是认为记命令太麻烦，有些命令确实不好记，或者不理解原理，之后用多了就感觉一些常用的功能都需要打很多字母，不够便捷。一些别名（主要是git manual中都推荐的）$ git config --global alias.co checkout$ git config --global alias.br branch$ git config --global alias.ci commit$ git config --global alias.st status$ git config --global alias.unstage 'reset HEAD --'$ git config --global alias.last 'log -1 HEAD'$ git config --global alias.visual '!gitk'" }, { "title": "GithubPage", "url": "/posts/GithubPage/", "categories": "教程", "tags": "网站, 博客", "date": "2022-03-18 09:48:54 +0800", "snippet": "Github Page + Jekyll + Chirpy更新：Jekyll安装官方指南参考：Jekyll on Windows |Jekyll • 简单、博客感知的静态站点 (jekyllrb.com)强烈推荐安装步骤：在 Windows 上安装 Jekyll (github.com)但是之前第一次安装的时候按道理应该很简单，但是不知道为啥踩了很多坑，对于Ruby也不熟悉，也因此重装以后一直没重新Jekyll（由Github自动部署吧）。因此尝试用Chocolatey一键安装。（所有命令如果找不到指令，尝试使用refreshenv，或重启终端） 安装Choco，参见《windows命令行总结-包管理器》 安装Ruby （与官方步骤第一步安装Ruby+Devkit步骤匹配，但是从RubyInstaller-2.4开始，它使用MSYS2作为他们的开发工具包，而不是DevKit。所以这里安装ruby无需安装ruby.devkit） choco install ruby # 安装完成后重启终端，ruby\\bin会自动加入环境变量 ruby --version # test 安装MSYS2以及RIDK安装程序 (与官方步骤第二步匹配，但是在ridk之前先自行安装msys2，否则会提示“MSYS2 installation failure: ‘MSYS2 seems to be unavailable’”，根据这个回答解决)。因为Ruby依赖与MSYS2+Mingw工具链去编译包（但是ruby安装包本身又不包含msys2，差评！） # 自行安装MYSY2，这提供jekyll原生扩展所需的额外工具choco install msys2 # 根据提示选择默认的[1,3]# 这里安装msys2时可能会卡在updating trust database，Ctrl+C取消然后重新运行一次即可 --force重新安装 # 然后运行ridk，包括更多用于本机扩展的工具ridk install 安装Bundler gem install bundler 安装jeykyll gem install jekell # 如果前面安装错误或不运行ridk install，会出现Error installing jekyll: ERROR: Failed to build gem native extension. 无法编译 关于上面安装都是在干什么： chocolatey: windows平台的包管理器。 ruby: 一种开源的面向对象程序设计的服务器端脚本语言。 msys2: 适用于 Windows 的软件分发和构建平台，提供 原生Windows软件的构建环境。用于Ruby程序构建。 ridk: ridk是管理 RubyInstaller-2.4 及更高版本运行时环境的辅助工具。 jekyll：静态博客框架，Github推荐使用（然而资料比hexo真的少很多）。Ruby语言编写。 bundler: 提供ruby依赖管理，跟踪并安装所需特定版本的gem，后面jekyll网站初始化时，bundle从Gemfile中安装所需的依赖。References: 在 Windows 上安装 Jekyll (github.com) (9条消息) Winget、Scoop 和 Chocolatey 安装位置更改方法_Ayka的博客-CSDN博客_winget 安装目录 Windows下的包管理器 Chocolatey 的使用 - 简书 (jianshu.com)当前选用。开箱即用。无需复杂的配置（自定义样式），效果就较好。Fork Nihil大佬的个人定制化版本。有轮子就不要造轮子了好吧。（其实就是懒）开箱即用这点还是非常方便的。以后如果有时间折腾了，再去尝试吧。使用方法：基于 Chirpy 主题定制化的个人博客.Nihil的定制化版本Jekyll使用 首次运行 bundle # 处理依赖 本地启动服务器 bundle exec jekyll serve TODO 迁移或同时备份至腾讯云COS，添加自动CI处理 替换图床，考虑也使用COS注意开启HTTPS：可以在github page的项目中：设置-&gt;Pages-&gt;Enforce HTTPS. 强制github page使用https.Github page + HexoReference:https://alobal.github.io/2020/07/15/Github-Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/ 创建username.github.io仓库 安装hexo环境。 配置hexo项目。 配置主题等。 编写blog。" }, { "title": "开端", "url": "/posts/%E5%BC%80%E7%AB%AF/", "categories": "随笔", "tags": "漫谈", "date": "2022-03-11 14:30:57 +0800", "snippet": "随笔一直都感觉要做一枚努力提升自己的工程师，养成写blog的习惯是必须的。然而写blog的过程确实非常煎熬…往往是愿意废寝忘食地钻研一个问题，但是在得到一个结果后（无论是该死的结果还是令人喜悦的结果），就不愿意花费精力去记录下来，特别是绞尽脑汁回忆解答过程的每个步骤。但恰恰是这样的痛苦，使得写blog变成一种回顾、复盘的过程，是除了解题过程以外，更加重要的提升自己解决问题能力的锻炼。为了提升背后的痛苦是值得忍受的。但是有什么好一点途径缓解这种痛苦呢。我觉得可以有两个方面。第一是把写blog的过程更加简易化、系统化，知道什么时候应该总结写blog，哪些东西是要重点记录，怎么样去组织一个blog内部结构，组织blog之间的结构，形成一套方法论以后，写blog只要简单地填充内容，将思考过的成果如实记录即可。第二方面则是加强完成一次blog过程的成就感。而这主要是提升blog蕴含的价值。这又是与第一方面关联的，以什么样的方式思考，思考出来的成果哪些是最宝贵的，应该用什么方式组织，组织成什么样子，这些方法论指导下，形成一次有意义的blog过程。成就感的推动才会形成一个良性循环。基于上述的思考，形成需求，与原来的解决方案比较，我个人在实践中主要是使用现有的平台去写blog（主要是因为懒，图方便）。主要的问题在于，不是那么的自主可控，组织形式没有合理规划，当然最重要的是渲染太丑了，毕竟还是要挣钱的，想高级就氪金。我认为一个赏心悦目的成果还是比较有比较好的推动力的。当然想是这么想，还是一直在摸鱼…在一个偶然的午后，闲来无事翻看了许多大佬的个人网站，看了一下午，虽然是没学到什么东西（汗，都是在看随笔）。但感觉作为一个理科男，拥有一个有趣的灵魂非常重要。于是在这鼓舞之下，咸鱼决定还是翻个身吧~安利一下：NihilSwichBokjan–写于2022.3.11" }, { "title": "windows痛苦面具-C盘瘦身法", "url": "/posts/windows%E7%97%9B%E8%8B%A6%E9%9D%A2%E5%85%B7-C%E7%9B%98%E7%98%A6%E8%BA%AB%E6%B3%95/", "categories": "杂记, windows", "tags": "记录", "date": "2021-12-24 18:31:00 +0800", "snippet": "简单粗暴 买更大内存的电脑(SSD) 重装系统(五星推荐)原则 所有软件能不安装在C盘就不要安装在C盘，必须安装在C盘的：Windows系统、Visual Studio、Chrome等；安装软件时留个心眼，碰到高级设置、自定义等一点要点进去设置安装路径；操作它到了真的山穷水尽，看着红色的C盘，要开始操作了： 修改默认存储路径1。右键windows自带视频、文档、下载、桌面、音乐等，属性中修改位置(文档、下载、桌面这几个尤其会占地方)； 修改默认存储路径2：修改环境变量TEMP、TMP 修改默认存储路径3：AppData(其中的LocalLow和Roaming可以改，大小有十几二十G，但需要一些魄力)，Roaming大概也可以用右键属性改位置（在属性里面改是最安全的，windows基本上会帮你完成所有操作）。不行的话改注册表：HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders，先在其他盘找一个地方，将APPData原本的目录拷贝过去(能拷多少是多少)，然后改注册表到这个地方。有风险！可能会导致部分软件需要重装。(重装就重装呗，一回生二回熟) 软件辅助1：Folder Size显示文件夹大小；（辅助软件在本人《windows生产力提高》的blog里有链接下载） 软件辅助2：SpsaceSniffer 显示一个磁盘所有大文件排序 一个一个干过去，有疑惑的google一下。 找的发现1：pagefile.sys文件，为虚拟内存页面，虚拟内存就是把一部分硬盘空间拿出来看作是内存使用，默认是使用C盘的空间，大小一般是内存大小的1-2倍左右。修改方法：控制面板-&gt;系统-&gt;调整Windows的外观和性能-&gt;高级-&gt;虚拟内存-&gt;修改，改掉C盘的，放到别的盘就行，大小自己看着给。我的： 修改软件储存位置。QQ、微信个人文件夹。都在设置里面找找就能改。要迁移可以考虑导出聊天记录再导入(这么来一圈本身大小也会降很多) 修改软件储存位置： .gradle 比如AS中设置gradle位置 .vscode 这里面的操作是为了给朋友指导回忆起来的，可能不太全，在实践过程碰到其他操作继续补全。" }, { "title": "windows生产力提升-装机必备", "url": "/posts/windows%E7%94%9F%E4%BA%A7%E5%8A%9B%E6%8F%90%E5%8D%87-%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/", "categories": "杂技, windows", "tags": "windows", "date": "2021-12-24 18:22:00 +0800", "snippet": "前言最近因为要配置新的工作环境，而且在之前重装系统的压力测试之后已经轻车熟路了，于是便想着把这个经验分享出来，也便于下次啥时候系统被玩崩了（bushi）之后简单的复制这套方案。更新：为方便更新，使用一个飞书表格来管理软件的总结，方便查看：‌‍‬⁠⁡⁢⁣⁤﻿APP清单 - 飞书云文档 (feishu.cn)。正文本文根据装机后的急迫性、功用、必要性等方面分为四个方面的列表，分为是《装机必备》《舒适度提高》《能力进阶》。下面所说的所有软件都会在最后提供安装包（官网下载的、云盘形式），除了插件相关的。下面的描述将以第一人称用户体验的方式进行，关于产品的详细介绍，客官们在看了我的安利后感兴趣的可自行到官网查阅。装机必备 Chrome浏览器 这基本上是装机打开电脑第一件要做的事情了。因为过于大众向的推荐，也就不多做介绍了。简单的说，特别是对于搜索、多终端共享等重度需求的用户，我是每个终端（电脑、手机、pad）基本都会首选使用Chrome浏览器。给没用过的小伙伴感受一下： 搜索栏下方是书签、右侧是扩展插件。用户来说可以到设置-&gt;搜索引擎中替换掉喜欢的引擎。 XDM下载器 快速便捷省心。XDM可自动捕获浏览器中的下载请求（如chrome，安装时会提示安装对应的插件，或者XDM设置安装对应浏览器的插件）。XDM的感受是快、非常快、非常非常快。多线程下载技术，尤其是结合代理，下载任何资源都可以享受极致的速度。另外其他的功能，像断点续传、批量下载、重新下载等应有尽有，也可以切换中文语言，还有一个比较实用的功能是自动捕获视频文件，进行下载（就比如在腾讯视频里打开一个视频，可以看之后，会出现一个Download Vedio的选项，即能看就能下载，因为本质上能看了视频已经下载到本地）。类似的比较出名的软件有IDM，但是IDM是付费的，XDM是开源免费的，还更好用了。当然就比Chrome自带的下载器就更不用说了。感受一下： everything本地搜索器 本来这个应该放到《舒适》中的，但由于本软件提高的舒适度过高，乃至没有该软件的电脑都不配叫做生产力工具。Everything是用来查找本地文件（乃至在文件中查找内容）的，它的核心优势就是相对于一坨shit一样的windows资源管理器而言，极快的搜索时间。其他一些玩法：比如想查找一个文件的路径，或者是一个应用程序所在路径，只需要回忆起名字的部分特征，进行查找即可。比如想确定QQ安装的路径，那全局搜素QQ.exe即可；比如查找某个路径下的所有图片，只需要添加筛选器选择图片图片类型；比如查找某个文件夹下所有文件中某个特征字符串（编程时查找使用过某个类的文件），在高级搜索设置内查找相关信息即可。感受一下： Notepad++文本编辑器 对于生产工具而言，文本编辑器是刚需，而一个好用的文本编辑器就十分重要。 文本编辑器核心是在于编辑文本，狭义上是指txt文件，但广义上，任何以字节编码的文本文件都是其影响对象。而Notepad++的最重要意义就是提供一个舒适、美观的方式，让用户去编辑所有的文本文件。对于很多类型的文件，如.xml、.h、.cpp等等，都是文本类型的文件，安装notepad++后都可以直接右键“用Notepad++打开”进行查看编辑。更进一步，遇到一个陌生的文件，想要对其进行了解时，第一步都是可以通过Notepad++打开进行初步了解。另外Notepad++支持各种语法的染色（像cpp xml json java lua等等），比自带的笔记本好看多了；以及编码转换，像ASCII、UTF-8、GBK等等；其他的扩展插件安装，像自带的十六进制查看工具。Notepad++还有一个比较重要的是所见即真实，就是你实际看到的就是实际上储存的。这点看起来很简单，但像是在笔记本里面，在不同编码规则上，比如一个ASCII文本插入unicode字符，就可能导致它显示不出来，就以为不存在。不过有个注意的问题是，Notepad++可能之前似乎因为辱华问题被全面封禁了，可能有点难找到官网下载。感受下：舒适度提升 360zip 解压软件，没什么好帮它吹的。相比于windows自带的解压软件，相较于本体360杀毒，个人感觉确实好用。常规的功能，像zip加压解压、7z加压解压、添加密码、分卷等等都有，UI也还行。但就是解压完UI就卡住有点恶心。感受一下： CCleaner管家 从这个开始下面几个都是系统管理相关的软件。前面提到了360就来说说“电脑管家”这类软件。虽然叫管家，但平时都不会一直挂着，只会在需要时打开，避免浪费内存（看你喜欢吧）。CCleaner提供：健康检测、垃圾清理、驱动更新（需要会员）、注册表清理、软件卸载、开机启动管理等功能。个人主要用的是注册表清理（这个在卸载某些软件卸载不干净的时候有奇效），开机启动管理的功能。来看看： dControl杀杀毒软件 杀杀毒软件是啥意思呢，就是干掉windows defender的软件。反正我嫌它很烦，没试找事一直在叫，自动隔离我的文件、防火墙还老拦截我程序（还试过后台一直扫描导致内存占用极高）。windows defender也老流氓了，常规手段（包括设置、安全政策、改注册）都很难干掉它。dControl就是一个简单的控制软件。不过不建议在一些重要的电脑上（像实验室）关闭防火墙。看下： unlocker清理文件工具 这里的清理指的是清理那些顽固文件，比如你卸载时卸载不干净，有些文件留了下来，由于强迫症死活不让你删掉。比如说提示没有权限、无法访问、已被打开等等，反正windows就是把你当做傻逼，什么都不让你干。我真的不知道被这个逼疯了多少次（我甚至试过最后通过ubuntu系统把windows系统的老顽固干掉）。windows上真很难对抗这些老顽固，除非引入一个更流氓的家伙。unlocker就是一个轻量的解决之道。它的使用方法就是选中一个文件或一整个文件夹（这个好评），然后选择操作，比如delete，然后unlock，就帮你完成了这个操作。来看看： ContextMenuManager右键菜单管理 windows右键菜单又是一个重灾区，软件装的多了，右键菜单就是密密麻麻的一片，谁都往里面加菜单项。ContextMenuManager就是教它们做人的东西，什么QQ发送、网盘、WPS都滚一边去吧。另外它还有比较好用的是自定义右键菜单，比起去写注册表，GUI处理还是方便多了。来看看： ditto剪切板 前面说了一堆系统管理相关的也乏了无聊了，有些确实是半年不用，一用就想夸上天。下面是日用性比较强的。比如说剪切板。这个也是一个刚需了，经常会出现复制了一段话（比如我这里码的2000字），然后忘了没贴，又去复制另外一段东西（比如bilibili.com），哦豁，写的东西都没了（其实也不至于，找找还是有的）。这个就很不方便。ditto就是增强这方面的一个应用。支持不同类型（如文字、图片、文件）等、有中文模式、有主题切换、自定义快捷键、历史信息保存，满足这方面需求毫无问题。来看看我的剪切板（我的快捷键是Ctrl+~）： noMeiryUI 系统文字修改 小标题已经概况了软件功能。嫌系统字体太丑，自己改又麻烦。用noMeiryUI就可以一键完成。看看设置： QTTabBar资源管理器增强 如上图所示，资源管理器下面的tab页就是QTTabBar的作用。还是之前说的windows资源管理器是真不好用。添加QTTabBar，能提供：像web一样的tab页；双击空白处返回、中键添加一个tab等快捷方式；文件预览（如音频、视频预览播放）等。其他的功能还很多，可自行摸索，也有中文补丁包下载。要注意的是安装完要生效，要在资源管理器 查看-&gt; 选项下勾选QTTabBar。来看看： Typora文本编辑器 相较于Notepad++，Typora就是纯粹的码字工具，它更简洁、更美观、对md等语法支持和渲染更出色。最最主要是用来长期码字（写小作文）更舒服，以及书写和查看MD文档（支持将MD转化为pdf、docx等）。我默认的文本编辑器就是Typora（不过最近最最新版收费咯，可以用旧版）。上图： WPS 知云 这两个就放在一起讲吧，有些小伙伴安装系统是没有激活的Office的，与其受它的气不如直接用WPS算了，它的PDF翻译功能还是挺香，对各种类型文档（docx ppt pdf等）都进行了一致的支持。说到翻译，知云就是更进一步的PDF翻译软件，用来看论文会比较香（哎这不是装机必备篇吗，一装机就看论文？救命啊）放下知云的UI：写在本节最后：其实这里有些软件可能对于部分小伙伴来说并不是刚需，可能你觉得很酷，但下载玩了一次之后都不会再用了。本篇的目的是让这些软件真切的帮助到你，提高你使用windows的舒服度，让你爱上玩电脑。因此清楚自己的需求，然后找到这个需求的解决方法，这才是最正确的道路。重要的是解决问题的能力。上面的软件都是我面对个人的实际需求，逐渐累积到的解决方案，希望对大家有帮助。能力进阶怎么说呢，授人以鱼不如授人以渔。重要的是解决问题的能力。其实上面的安利，只要清楚需求，找好寻求答案的途径，都是可以轻松获取的。如果你有我没有的需求，这里的解决方案都不适合你，那我建议你挖掘这个问题，自己去解决这个问题。好了感慨就到这里。下面介绍一下Chrome中的插件（由于插件不好离线流通，所以后面的部分请获取科学能力后再进行查看）： Adblock Plus 广告的敌人 一键清爽你的浏览器 对于没有自动清理掉的广告弹窗（CSDN说的就是你），可以点击插件，选择“拦截元素”，点击具体的弹窗进行清理。 Tampermonkey 暴力猴 必备的脚本管理工具，很多浏览器脚本都要求的前置条件，通过它可以一键安装很多实用的脚本，并进行更新维护。 AC baidu 搜索引擎小动作辟易 提供的功能包括重定向、去广告、自主拦截域名、自定义样式等。看看我的搜索： *Convertio 一个在线格式转换网站对应的插件，作用不是特别大，保存网址也行 *SuperCopy 一个破解禁止右键复制的扩展，同类型的扩展或脚本也挺多的 *沙拉查词 划词翻译软件，仅限于浏览器内部，在电脑全局建议有道 最后资源链接如下：链接：https://pan.baidu.com/s/1Hqj1vUJ0GocMKCbW_Mw7zA 提取码：wdw5没办法找到资源的同学自行获取对应的安装包，有能力的建议直接google查找获取最新版本的最好。感谢看到最后。有什么更好玩的生产力提高工具，不妨分享跟我一起探讨。我们下次再见。（可能是下个月了，咕咕咕）" }, { "title": "Win7 开机进入grub", "url": "/posts/Win7-%E5%BC%80%E6%9C%BA%E8%BF%9B%E5%85%A5grub/", "categories": "杂记, windows", "tags": "记录", "date": "2021-06-20 17:18:00 +0800", "snippet": "问题描述win7电脑，开机进入GNU Grub，输入exit可以退出grub并进入Boot manager选择启动系统。此时可发现多个系统，ubuntu及win7.原因电脑中以前装的ubuntu存在其开机引导文件，但ubuntu系统无法被正确启动，因此进入了grub命令启动页面。只需要将开机启动顺序更改，默认启动win7即可。解决开机进入BIOS（电脑为联想小新Air，可翻到电脑后侧查看型号，搜索进入BIOS方法），开机出现LOGO时长按FN+F2进入。在BIOS界面切换至BOOT，根据提示切换顺序即可。额外：确认不需要的启动efi，在进入系统后，下载软件处理（如DiskGenius），Linux可通过sudo直接删除，搜索一下即可" }, { "title": "word插入漂亮的代码块", "url": "/posts/word%E6%8F%92%E5%85%A5%E6%BC%82%E4%BA%AE%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97/", "categories": "杂记, windows", "tags": "记录", "date": "2021-04-09 22:15:00 +0800", "snippet": "前言在写毕业论文的时候不可避免需要插入代码片段（凑字数啊 ），以往使用的word插入方式感觉不太适合正规严肃的场合，遂再研究了一遍word插入代码方式，最终结果差强人意吧。下面列出几种方式待查阅。同时先放出最心仪的效果（在该场景中）：方案VSCode直接复制粘贴效果如图所示：优点：保留原IDE中的主题、代码着色等效果。缺点：代码块在word文档中没有分隔与突出的效果。适用场景：作为技术文档非常实用，方便技术人员查看。借助网页的渲染格式方式最简单，借助某些帮助网址即可。原本流传较广的是，http://www.planetb.ca/projects/syntaxHighlighter/。不过现在似乎停止维护了，但其他地方也能达到同样的效果，可以参考使用：http://www.codeinword.com/。达到的效果参考如下：优点：显示效果较好，同时满足了代码块的突出强调。（也是我之前一直使用的方式）缺点：这个CSS渲染的效果不太适用于正式的场合，如前面提到的论文中，代码显示效果也不是十分出色（相比于在IDE中的显示效果）。适用场景：较为通用。使用Notepad++等格式转换插件比如使用Notepad++，可以安装NppExport插件，导出代码格式。详细可参考：https://blog.csdn.net/sunshine123moon/article/details/49123511。参考效果：优点：作为文档中的一部分文本时，显示效果出色。缺点：同样缺少作为代码块的突出效果。应用场景：将代码作为文档的一部分文本使用。Office中OpenDocument功能或其他插件直接复制的代码文本可能在office中会存在拼写提示的红色波浪线等，导致显示效果很差，这个问题可以通过office的OpenDocument功能解决。该方法可以结合上述任意一种插入方式，具体使用如下：Office中，插入&gt;对象&gt; Opendocument Text这将打开一个文档窗口，粘贴文本，根据需要设置其格式，然后将其关闭。参考效果：可以看到显示效果基本一样。同样的在背景表格上添加代码为达到最开头实现的那种正式的效果，手动实现途径如下：在Office中添加1*1的表格，双击表格左上角全选按钮进入表格设置，选择底纹设置背景颜色，得到一个背景框，再填入普通代码即可（不需要其着色渲染效果）。如图所示：效果参考：基本实现了要求。优点：显示效果最佳，适用于正式的书面表述中。缺点：代码本身的阅读效果较差，没有着色、高亮的效果。但该做法同样可以跟上面的做法结合，通过改变背景颜色和代码渲染的匹配程度达到更好的显示效果。适用场景：正式场合。奇技淫巧按道理到上面这步已经完成了本人的所有要求，但是，本人最开始看到的效果（即最开头那个），它本身不是office中的表格，它不能被拉伸、选中等，这个特性也非常有趣，可以保证所有地方的一致性以及不可修改性。但这个设置是在其他人的文档中看见的，无法得知其实现原理。（预计也是某个格式转换工具自动完成的）于是，本人的做法是，选中看到的那段代码块，删除所有代码只留下一个空格，选中空格，创建样式。直接就能套用了。至于复用性..单击样式右下角，点击管理样式，导入/导出，将新建的样式复制到右侧Normal.dotm，则以后新建的docx都能使用到该样式。完美！~留一个个人的docx参考吧~https://ttztmgzlpl.feishu.cn/file/boxcnzx0pJyEWMBrTvbaC05w9Hh?from=from_copylink（通过飞书共享，CSDN的资源分享懂得都懂）ps:里面没有任何东西，看样式表！最后自从琢磨前端、CSS之后，越来越觉得CSDN的样式效果丑的不行，还不让自己设置。要在Markdown里面每一段设置一次font也太吃力了（Markdown只是转换成html，在html里面设置font也不是不行，但原则上样式应该是通过CSS设置，CSDN并未像一些文本编辑器如Typora等开放CSS样式修改，应该我的理解没错吧，如果CSDN可以设置，也请大佬告知【在免费的情况下】）。这段话就是手动设置了font的效果。越发想弄一个githubpage了...." }, { "title": "Winsock编程 blocking UDP socket导致死锁问题解决", "url": "/posts/Winsock%E7%BC%96%E7%A8%8B-blocking-UDP-socket%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/", "categories": "杂记, windows", "tags": "记录", "date": "2021-04-04 22:39:00 +0800", "snippet": "项目场景项目需求是通过UDP与服务器通讯。其中客户端有一个功能模块，进入该模块运行时需要监听端口，停止运行或退出时应停止监听。使用了一个监听线程去管理接受数据。服务器是纯C++代码，因此采用了Winsock。客户端基于Qt库，但为保持一致性，也是用Winsock进行通讯。问题描述监听线程继承于QThread，实现了挂起、恢复、终止等服务，代码类似于：void UDPThread::stop(){ if (QThread::isRunning()) {// qDebug() &lt;&lt; \"stop thread : \" &lt;&lt; QThread::currentThreadId(); mutex.lock(); stopFlag = true; condition.wakeAll(); mutex.unlock(); }}void UDPThread::pause(){ if (QThread::isRunning()) {// qDebug() &lt;&lt; \"pause thread : \" &lt;&lt; QThread::currentThreadId(); mutex.lock(); pauseFlag = true; mutex.unlock(); }}void UDPThread::resume(){ if (QThread::isRunning()) {// qDebug() &lt;&lt; \"resume thread : \" &lt;&lt; QThread::currentThreadId(); mutex.lock(); pauseFlag = false; condition.wakeAll(); mutex.unlock(); }}另外，QThread的线程循环类似于:void UDPThread::run(){ qDebug() &lt;&lt; \"enter thread : \" &lt;&lt; QThread::currentThreadId(); while (!stopFlag &amp;&amp; !isInterruptionRequested()) { qDebug() &lt;&lt; \"task work : \" &lt;&lt; QThread::currentThreadId(); startUDPClient(); { if (pauseFlag) { qDebug() &lt;&lt; \"lock thread : \" &lt;&lt; QThread::currentThreadId(); mutex.lock(); condition.wait(&amp;mutex); mutex.unlock(); qDebug() &lt;&lt; \"unlock thread : \" &lt;&lt; QThread::currentThreadId(); } } } pauseFlag = false; stopFlag = false; qDebug() &lt;&lt; \"exit thread : \" &lt;&lt; QThread::currentThreadId();}void UDPThread::startUDPClient(){\t...\t if(!pUDPMsg) pUDPMsg = new WinUDPSendRecv(RevcIPTest, recvPort, SendIPTest, selfPort); int count = 0; ENTITY_STATE_INFO EntityState; Struct_UDPMsgKind head; if(pUDPMsg-&gt;ReceiveMsg((char *)&amp;EntityState, (char *)&amp;head, sizeof(head))) {\t\t...处理数据 }}startUDPClient函数是处理监听和数据过程。然后就出现一个问题，无法退出该线程，即在析构函数调用wait()函数会一直陷入停等状态。查阅发现是前面pause即无法上锁，确定是一直停留在UDP的recvfrom函数。（这里对UDP客户端经过封装，内部调用recvfrom函数，且设为阻塞式）。解决方案 方案1 调用shutdown函数。 网上有说如何退出阻塞式监听，提到使用shutdown函数，类似于shutdown(SOCKET, SD_BOTH)。 \t一度已经生效！！ \t新的问题是，shutdown后的套接字无法重新调用，则必须关闭所有资源在新调用时重新分配。 \t于是在UDP管理类（WinUDPSendRecv）的析构函数中调用closesocket，关闭套接字，在恢复监听时重新生成一次UDP管理类。 \t新问题又出现，在shutdown，可能需要一点时间准备退出（猜测），所以紧接着调用和closesocket并析构所有资源会导致失败，再次陷入recvfrom的忙等中。 \t可以参考下面的一些讨论： \thttps://stackoverflow.com/questions/28957279/how-to-exit-a-blocking-recv-call \thttps://stackoverflow.com/questions/38936093/how-to-exit-a-blocking-recv-in-windows https://social.msdn.microsoft.com/Forums/security/en-US/ce2ff382-b1bf-40a1-8877-84ba82479799/how-to-exit-a-blocking-recv-call?forum=vcgeneral 方案2 ioctlsocket 在需要停止监听时，使用ioctlsocket函数，将套接字重新设为非阻塞式，即可退出忙等。 但该解决方案又碰到一个问题，就是在监听时，如果监听地址是无效的，这个设置就不会生效。 参考： https://www.codeproject.com/Questions/723382/How-to-close-a-blocking-recv-socket-from-another-t 方案3 放弃阻塞 \t看了上面几张帖子，尤其是： \t忽然才意识到没有必要非要使用阻塞式，毕竟监听线程具有大循环，一次超时继续监听下一次即可。因此直接取消阻塞式设置即解决了问题….. 方案4 放弃WinsockQUDPSocket不香吗… 不过据说项目组其他人测试了Qt UDP服务，存在bug，未亲测。WinAPI是真的ugly.." }, { "title": "Qt样式控制：主题切换以及QIcon的源码探析", "url": "/posts/Qt%E6%A0%B7%E5%BC%8F%E6%8E%A7%E5%88%B6-%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2%E4%BB%A5%E5%8F%8AQIcon%E7%9A%84%E6%BA%90%E7%A0%81%E6%8E%A2%E6%9E%90/", "categories": "杂记, Qt", "tags": "记录", "date": "2020-08-25 15:29:00 +0800", "snippet": "需求需求是：类似于Qt Creator或者VS Code一样，提供单机软件的主题切换功能。Simple Thing其中颜色等配置切换可采取Qt Creator的Settings文档格式或者VS Code的json格式定义。如果仅提供最基本的内嵌主题，则直接更换QSS设计即可（设置于顶层界面，需确保所有子界面均为顶层界面的孩子/孩子的孩子）。问题QSS样式中存在一个难题，即QSS无法设置图标颜色。如Qt Creator中浅色主题显示的是黑色图标，而黑色主题显示的是白色图标。针对该问题进行探索。解决思路主题切换时，软件的图标配色不能同样通过QSS设置修改。因此暂时不相应变更，建议图标颜色（标准）下使用通用性较强的配色。（VS Code中即采用该方法，切换主题不修改图标）。【鸵鸟算法万岁！】可供参考的思路为（Qt Creator中做法）：构建自己的Icon类，储存图标文件和颜色（主题）信息，所有地方均使用自定义图标类，通过icon方法转化为QIcon。其中颜色绘制通过读取QImage，动态修改像素值进行构建。参考： 构建出类似于QIcon的较通用性接口较为复杂。建议参考Qt Creator源码（src/plugins/coreplugin/icon）。进一步地，可提供出类似于Qt Creator的主题更换机制，便于用户自定义主题。思路是通过QSetting和预定义主题设置枚举完成。同样参考Qt Creator源码（src/plugins/coreplugin/themeChooser、theme）。源码探究探索中暂废弃的思路：QIcon本质绘制（paint）通过QIconEngine的paint.QIconEngine为纯虚基类，Qt库提供的继承子类为QPixmapIconEngine（位于qt private类定义，非暴露接口，不能继承）和QIconLoaderEngine。Png等文件资源加载默认使用QPixmapIconEngine。QPixmapIconEngine中去绘制QPixmap，而pixmap图标状态（State）模式（Mode）等以及Style设置等动态获取（储存于缓冲池中）。本质上主要是通过QGuiApplicationPrivate::applyQIconStyleHelper获取，除了最基本也是图标主要显示的情景，即Normal的Mode外。参考：而applyQIconStyleHelper被QApplicationPrivate重写后本质上通过QStyle的generatedIconPixmap通过枚举不同状态真正绘制出不同的pixmap（同样是通过QImage动态更新像素点）。/*! \\reimp */QPixmap QCommonStyle::generatedIconPixmap(QIcon::Mode iconMode, const QPixmap &amp;pixmap, const QStyleOption *opt) const{ switch (iconMode) { case QIcon::Disabled: { QImage im = pixmap.toImage().convertToFormat(QImage::Format_ARGB32); // Create a colortable based on the background (black -&gt; bg -&gt; white) QColor bg = opt-&gt;palette.color(QPalette::Disabled, QPalette::Window); int red = bg.red(); int green = bg.green(); int blue = bg.blue(); uchar reds[256], greens[256], blues[256]; for (int i=0; i&lt;128; ++i) { reds[i] = uchar((red * (i&lt;&lt;1)) &gt;&gt; 8); greens[i] = uchar((green * (i&lt;&lt;1)) &gt;&gt; 8); blues[i] = uchar((blue * (i&lt;&lt;1)) &gt;&gt; 8); } for (int i=0; i&lt;128; ++i) { reds[i+128] = uchar(qMin(red + (i &lt;&lt; 1), 255)); greens[i+128] = uchar(qMin(green + (i &lt;&lt; 1), 255)); blues[i+128] = uchar(qMin(blue + (i &lt;&lt; 1), 255)); } int intensity = qt_intensity(red, green, blue); const int factor = 191; // High intensity colors needs dark shifting in the color table, while // low intensity colors needs light shifting. This is to increase the // perceived contrast. if ((red - factor &gt; green &amp;&amp; red - factor &gt; blue) || (green - factor &gt; red &amp;&amp; green - factor &gt; blue) || (blue - factor &gt; red &amp;&amp; blue - factor &gt; green)) intensity = qMin(255, intensity + 91); else if (intensity &lt;= 128) intensity -= 51; for (int y=0; y&lt;im.height(); ++y) { QRgb *scanLine = (QRgb*)im.scanLine(y); for (int x=0; x&lt;im.width(); ++x) { QRgb pixel = *scanLine; // Calculate color table index, taking intensity adjustment // and a magic offset into account. uint ci = uint(qGray(pixel)/3 + (130 - intensity / 3)); *scanLine = qRgba(reds[ci], greens[ci], blues[ci], qAlpha(pixel)); ++scanLine; } } return QPixmap::fromImage(im); } case QIcon::Selected: { QImage img = pixmap.toImage().convertToFormat(QImage::Format_ARGB32_Premultiplied); QColor color = opt-&gt;palette.color(QPalette::Normal, QPalette::Highlight); color.setAlphaF(qreal(0.3)); QPainter painter(&amp;img); painter.setCompositionMode(QPainter::CompositionMode_SourceAtop); painter.fillRect(0, 0, img.width(), img.height(), color); painter.end(); return QPixmap::fromImage(img); } case QIcon::Active: return pixmap; default: break; } return pixmap;}根据上述描述，图标绘制修改通过QIconEngine，但其中真正修改还是在QStyle中。因此需要同时重写QIconEngine和QStyle。重写QIconEngine是为了处理一般情况，即Normal的处理；重写QStyle是为了处理不同模式中图标的绘制。当然这是QPixmapIconEngine的做法（本身也不属于Qt 标准库），也可以把图标绘制放入QIconEngine中（不如说应该这么做）。重写之后要怎么做呢（重写参考QPixmapIconEngine和QCommonStyle）。QIconEngine通过编写导出插件，至于qt目录中Plugins/iconengines目录中，注册相应文件资源尾缀的处理引擎，或者直接QIcon(new MyIconEngine。QStyle则还要重写QStyleFactory用于提供创建QStyle接口，然后同样作为插件放入Plugins/styles中（这里有一个很重要的问题是，不明确指定style的情况下，qt会自动选择style，如windows10平台为windowsvistastyle，这样的话指定自定义style就需要处理各种平台的选择了。同样的，windowsvistastyle不是标准qt库，不能继承和重写）。详情参考qt中提供的插件机制。" }, { "title": "3D游戏引擎入门课程7——内存管理与插件机制", "url": "/posts/3D%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%85%A5%E9%97%A8%E8%AF%BE%E7%A8%8B7-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/", "categories": "教程, 3D游戏引擎", "tags": "游戏引擎", "date": "2020-06-29 12:50:00 +0800", "snippet": "写在前面本专栏内容均为学堂在线慕课《3D游戏引擎架构设计基础》中的内容。个人将其转化成文字和图片的版本（个人更加喜欢文字版本的教程，阅读速度更快很多），方便查阅。原课程链接：3D游戏引擎架构设计基础。内存管理与插件机制内存管理和扩展插件概述内存管理内存管理是引擎底层和核心内容之一，引擎中几乎所有顶层基类都是内存分配的类，所以内存管理决定了系统的运行效率。引擎的内存管理从对象可分为CPU主内存和GPU的显卡内存；从操作类型可分为数据结构的分配和释放，以及数据访问。第三方标准库，如STL、BOOST等，已经提供了各种数据结构的内存分配和管理，使用这些标准库可以简化游戏引擎的底层设计。如STL，将数据类型抽象为容器，将数据组织和算法分离，其中容器主要包括三种：序列容器（vector, deque, list等）、关联容器（map, multimap, set, multiset等）、容器适配器（stack, queue, priority_queue等）。第三方库还提供了内存分配的保护机制，避免内存指针的使用错误，防止内存泄漏，如shared_ptr，weak_ptr，scoped_ptr等。动态内存分配是指使用的时候分配内存，不用的时候释放内存，但其开销很大，游戏引擎经常使用定制分配器做动态内存分配，包括：扩展性引擎的可扩展性要求：插件技术： 插件是可独立开发的程序块，由系统的插件接口管理。 基于插件的体系架构是一种灵活的组件式结构。 插件接口股安咯程序可以动态地调用多个插件，而不必或很少修改程序。 优点在于：引擎核心功能简洁清晰；插件之间耦合度低，便于维护和修改；引擎根据需要选择插件，提高运行效率。 插件接口的设计原则包括：通用性、兼容性、稳定性、可测试性、可维护性。 插件管理机制：智能化识别插件，动态判断插件进行安装或卸载；自动化调用；管理插件间的通信；对插件进行初始化和配置管理。 内存管理和扩展插件实现实例OGRE内存管理和扩展插件OGRE中内存管理的分类：OGRE中的智能指针SharedPtr:OGRE中的GPU Buffer管理：OGRE中插件的实现机制：OGRE的插件类Plugin:OGRE中的plugin.cfg" }, { "title": "3D游戏引擎入门课程6——事件处理与脚本语言", "url": "/posts/3D%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%85%A5%E9%97%A8%E8%AF%BE%E7%A8%8B6-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E4%B8%8E%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/", "categories": "教程, 3D游戏引擎", "tags": "游戏引擎", "date": "2020-06-29 12:50:00 +0800", "snippet": "写在前面本专栏内容均为学堂在线慕课《3D游戏引擎架构设计基础》中的内容。个人将其转化成文字和图片的版本（个人更加喜欢文字版本的教程，阅读速度更快很多），方便查阅。原课程链接：3D游戏引擎架构设计基础。事件处理与脚本语言事件处理与脚本语言概述事件处理事件驱动的游戏交互控制：游戏引擎的事件处理方式影响着整个引擎架构的设计与风格。事件处理是引擎架构的底层设计，是引擎的两大主线内容之一（另一个是场景管理和渲染渲染）。其中游戏引擎循环架构风格包括三种： 回调驱动框架的交互控制方式 其中事件处理是通过回调函数执行的，示例如下： 事件处理机制框架示意： 基于事件更新的交互控制方式 视窗消息泵的交互控制方式上述的事件处理机制中，回调驱动方式主要适用于窗口或外部输入的设备事件，采用的是事件处理机制；基于事件更新的方式主要适用于场景渲染的帧时间更新，可以用回调函数实现更新；视窗消息泵的方式主要适用于在已有的GUI框架中集成交互控制。事件处理中的设计思想，观察者模式：应用观察者模式使得事件与事件处理方法在定义时耦合度较小。脚本语言指为了缩短传统的编写-编译-链接-运行过程而创建的计算机编程语言，也是一种编译语言的扩展语言。其语法比较简单，与应用程序密切相关，可以直接调用应用程序函数，一般不具备通用性。其特性包括：直译性、轻量、支持快速迭代、方便易用。常见的脚本语言包括：Python、Lua、JavaScript等。游戏引擎与脚本的关系示意如下：其组合方式包括：脚本语言的接口定义：事件处理实现实例OGRE事件处理OGRE的事件：所以OGRE的事件处理中核心是处理渲染事件，主要类FrameListener如下：进一步地讨论frameRenderingQueued帧渲染排队事件：OGRE的渲染事件监听相关类：OGRE中外部事件在OGREBites模块中实现；OGREBites模块的ApplicationContext类是FrameListener类的子类，提供有方便的事件监听接口；OGREBites模块的InputListener结构定义了键盘、鼠标、触摸等输入事件的回调函数；OGREBites模块的其他外部类包括：窗口事件类、GUI的控件事件类等。ApplicationContext类与事件处理相关的部分：Panda3D事件处理Panda3D事件处理机制中任务的概念：Panda3D事件的核心类类图：任务类之间的关系：AsyncTask类接口：事件处理机制和相关类：事件处理器的详细解析：事件对象定义和处理的一个示例：GUI类：" }, { "title": "3D游戏引擎入门课程5——角色动画", "url": "/posts/3D%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%85%A5%E9%97%A8%E8%AF%BE%E7%A8%8B5-%E8%A7%92%E8%89%B2%E5%8A%A8%E7%94%BB/", "categories": "教程, 3D游戏引擎", "tags": "游戏引擎", "date": "2020-06-29 12:50:00 +0800", "snippet": "写在前面本专栏内容均为学堂在线慕课《3D游戏引擎架构设计基础》中的内容。个人将其转化成文字和图片的版本（个人更加喜欢文字版本的教程，阅读速度更快很多），方便查阅。原课程链接：3D游戏引擎架构设计基础。角色动画角色动画概述和表示方法 角色是指推动游戏剧情的载体，包括玩家、非玩家、怪兽和敌人等。角色的表示 赛璐璐动画 刚性层阶式动画 每顶点动画 变形目标动画 骨骼蒙皮动画其中骨骼蒙皮动画是使用得最多的表现技术。游戏中的角色动画建模过程： 蒙皮：建立角色的网格模型 骨骼：建立关节和关节层次树，并将关节与对应的网格顶点绑定 皮肤或衣服：定义网格的材质和纹理贴图 角色动画：描述角色的动作，定义角色骨骼的位置移动 表现示例：骨骼蒙皮动画中重要的概念 自由度和关节类型： 关节的空间变换 网格顶点和关节绑定 运动合成和运动控制 运动合成中的重要概念： 动画片段：是指组成游戏角色的动作的局部姿势，如举手、跳跃、一个走路或跑步的步幅等。 关键帧或关键姿势：是指在动画片段指定的时间点上设定的重要姿势，通过关键帧，可以用线性插值或曲线插值算法自动生成中间的姿势，即中间帧。关键帧可以被看成角色姿势的一个静态图。而动画片段是由若干个关键帧和中间帧组成，且所有帧按照设点的时间点显示。动画片段是角色动画的一个局部姿势，是动态的。 示例： 动画片段的合成是指对应关节位置的计算，角色动作自动合成的方法包括： 线性混合 骨骼分部混合 加法混合。角色动画实现实例OGEE角色动画OGRE角色动画渲染流程：OGRE节点类型与骨骼树结构：关节节点与场景图的关系：OGRE角色动画主要类：下面是OGRE角色动画的几种核心类描述：角色动画的骨骼蒙皮动画的示例：OGRE角色动画总结：Panda3D角色动画Panda3D中角色动画的概念:Panda3D中角色表示的类图如下：角色局部运动类：最后是Panda3D动画类：" }, { "title": "3D游戏引擎入门课程4——场景渲染", "url": "/posts/3D%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%85%A5%E9%97%A8%E8%AF%BE%E7%A8%8B4-%E5%9C%BA%E6%99%AF%E6%B8%B2%E6%9F%93/", "categories": "教程, 3D游戏引擎", "tags": "游戏引擎", "date": "2020-06-29 12:50:00 +0800", "snippet": "写在前面本专栏内容均为学堂在线慕课《3D游戏引擎架构设计基础》中的内容。个人将其转化成文字和图片的版本（个人更加喜欢文字版本的教程，阅读速度更快很多），方便查阅。原课程链接：3D游戏引擎架构设计基础。场景渲染渲染概述与剔除方法渲染的定义：将三维矢量描述的场景转换到二维像素描述的场景的处理过程，是整个游戏引擎功能模块是最重要的内容。相关的概念描述包括：为了提升渲染的效率，可以采用不可见物体剔除，包括： 根据摄像机位置，剔除视见体外的物体（可以通过包围体） 判断视见体中物体的遮挡关系，剔除被遮挡的物体（可以通过包围体） 剔除可见物体的背面 真实感渲染中，包括以下内容的计算和融合得到渲染结果。 光照，指根据场景定义的灯光、材质等属性，用图形库支持光照模型渲染场景。其中光照模型包括：局部光照模型，全局光照模型，光照绘制算法等，光照计算通过光源、三角形面片的顶点法向量和材质等属性计算。光源是不可渲染的，只是作为计算真实感场景的属性，本身不被渲染。 纹理：纹理映射是增加场景网格模型真实感表现效果的方法。纹理是由像素表示的，是以贴图映射的形式与网格模型关联起来，其纹理涂是一种资源文件。如.jpg,.tga,.bmp,.png,.tif等，可以与光照、阴影、特效等产生混合效果。纹理映射方法包括：多重纹理、凹凸纹理、光泽纹理、投影纹理、环境纹理等。 阴影，可以产生场景深度和立体效果。阴影区域就是，在视点位置看是可见区域，但在光源位置看是不可见区域，示意图如下： 其中软阴影的概念为：如果是面光源照射物体，则影子区域呈现为软阴影，即阴影由全阴影区和半阴影区组成，示意图如下： 视觉特效，可以产生动态光影效果，一般用布告板或粒子系统等实现。渲染实现的重要部分：GPU和着色器编程：其对于游戏引擎的要求： LOD LOD（Level of Detail）是指渲染时，使用较少的细节表示较小的、较远的或不太重要的场景物体。实现方法包括：离散LOD（静态LOD），连续LOD（动态LOD）和视点依赖LOD等。场景渲染实例OGRE场景渲染 OGRE主渲染循环：OGRE主渲染时序图：OGRE SceneManager类的渲染操作： SceneManager::_renderScene(Camera *camera, Viewport *vp, bool includeOverlays) SceneManager::_renderVisibleObjects(void) SceneManager::renderVisibleObjectsDefaultSequence(void) SceneManager::_renderQueueGroupObjects(RenderQueueGroup *pGroup, QueuedRenderableCollection::OrganisationMode om) SceneManager::renderBasicQueueGroupObjects(RenderQueueGroup *pGroup, QueuedRenderableCollection::OrganisationMode om)加粗样式 SceneManager::renderObjects(…); QueuedRenderableCollection::acceptVisitorGrouped(…) QueuedRenderableCollection::acceptVisitor(…); SceneManager::SceneMgrRenderableVistor::VISIT(Pass *p, Renderable *r); SceneManager::renderSignleObject(…) SceneManager::_issueRenderOp(…) GLRenderSystem::_render(RenderOperation &amp;op)//使用OpenGL渲染 以上Step总结：Panda3D场景渲染 Panda3D渲染过程：Panda3D渲染核心类和类关系：下面是几种Panda3D场景渲染的核心类详细描述：Panda3D渲染管理： 应用程序启动渲染； 对于视见体，剔除不可见物体，建立渲染队列和状态，并排序； 执行渲染，获得一帧渲染结果 应用程序更新场景，循环开始下一帧渲染，转2. Panda3D主渲染流程：其中的几个子过程如下： 异步任务驱动渲染的流程： 多线程渲染： 剔除操作 渲染操作" }, { "title": "3D游戏引擎入门课程3——资源管理", "url": "/posts/3D%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%85%A5%E9%97%A8%E8%AF%BE%E7%A8%8B3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/", "categories": "教程, 3D游戏引擎", "tags": "游戏引擎", "date": "2020-06-29 12:50:00 +0800", "snippet": "写在前面本专栏内容均为学堂在线慕课《3D游戏引擎架构设计基础》中的内容。个人将其转化成文字和图片的版本（个人更加喜欢文字版本的教程，阅读速度更快很多），方便查阅。原课程链接：3D游戏引擎架构设计基础。资源管理资源管理概述游戏资源的组织和管理。其目的是有效地组织和管理各类游戏资源，即在合适的时候快速准确地提供给游戏程序使用。其中，资源组织是指根据各类资源的特性和使用方式，设计资源数据的内存结构；资源管理是指抽象并定义统一的资源处理方式，如：资源加载和卸载、资源调度等。资源管理过程图如下：游戏资源管理： 文件管理：包括文件加载与卸载，文件解析，文件格式转换，文件资源打包，文件资源传输等过程。 内存管理：包括内存分配，访问保证，内存释放等功能： 状态管理：一般地，一个游戏资源不会再内存中重复存储，以节省内存，根据资源状态，决定加载和使用等操作；通过状态转换图，管理资源加载或卸载的操作。资源状态有：未定义、已定义、未加载、已加载、正使用等。资源状态转换图示例： 调度算法：原则是尽可能少地移动资源数据，当不得不移动时，根据一定的条件决定移动策略。常用的调度算法包括：对资源优先级排列、LRU算法、根据当前操作决定最可能使用的资源等。 多线程处理 资源管理实例OGRE资源管理其中主要类的类图如下：上述三个核心类的关系图如下：OGRE资源生命周期的时序图如下：Panda3D资源管理 Panda3D资源管理主要类模块：Panda3D异步资源加载器类图：Panda3D异步加载时序图：" }, { "title": "3D游戏引擎入门课程2——场景管理", "url": "/posts/3D%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%85%A5%E9%97%A8%E8%AF%BE%E7%A8%8B2-%E5%9C%BA%E6%99%AF%E7%AE%A1%E7%90%86/", "categories": "教程, 3D游戏引擎", "tags": "游戏引擎", "date": "2020-06-29 12:50:00 +0800", "snippet": "写在前面本专栏内容均为学堂在线慕课《3D游戏引擎架构设计基础》中的内容。个人将其转化成文字和图片的版本（个人更加喜欢文字版本的教程，阅读速度更快很多），方便查阅。原课程链接：3D游戏引擎架构设计基础。场景管理场景管理概述与BVH 为了提高场景管理的效率，场景对象的逻辑组织架构通常是树型的结构。举例：游戏场景组织的架构包括： 场景图，多用于管理动态场景。 八叉树，多用于管理大型室外场景。 二叉空间分割，即BSP树，多用于管理室内场景。 BVH（Bouding Volume Hierarchies）包围体层次结构，用于快速判断场景对象之间的几何位置关系，其通过BVH方法为每个对象计算包围体。BVH就是节点有包围体信息的树状结构。举例：其中包围体类型又包括：包围球，轴平行包围体，有向包围体，k-离散有向多面体。其计算复杂度是逐渐上升的。其中计算方法如下图所示：场景组织结构：场景树，八叉树和BSP树场景树 用层次结构表示场景中的对象 上层对象的操作影响其所有子树的对象 有向无环图 场景图的抽象描述如下：八叉树 将空间分成八等份，如果被分的部分填满了场景内容，或被分的部分没有场景内容，则不再分割；否则，继续分割，直到满足终止条件。八叉树的组织：其缺点是叶子节点的指针空间都为空，浪费很多空间。其中一种改进的做法是：线性八叉树节省了储存空间，场景运算也非常简便。八叉树分割算法：其中可以通过计算分割的立方体与几何包围体的包含关系来确定几何体与场景的几何关系是F（Full）还是E（Empty）。递归的分割算法实现非常简洁快速。八叉树的构建思想决定了场景的有序性，当镜头位置和方向确定后，场景的遍历顺序就可以确定。八叉树的遍历方式可以从后向前遍历，或是从前向后遍历。其中前者被也称为画家算法，这种方式不需要计算遮挡关系，但是需要渲染每一个面，效率很低。后者是最近的面先渲染，再通过遮挡关系或深度缓存信息，决定像素的最终渲染结果。这种方法深度缓存需要在像空间执行，但是减少了很多渲染计算，效率较高。八叉树的优点如下：BSP树 是用空间超平面，递归地将空间分割为凸多面体集，用二叉树表示被分割的空间。 其中凸多面体的定义为：由若干平面多边形所圈成的封闭的立体叫做多面体，这些平面多边形称为多面体的面，这些多边形的边和顶点分别称为多面体的棱和顶点。如果多面体在它们每一面所决定的平面的同一侧，则称此多面体为凸多面体，或欧拉多面体。凸多面体的任何截面都是凸多边形，与凹多面体相反。其分割思想为：其构建算法为：其中几个几何问题算法包括： 如何判断凸多面体： 如何判断两个面片的几何位置关系： 判断面片与顶点的几何位置关系：解决了上述几个几何问题，继续讨论BSP树的构建。另外一个问题是，如何确定分割的超平面，选择步骤为： 剔除凸包面 计算NF、NB、NS 选择分割空间的超平面最后是BSP树完整的构建算法：BSP树的遍历算法（画家算法）：可以通过从前往后遍历，通过深度缓存进行计算进行优化。BSP树的应用：最后对几种算法进行对比：场景管理实例OGRE场景管理 OGRE中场景类型分为：静态、动态、扩展的： 静态型：非常庞大、向四周不规则蔓延的、不可移动的、由三角形网格组成的物，包括地形、天空盒等，有以下的表示：SkyPlane, Skybox, SkyDome(SceneNode *)；World geometry, 通常是一个确定的SceneManager；Static geometry，通常SceneManager的树结构是确定的，如室内场景。 动态性：可在场景中移动的、离散的、相对较小的物体，主要包括实体（Entity）、粒子、摄像机等，用SceneNode类和MovableObject类表示。 扩展型：主要包括BSPSceneNode, OctreeNode, PCZSceneNode等。 OGRE场景管理部分类图：其中的主要类描述：SceneManger（场景管理单例）主要功能图：OGRE创建场景对象示例：OSG场景管理OSG的场景管理主要模块：OSG场景关系类图：下面是OSG场景管理中几个核心类：OSG场景管理设计分析：Panda3D场景管理 Panda3D场景管理概念： 场景图有一个公共基类（PandaNode抽象类），派生所有场景节点类； 场景图的任何一个节点可以由一个以上的父节点，即场景图是有向无环结构； 派生的几何节点类是场景图的叶子节点，是可渲染的节点； NodePath类时管理场景图的接口类，操作场景节点，获取从根到访问节点的路径等。 Panda3D场景管理部分类图：Panda3D场景管理基类定义：下面是Panda3D中场景管理几个核心类的描述：Panda3D场景管理模块关系图：Panda3D场景管理示例： 几种游戏引擎场景管理比较：" }, { "title": "3D游戏引擎入门课程1——概述", "url": "/posts/3D%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%85%A5%E9%97%A8%E8%AF%BE%E7%A8%8B1-%E6%A6%82%E8%BF%B0/", "categories": "教程, 3D游戏引擎", "tags": "游戏引擎", "date": "2020-06-29 12:50:00 +0800", "snippet": "写在前面本专栏内容均为学堂在线慕课《3D游戏引擎架构设计基础》中的内容。个人将其转化成文字和图片的版本（个人更加喜欢文字版本的教程，阅读速度更快很多），方便查阅。原课程链接：3D游戏引擎架构设计基础。本文由整份的word文档转化而来，可选择阅读整份文档（转化成的web专栏阅读起来感觉会更加舒服）。链接放到最后。导图课程思维导图：大图查看链接：高清版因此，本专栏将根据导图的索引，分为7个章节。索引 概述 [场景管理]((https://olimiya.github.io/posts/3D游戏引擎入门课程2——场景管理) [资源管理]((https://olimiya.github.io/posts/3D游戏引擎入门课程3——资源管理) [场景渲染]((https://olimiya.github.io/posts/3D游戏引擎入门课程4——场景渲染) [角色动画]((https://olimiya.github.io/posts/3D游戏引擎入门课程5——角色动画) [事件处理与脚本语言]((https://olimiya.github.io/posts/3D游戏引擎入门课程6——事件处理与脚本语言) [内存管理]((https://olimiya.github.io/posts/3D游戏引擎入门课程7——内存管理与插件机制)概述游戏引擎概述 定义：如果把游戏开发中的核心基础功能独立抽象出来，供游戏开发者调用，这样的组件被称为游戏引擎。使用游戏引擎开发游戏，能够提高游戏的开发效率和质量。在早期的游戏开发中，设计者们逐步地、不断地抽取出游戏设计的公共组件，将这些功能抽象化、模块化，形成了游戏引擎。随着游戏开发的不断成熟，游戏引擎的功能已经越来越强大。其中开源的游戏引擎包括，Unreal Engine 4，OGRE，Panda3D等，流行的商业游戏引擎包括，Unity等。下文将主要通过OGRE和Panda3D进行举例。游戏引擎框架概述 游戏引擎的需求分析，即游戏引擎应该包含的功能。 其中环境需求包括： 目标硬件 设备驱动 操作系统 第三方软件包和中间件 支撑引擎的平台独立层 功能需求包括： 引擎的核心基础模块 引擎资源管理 引擎场景管理和图形渲染 角色动画 声音 物理和碰撞检测 人工智能 图形用户界面GUI 脚本处理等 游戏引擎的设计原则包括：功能完善（多），运行效率高（快），性能稳定（好），同时具备良好的扩展性。 游戏引擎的架构设计，应将以下内容按照一定的方式组合在一起： 基础平台的支撑组件 第三方的基础库：数据运算、图形处理、数据结构等 引擎功能（如上面功能需求所述） 游戏引擎层次化组织架构：功能游戏功能游戏的分类：游戏引擎中的设计模式 创建型模式： 单例模式：系统中只存在一个实例，一般是全程存在的。 抽象工厂模式：为创建若干个有关联的工厂类提供接口，是抽象类，无需制定具体类。 工厂模式：提供若干个有关联对象的接口，是具体类，可以实例化。 结构性模式： 适配器模式：将一个类的接口转换成所希望的另外一个类的接口。让原本因接口不兼容而不能一起使用的那些类可以一起工作。通过该模式可以为第三方的基础库定义统一的接口。 行为性模式： 迭代器模式：顺序访问一个聚合对象中的各个元素，但不需要了解该对象的内部表示。 观察者模式：由多个观察者对象同时监听某个主体，当主体对象发生变化时，通知所有的观察者，并做成响应。 访问者模式：将一些操作封装，并施加于某种数据结构元素上，当修改封装的操作时，不会影响被施加的数据结构，即可以将不稳定的方法和稳定的数据结构隔离。如，将渲染算法封装为访问者模式的类，可将方法和数据隔离，如果某个数据结构的某个算法发生改变，则只需要修改算法，而不影响数据结构的元素。 文档链接[金山文档] 3D游戏引擎基础.doc" }, { "title": "Kintinuous算法+Ubuntu19.10编译过程记录", "url": "/posts/Kintinuous%E7%AE%97%E6%B3%95+Ubuntu19.10%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/", "categories": "杂记", "tags": "编译", "date": "2020-06-29 12:04:00 +0800", "snippet": "写在前面这篇博文告诉你什么：Kintinuous编译过程可能遇到的一些问题和解决办法。属于汇总贴。同时证明了较新系统中运行编译Kintinuous的可行性。不告诉你什么：算法解析。工作过程下面将记录一遍整个工作的流程（具体命令将省去，详情见参考链接）。 查询获取Kintinuou项目，并从项目中获知所需的依赖环境。（https://github.com/mp3guy/Kintinuous） 进入ubuntu实体机（具体版本为19.10），本项目环境配置必须在Linux的实体机上进行。因为项目需要使用cuda，而虚拟机中大概率获取不到真正的显卡硬件。（https://blog.csdn.net/cbd_2012/article/details/84581621） 安装必备的依赖。（下几步库安装可参考https://blog.csdn.net/lzRush/article/details/89089233） 安装NVDIA及CUDA。本人的系统自带NVDIA的430版本驱动，适合10.1版本的CUDA，故直接安装CUDA。该步骤耗时较长，但直接根据官方提示进行即可。 安装OpenNI2及PCL1.7。 安装OpenCV2.4。这步应该是问题最大的。可能的出现的问题和解决方案如下： cmake库找不到：https://blog.csdn.net/qq_17783559/article/details/105078293；非常常见的openCV版本与CUDA版本不兼容，即找不到CUDA_nppi_LIBRARY (ADVANCED)，使用下面的1235步：https://blog.csdn.net/u014613745/article/details/78310916；Make过程也可能出现许多报错，如缺少stdlib.h库，通过cmake增加-DENABLE_PRECOMPILED_HEADERS=OFF解决；avcodec_free_frame notdeclared等报错属于ffmpeg库不兼容，可自行编译ffmpeg库，操作见Kintinuous项目Readme，或可在cmake中取消with_ffmpeg，据说并不会影响其他功能；其他一些make错误不一一指出直接google就有解决方案，一个比较汇总的链接如下：https://blog.csdn.net/u012796629/article/details/89857190； Makeinstall成功后，其他库引用openCV可能出现找不到shared library（本人在编译Kintiuous时遇到），解决方案：https://stackoverflow.com/questions/12335848/opencv-program-compile-error-libopencv-core-so-2-4-cannot-open-shared-object-f；以及找不到一些与cuda相关的opencv_dev_cudart库等，解决方案是自行拷贝CUDA目录中相关库，或者在提示错误的项目cmake增加-DCUDA_USE_STATIC_CUDA_RUNTIME=OFF，参考：https://blog.csdn.net/Hansry/article/details/90675208；另外可能注意的问题是gcc与g++版本，由于cuda10安装仅支持gcc8，故整个过程都使用的是gcc8及g++8，注意两者版本应一致。Linux中多版本软件可自行切换，具体参考google。 安装DLib（v1.0），DBoW2（v1.0）,DLooperDetector（v1.0），ISAM（v1.7），Pangolin（最新）。链接均可参考Kintinuous中给出的。 编译Kintinuous。该步也可能出现较多问题。如使用高版本导致abs的报错，自行更改源码即可；Unsupported gpuarchitecture ‘compute_20’及no kernel image is available for executionon the device ，两个问题都通过cmake中增加-DCUDA_TOOLKIT_ROOT_DIR=/usr/local/cuda-10.1 -D CUDA_ARCH_BIN=6.1 -DCUDA_ARCH_PTX=6.1解决了（本人CUDA10.1+GPU GTX1050Pascal架构），如无法解决则查询GPU所适配的架构和算力。参考Kintinuous项目中的Issues:https://github.com/mp3guy/Kintinuous/issues/40。 Kintinuous正常运行样例。 下载TUM测试集。通过png_to_klg项目把RGB_D数据转换为Kintinuous读取的klg文件，项目地址：https://github.com/HTLife/png_to_klg（该项目配置在完成前面的配置后可轻松完成）。转换数据集进行测试。测试过程Kintinuous出现报错，Assertion `deformationGraph’ failed.已放弃(核心已转储)，解决方法同样参考Issues：https://github.com/mp3guy/Kintinuous/issues/63；或是https://blog.csdn.net/solo_ws/article/details/72887562。上述核心已转储问题以已其他方式出现，针对特定的数据集无法正常运行，未找到原因。至此成功完成了Kintinuous算法的编译运行测试等工作。最后最后放几张运行结果：" }, { "title": "C++标准库与OSG库智能指针对比记录", "url": "/posts/C++%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8EOSG%E5%BA%93%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%AF%B9%E6%AF%94%E8%AE%B0%E5%BD%95/", "categories": "杂记, C++", "tags": "记录", "date": "2020-03-19 00:05:00 +0800", "snippet": "转载mark一下总结帖：https://www.cnblogs.com/wuyepeng/p/9741241.htmlhttps://www.cnblogs.com/greatverve/p/smart-ptr.html个人记录 std::weak_ptr&lt;&gt;和osg::observer_ptr&lt;&gt;感觉C++的weak_ptr没有osg中osg::observer_ptr&lt;&gt;来得明白易懂。observer_ptr&lt;&gt;顾名思义就是观察者指针，没有对象的所有权，其作用是在对象销毁时自动消除该指针。当然，这是因为这个库本身建立的体系决定的。两者有共同之处也有区别吧。weak_ptr:osg::observer_ptr&lt;&gt;" }, { "title": "openCV with CUDA 编译：乱码错误+no such file", "url": "/posts/openCV-with-CUDA%E7%BC%96%E8%AF%91-%E4%B9%B1%E7%A0%81%E9%94%99%E8%AF%AF+no-such-file/", "categories": "杂记", "tags": "记录", "date": "2020-03-18 17:41:00 +0800", "snippet": "前言关于OpenCV编译教程非常多，个人参考的链接如下：https://blog.csdn.net/stjuliet/article/details/84640094基本上按照步骤一步一步下来没有什么问题，这个流程经过很多小伙伴的验证也是可行的。但是在cmake完成，使用VS进行build的时候，本人就出现了一大堆错误，直接导致编译失败。查找输出，发现第一个错误是在nvcc编译.cu文件的过程中，输出的信息全部都是”锟斤拷”之类的乱码，其中大部分是warning，只有一个是error，是乱码+No such file。本人编译的版本openCV4.2.0 + CUDA9.2(10.2也试过) + VS2017 + CMAKE3.15。探讨由于VS输出报错中，主要error是no such file，个人查找了相应位置，发现项目中C/C++附加包含库目录是有相应头文件的，而且修改源码，输出#include时也有相应提示，所以此时我认为库目录路径应该是有的，那问题就是出在乱码上。此时查阅了一些其他人遇到的问题，如https://blog.csdn.net/Angle_Cal/article/details/79376233，提出的问题是因为MSVC编译器编译出现乱码，并就此更改了各个编译器地址但都没用。在与该博客作者探讨了一番后无果。据说这是CUDA以往的bug，在新版本中已经修复了，所以也没见身边小伙伴遇到过。一番折腾（特别是阅读cmake文档。）感觉越走越偏。换个思路，既然是编译.cu文件出现的问题，那我自己编译该.cu文件。于是通过命令行nvcc手动编译.cu文件，此时完全没有乱码！但还是报了no such file的错误。然后通过指定参数–include-path添加库路径，这时编译通过了！就此我单独拿了一个子项目出来就行编译，然后在VC++目录中添加包含目录，这时同样成功了！解决经过上面的发现，那显然是nvcc编译.cu的时候真的找不到库的头文件（虽然在C/C++附加包含目录中有）。解决方案就是在cmake时，手动指定nvcc的参数，设置–include-path这时本人的设置：--include-path F:/library/vs/OPenCV_CUDA/build/3rdparty/ippicv/ippicv_win/icv/include,F:/library/vs/OPenCV_CUDA/build/3rdparty/ippicv/ippicv_win/iw/include,F:/library/vs/OPenCV_CUDA/opencv-4.2.0/modules/core/src,F:/library/vs/OPenCV_CUDA/opencv-4.2.0/modules/core/include,F:/library/vs/OPenCV_CUDA/build/modules/core,F:/library/vs/OPenCV_CUDA/opencv_contrib-4.2.0/modules/cudev/include,F:/library/vs/OPenCV_CUDA/opencv-4.2.0/3rdparty/zlib,F:/library/vs/OPenCV_CUDA/build/3rdparty/zlib,F:/library/vs/OPenCV_CUDA/opencv-4.2.0/3rdparty/include/opencl/1.2,F:/library/vs/OPenCV_CUDA/opencv-4.2.0/3rdparty/ittnotify/include,F:/library/vs/OPenCV_CUDA/build,F:/tools/CUDA10.2/CUDA_Development/include至于上面的路径怎么找，本人是找了其中一个项目，复制了C/C++附加包含库路径（可能有遗漏）。编译后错误大量减少，碰到少量错误再一个一个添加其路径即可。最后最终是编译成功了。反思了一下，一个是被VS一堆乱码给误导了。就这个问题，明明我活动代码页一直设置是Unicode，而且我手动输出调试信息或者在命令行cmd编译.cu都是正常的。可能跟cmake中一些设置有关。另外一个是cmake之后库目录默认放在每个项目C/C++的附加包含目录而不是VC++包含目录，原因是前者是对当前项目生效的，而后者是对全局生效的。但本人就是因为这一点而编译不通过.cu文件（毕竟人家都说了是C/C++的设置）。但所有其他人都从未遇到该问题，本人甚是不解。以上便是本次“解谜过程”，由于拖了很久才进行记录总结，很多截图已无法获取，对阅读者致以歉意。" }, { "title": "Free Heap block xx modified at xxafter it was freed 堆内存出现野指针错误", "url": "/posts/%E5%A0%86%E5%86%85%E5%AD%98%E5%87%BA%E7%8E%B0%E9%87%8E%E6%8C%87%E9%92%88%E9%94%99%E8%AF%AF/", "categories": "杂记, C++", "tags": "记录", "date": "2020-03-01 20:30:00 +0800", "snippet": "首先看下问题提示HEAP[SimEng.exe]: HEAP: Free Heap block 000002CA51FC08A0 modified at 000002CA51FC0950 after it was freedOk，碰到这种xxxx地址的报错提示就慌得一批。解答经过一种暴力式解谜，找到以下的原因（解谜过程不建议也不见得能复用，基本上就是看堆栈，“偶然”看到有熟悉的名字就去找到用到的地方，然后一点一点注释，然后找不同，极其低效QAQ）：原因：关闭窗口，开始执行析构：1.从mainwindow开始析构： 2.析构它的孩子（m_osgwidget）： 3.析构其他孩子（MAP_OSG_LayerControlWidget）： 真相只有一个：3中析构调用了2中已经被析构的指针！据说Qt对象树的析构并不能指定顺序 所以在Qt对象的析构中不能调用兄弟指针。解决方案：注释掉3.中析构这调用就行了，要用可以写个closeEvent方法保险一些。后言这里只是提供了关于内存出错的一种经验，毕竟C++内存管理是非常复杂而且技术多样的地方。这里由于是在程序退出，执行析构的时候出现的错误（堆内存释放），所以出现野指针的问题跟一般情况有些出入，对比普通的野指针异常更难发现问题了（在看堆栈的时候全是qt内存管理机制，看不懂..）。总之出现问题还是多翻看自己的代码（也可能是别人的，笑）反思：暴力破解问题的思路实属不可取，效率低效之余全靠运气QAQ据说可以通过重写new和delete的操作，记录分配的内存，然后写一个查询函数，即可通过vs的监视窗口顺利找到出问题的内存块对应的对象。当然可能可以通过一些工具方便做到这点吧…继续加油.." }, { "title": "Qt查看源码总结帖", "url": "/posts/Qt%E6%9F%A5%E7%9C%8B%E6%BA%90%E7%A0%81%E6%80%BB%E7%BB%93%E5%B8%96/", "categories": "杂记, Qt", "tags": "记录", "date": "2020-02-28 16:55:00 +0800", "snippet": "前言在学习osg的时候养成一个习惯，就是一边学习一边打开自制的帮助文档，看着源码，一边去编码。然后结合很久之前就想学习Qt源码，拿到一份Qt类图之类的，对Qt学习实践进行一些总结。所以趁此机会，鼓捣了一下Qt中如何使用源码的做法。此处实名感谢Qt开源社区群的の大佬，尽心尽力地给出许多有用的建议，一步一步进行指导。实践做法一基于从osg处学来的操作，我先是利用doxygen扫描Qt的源码（这里默认已经添加了Qt Src组件），生成一份.chm的帮助手册。这个做法的优点是，可以即时查看源码，查看类图，比如想用到QImage类，那直接索引QImage，查看API，查看实现，查看继承关系，相类似的类等等，是一种将实践工作与学习结合在一起的方法。…But，跟osg源码组织形式不一样，Qt源码的组织结构非常复杂，各种调用封装很绕，不是直接一个文件夹下.h.cpp扫描就行了，而且还有许多类似于example之类的文件，导致扫描正则很难写，扫描速度很慢。（编译了一天一夜了，还在编译，大小在3G+），以后完成了效果不错再补充一份DoxygenFile.做法一被我放弃了…编译了两天还没成功，我电脑可能先炸..不过好像可以续编译，以后有时间继续吧…做法一的替代：找到一个挺不错的网站，就是Qt的源码树，在实时查找翻看源码时挺实用的（https://code.woboq.org/qt5/）做法二一个折中的做法是调试进入源码。关键是：Qt Src文件，以及pdb文件。获取PDB： 从https://download.qt.io/下载Qt对应版本的pdb文件，有部分可直接下载，如： 如果没有打包的pdb，可换个路径查找具体的pdb，如我的Qt5.12.1+msvc2017_64配置的：https://download.qt.io/online/qtsdkrepository/windows_x86/desktop/qt5_5121/qt.qt5.5121.debug_info.win64_msvc2017_64/。可下载所有pdb，或者选择需要的模块。 除此之外，还有一种更为简便的方法获取pdb文件，就是通过Qt的MaintenaceTool工具。参考链接：https://blog.simbot.net/index.php/2019/07/28/qt-debug-symbols/ MaintenaceTool工具经常出现版本低于3.0.6之类的报错，我的做法是，删除储存库中所有非默认储存库，在出现报错后，点击ok返回，重新点击更新组件，这时可以更新MaintenaceTool，更新以后就能使用了。（更新后还会继续报错版本过低，用上述方法，ok返回，不管它即可，这时bug啊）处理PDB 下载好PDB之后，解压，放到同一个文件夹（即所有.pdb放在一起），我解压后pdb主要分在bin和lib两个文件夹，这也没关系，添加两个路径即可。 在Qt creator中工具-&gt;调试器-&gt;CDB Paths，添加上述路径（这里默认已经配置好CDB，若没有CDB，建议重装或参考相应的教程）： 同理，在vs中也同样，工具-&gt;选项-&gt;调试-&gt;符号添加路径即可：添加Qt源码 Qt Creator，同样工具-&gt;调试器-&gt;概要-&gt;添加Qt源码（很多教程只教这一步，但是没有pdb是不行的） - 这时断点，F11即能进入源码： VS：此时，成功调试进入源码部分。总结回味了一下，其实实时查看源码这个操作的确不应该被直接支持（指的是在代码里通过ctrl+左键查看）。因为我们的工程不可能包含Qt整个源码工程，自然链接不到。（这里据说可以通过在qt creator同时打开源码的qt.pro项目，即可实时查看源码，但本人一直用不了该项目，各种报错。因为没有刚需，暂时不研究了）。而一方面直接通过qt assist查看Qt提供的API，一方面要深入研究时通过源码树网站跳转至相应的源码介绍页面（包括直接的源码，以及详细介绍，相关链接，类图等等）。另一方面调试时也能深入qt的逻辑层次，更好判断自己的应用是否正确。这似乎已经达到预期的目标了。" }, { "title": "osgEarth添加图例", "url": "/posts/osgEarth%E6%B7%BB%E5%8A%A0%E5%9B%BE%E4%BE%8B/", "categories": "杂记, OSG", "tags": "记录", "date": "2020-02-11 20:54:00 +0800", "snippet": "在osgEarth地图上添加图例多的不说了直接上代码：首先是添加控件（使用的是自带控件Control）//由于该功能属于项目的一部分，所以部分使用到的外部变量可能看不懂//根据API更替为自己的变量即可osg::ref_ptr&lt;osg::Group&gt; MAP_GR_CreateScale::createScale(){ using namespace osgEarth::Util::Controls; osg::ref_ptr&lt;VBox&gt; center = new VBox(Control::ALIGN_RIGHT, Control::ALIGN_BOTTOM, 0, 0); // Add a text label: { osg::ref_ptr&lt;HBox&gt; labelBox = new HBox(); labelBox-&gt;setHorizFill( true ); labelBox-&gt;setChildVertAlign( Control::ALIGN_LEFT ); labelBox-&gt;setMargin(0); osg::ref_ptr&lt;LabelControl&gt; label1 = new LabelControl( \"0\" ); label1-&gt;setFont( osgEarth::Registry::instance()-&gt;getDefaultFont() ); label1-&gt;setFontSize( 10.0f ); label1-&gt;setHorizAlign( Control::ALIGN_LEFT ); label1-&gt;setMargin( 0 ); labelBox-&gt;addControl( label1.get() ); osg::ref_ptr&lt;LabelControl&gt; label2 = new LabelControl( \"1000km\" ); label2-&gt;setFont( osgEarth::Registry::instance()-&gt;getDefaultFont() ); label2-&gt;setFontSize( 10.0f ); label2-&gt;setHorizAlign( Control::ALIGN_CENTER ); label2-&gt;setMargin( 0 ); labelBox-&gt;addControl( label2.get() ); osg::ref_ptr&lt;LabelControl&gt; label3 = new LabelControl( \"2000km\" ); label3-&gt;setFont( osgEarth::Registry::instance()-&gt;getDefaultFont() ); label3-&gt;setFontSize( 10.0f ); label3-&gt;setHorizAlign( Control::ALIGN_RIGHT ); label3-&gt;setMargin( 0 ); labelBox-&gt;addControl( label3.get() ); center-&gt;addControl(labelBox.get()); m_label2 = label2; m_label3 = label3; } //Add Bar { osg::ref_ptr&lt;HBox&gt; barBox = new HBox(); barBox-&gt;setChildSpacing(0); barBox-&gt;setChildVertAlign( Control::ALIGN_LEFT ); barBox-&gt;setMargin(0); osg::ref_ptr&lt;HBox&gt; bar1 = new HBox(); bar1-&gt;setSize(m_defaultPixel, 10); bar1-&gt;setBackColor( osgEarth::Symbology::Color::Blue ); bar1-&gt;setMargin(0); osg::ref_ptr&lt;HBox&gt; bar2 = new HBox(); bar2-&gt;setSize(m_defaultPixel, 10); bar2-&gt;setBackColor( Color::White ); bar2-&gt;setMargin(0); barBox-&gt;addChild(bar1); barBox-&gt;addChild(bar2); center-&gt;addControl(barBox.get()); m_bar1 = bar1; m_bar2 = bar2; } auto l_mapData = MAP_GLOBALDATA_APPData::getInstance()-&gt;g_mapData; if(!l_mapData-&gt;valid) return nullptr; osg::ref_ptr&lt;ControlCanvas&gt; cs = ControlCanvas::getOrCreate( l_mapData-&gt;pView ); cs-&gt;addControl(center.get()); m_pScale = center; m_pCanvas = cs; return m_pCanvas;}然后是实时更新（注册一个handler，在Scroll事件时调用即可）void MAP_GR_CreateScale::calScale(){ if(!m_pCanvas) return; //默认的像素值（80）对应的距离 int defaultPixelDistance = MAP_OSG_OSGTool::getDistanceDifferByPixel(m_defaultPixel);// qDebug() &lt;&lt; defaultPixelDistance; //计算默认距离对应有效数字为一位的距离（显示数值） int bit = QString::number(defaultPixelDistance).size(); double value = std::round(defaultPixelDistance / pow(10, bit - 1)); double nearDistance = value * pow(10, bit - 1); double width = MAP_OSG_OSGTool::getPixelByDistance(nearDistance); m_bar1-&gt;setWidth(width); m_bar1-&gt;dirty(); m_bar2-&gt;setWidth(width); m_bar2-&gt;dirty(); QString label1; QString label2; // km double showValue = nearDistance / 1000; if(showValue &lt; 1.0) { label1 = QString::number(showValue * 1000) + \"m\"; label2 = QString::number(2 * showValue * 1000) + \"m\"; } else { label1 = QString::number(showValue) + \"km\"; label2 = QString::number(2 * showValue) + \"km\"; } m_label2-&gt;setText(label1.toStdString()); m_label3-&gt;setText(label2.toStdString());}附工具函数osg::Vec2 MAP_OSG_OSGTool::getLatLongDegree(double x, double y){ osg::Vec2 pos(0.0, 0.0); auto l_mapData = MAP_GLOBALDATA_APPData::getInstance()-&gt;g_mapData; if(!l_mapData-&gt;valid) return osg::Vec2(); osgViewer::View* l_pViewer = l_mapData-&gt;pView; auto l_mapNode = osgEarth::MapNode::findMapNode(l_pViewer-&gt;getSceneData()); osg::NodePath l_nodePath; l_nodePath.push_back(l_mapNode-&gt;getTerrainEngine()); // 获取当前点 osgUtil::LineSegmentIntersector::Intersections intersection; l_pViewer-&gt;computeIntersections(x, y, l_nodePath, intersection); osgUtil::LineSegmentIntersector::Intersections::iterator iter = intersection.begin(); if (iter != intersection.end()) { osgEarth::GeoPoint point; point.fromWorld(l_mapNode-&gt;getMap()-&gt;getSRS(), iter-&gt;getWorldIntersectPoint()); pos.x() = point.x(); pos.y() = point.y(); return pos; } return osg::Vec2();}osg::Vec3 MAP_OSG_OSGTool::windowsXYToLatLongDegree(double x, double y){ auto l_mapData = MAP_GLOBALDATA_APPData::getInstance()-&gt;g_mapData; if(!l_mapData-&gt;valid) return osg::Vec3(); auto camera = l_mapData-&gt;pView-&gt;getCamera(); osg::Matrix VPW = camera-&gt;getViewMatrix() * camera-&gt;getProjectionMatrix() * camera-&gt;getViewport()-&gt;computeWindowMatrix(); osg::Matrix inverseVPW; inverseVPW.invert(VPW); osg::Vec3d world = osg::Vec3d(x,y,0) * inverseVPW; osgEarth::GeoPoint point; point.fromWorld(l_mapData-&gt;pMapSRS, world); return osg::Vec3(point.x(), point.y(), point.z());}osg::Vec2 MAP_OSG_OSGTool::LatLongDegreeToWindowsXY(double latDegree, double longDegree){ auto l_mapData = MAP_GLOBALDATA_APPData::getInstance()-&gt;g_mapData; if(!l_mapData-&gt;valid) return osg::Vec2(); auto camera = l_mapData-&gt;pView-&gt;getCamera(); osg::Matrix VPW = camera-&gt;getViewMatrix() * camera-&gt;getProjectionMatrix() * camera-&gt;getViewport()-&gt;computeWindowMatrix(); osg::Vec3d world; bool b = l_mapData-&gt;pMapSRS-&gt;transformToWorld(osg::Vec3d(longDegree, latDegree, 0.0), world); if(!b) return osg::Vec2(); auto windows = world * VPW; return osg::Vec2(windows.x(), windows.y());}osg::Vec2d MAP_OSG_OSGTool::getLatLongDifferByPixel(double hPixel, double vPixel){ osg::Vec2d differ(0.0, 0.0); auto widget = MAP_GLOBALDATA_APPData::getInstance()-&gt;g_osgWidget; if(!widget) return differ; double centerX = widget-&gt;width() / 2; double centerY = widget-&gt;height() / 2; osg::Vec2 centerLatLong = getLatLongDegree(centerX, centerY); double differX = centerX + hPixel; double differY = centerY + vPixel; osg::Vec2 differLatLong = getLatLongDegree(differX, differY); differ.x() = abs(differLatLong.x() - centerLatLong.x()); differ.y() = abs(differLatLong.y() - centerLatLong.y()); return differ;}double MAP_OSG_OSGTool::getDistanceDifferByPixel(double hPixel){ auto widget = MAP_GLOBALDATA_APPData::getInstance()-&gt;g_osgWidget; if(!widget) return -1; double centerX = widget-&gt;width() / 2; double centerY = widget-&gt;height() / 2; osg::Vec2 centerLatLong = getLatLongDegree(centerX, centerY); double differX = centerX + hPixel; osg::Vec2 differLatLong = getLatLongDegree(differX, centerY); return osgEarth::GeoMath::distance(osg::Vec3(centerLatLong.x(), centerLatLong.y(), 0), osg::Vec3(differLatLong.x(), differLatLong.y(), 0), MAP_GLOBALDATA_APPData::getInstance()-&gt;g_mapData-&gt;pMapSRS);}double MAP_OSG_OSGTool::getPixelByDistance(double distance){ auto widget = MAP_GLOBALDATA_APPData::getInstance()-&gt;g_osgWidget; if(!widget) return -1; double centerX = widget-&gt;width() / 2; double centerY = widget-&gt;height() / 2; osg::Vec2 centerLatLong = getLatLongDegree(centerX, centerY); double nextLat = 0; double nextLong = 0; osgEarth::GeoMath::destination(osg::DegreesToRadians(centerLatLong.y()), osg::DegreesToRadians(centerLatLong.x()), 90, distance, nextLat, nextLong); nextLat = osg::RadiansToDegrees(nextLat); nextLong = osg::RadiansToDegrees(nextLong); auto nextWindowXY = MAP_OSG_OSGTool::LatLongDegreeToWindowsXY(nextLat, nextLong); return distanceByPoints(osg::Vec2(centerX, centerY), nextWindowXY);}double MAP_OSG_OSGTool::distanceByPoints(osg::Vec3 first, osg::Vec3 second){ return std::sqrt(pow(first.x() - second.x(), 2) + pow(first.y() - second.y(), 2) + pow(first.z() - second.z(), 2));}double MAP_OSG_OSGTool::distanceByPoints(osg::Vec2 first, osg::Vec2 second){ return std::sqrt(pow(first.x() - second.x(), 2) + pow(first.y() - second.y(), 2));}另，有一个小问题，就是如果是在handler中Scroll事件触发即刻调用更新，会导致地图还没来得及放缩，这个时候更新用的地图是原来的地图，肯定导致一定的误差。我的思路是：void MAP_GR_CreateScale::updateScale(){ QTimer::singleShot(100, this, &amp;MAP_GR_CreateScale::calScale);}对，没错，就是万能的Timer~代码较为离散，毕竟是抠出来的一部分啦~" }, { "title": "osg添加插件--爬坑之路 无法定位程序输入点于动态库上", "url": "/posts/osg%E6%B7%BB%E5%8A%A0%E6%8F%92%E4%BB%B6-%E7%88%AC%E5%9D%91%E4%B9%8B%E8%B7%AF-%E6%97%A0%E6%B3%95%E5%AE%9A%E4%BD%8D%E7%A8%8B%E5%BA%8F%E8%BE%93%E5%85%A5%E7%82%B9%E4%BA%8E%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8A/", "categories": "杂记, OSG", "tags": "记录", "date": "2020-02-10 18:04:00 +0800", "snippet": "前文osg官方推荐的Windows平台软件源（真希望做好起来）:vcpkg正文osg添加新插件（我们根据官方文档编译好的osg库中已经有了部分插件dll，见{OSG_DIR}\\bin\\osgPlugins-3.6.0，但要使用其他的插件，如svg插件则需要自己编译添加）。 寻找要添加的插件源码，osg官网提供有许多，参考url：https://github.com/openscenegraph/OpenSceneGraph/tree/master/src/osgPlugins（也可以用svn签出部分）。 源码中有Cmake工程，不过据说不能自动识别osg的部分东西。所以还是自己建立一个工程，vs、qt都可（由于依赖库的问题，后面会提到，所以这里建议使用vs工程），把源码拷过去。 查看源码中有无依赖库，比如svg源码中就使用到librsvg的库（而这个库本身又依赖许多其他库！），这里推荐使用上文中提到的vcpkg。如下载librsvg库，只要一个命令vcpkg install librsvg:x64-windows即可，期间会把22个依赖包全部下好，同时一个命令vcpkg integrate install即可在VS中使用库，非常方便。Vcpkg教程参考：https://blog.csdn.net/cjmqas/article/details/79282847 依赖库下好，如在VS项目，此时把项目属性中输出改为dll，名字要设置为osgdb_xx.dll（如osgdb_svg,dll），编译源码即可得到dll插件。（由于vcpkg主要提供dll，所以这样得到的插件应该也会有一大堆dll，一起拷到环境配置中的osgPlugins文件夹即可）。无论在全局环境变量path还是{OSG_DIR}\\bin\\osgPlugins-3.6.0中，osg会根据名称自动去寻找插件。 在程序或者使用osgViewer去读写文件即可，如：osg::Image image = osgDB::readImageFile(“xxx.svg”);可能遇到的坑： 关于怎么在VS中开发osg项目，可参考本人的github项目https://github.com/kkkiitty/learnOSG中的OSG_VS，有一个VS上的osg框架（其实就是添加好include和lib，用到哪些库链接上就行）。 一般插件都分为debug版和release版，debug版带d尾缀，注意编译插件源码时选择的配置。这里有一点未解决的问题是我们项目似乎暂时只支出debug版本，所以插件暂时只编译debug版本即可。所以链接库时记得链接的库都要带d尾缀（当然带d不带d一起链接也行）。如果编译的是debug版，链接库只链接了release版是不能用的！同时osgViewer这个命令本身就是release版本的，所以不能跑debug版本插件（换成osgViewerd即可）。编译release版可能会出现：如果没碰到什么问题，但最简单的插件就是找（写）源码，编译且输出dll名字要符合格式，丢到path中，剩下的osg都会搞定了。如果碰到问题，那就祝欧吧~" }, { "title": "Qt 统一样式-结合良好设计原则", "url": "/posts/Qt-%E7%BB%9F%E4%B8%80%E6%A0%B7%E5%BC%8F-%E7%BB%93%E5%90%88%E8%89%AF%E5%A5%BD%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/", "categories": "杂记, Qt", "tags": "记录", "date": "2020-02-10 17:46:00 +0800", "snippet": "写在前面结合上一篇提到的界面风格统一的问题，ui界面美观是产品一个至关重要的优势，而界面美观最基础的一点就是风格统一。但在团队中界面设计往往由许多人共同完成，如果统一大家的样式就成了一个问题。下文方法是项目过程自己摸索的方法，不知道成熟团队或者公司内部有没有更好的准则，仅供参考。解决思路以QDialog一个常用的组件为例。 首先，我们建立一个模板控件：并搭建需要的框架：这里我要达到的效果有： 然后看看较为重要的函数useFrame，正是这个函数开启了框架：\tvoid MAP_DLG_TemplateDialog::useFrame(QWidget *widget, int w, int h){ m_templateUI-&gt;setupUi(this); m_templateUI-&gt;m_extendableLayout-&gt;addWidget(widget); if(w != 0 &amp;&amp; h != 0) this-&gt;resize(w, h); QFile qss(\":/QSS/qss/TotalQSS.qss\"); if (qss.open(QIODevice::ReadOnly)) { QString styleSheet = qss.readAll(); setStyleSheet(styleSheet); } m_templateUI-&gt;m_templateTitleBar-&gt;setButtonStyle(TitleBarButtonFlag::NOFLAGICONANDMAXMINBUTTON); m_templateUI-&gt;m_templateTitleBar-&gt;setTitleIcon(QIcon(\":/Icon/icon/world.png\")); m_templateUI-&gt;m_templateTitleBar-&gt;setTitleBarTitle(u8\"标题栏\", Qt::AlignCenter); m_templateUI-&gt;m_templateTitleBar-&gt;setDragable(true); this-&gt;setWindowFlag(Qt::FramelessWindowHint); connect(m_templateUI-&gt;m_applicationButton, &amp;QPushButton::clicked, this, &amp;MAP_DLG_TemplateDialog::applicationHandle); connect(m_templateUI-&gt;m_cancelButton, &amp;QPushButton::clicked, this, &amp;MAP_DLG_TemplateDialog::cancelHandle);}代码非常简单，更多是特定需要的接口，核心只要调用了setupUi，通过启用ui文件搭建的框架，并以QSS渲染其中指定的部件。 用法参考注释如下：/** * @brief The MAP_DLG_TemplateDialog class * 对话框模板类，可作为大部分对话框的父类； * 提供了一套对话框的自定义框架，暂时包括： * 1.自定义标题栏，具体API参见自定义标题栏头文件 * 2.底部button box，提供“确定”，“取消”功能。 * 3.边框样式以及相关QSS设置，详情参见ui文件的样式。 * 用法： * 生成Qt的ui/h文件，选择QDialog父类；在生成的.h文件中更改继承父类为MAP_DLG_TemplateDialog； * 在构造函数（或者合适的位置），调用MAP_DLG_TemplateDialog的useFrame方法即可。 * 参考MAP_DLG_CreateProject界面 * 最后在工厂类中提供生成界面的函数，使用工厂类创建界面。 * @see map_dlg\\map_dlg_createproject.h */举例：其实这个思路本身，其实就是利用了多个ui的组合，把界面共有的部分提取出来搭建一个ui框架文件，特定逻辑则继承这个父类，再写自己的ui文件。（可能是Qt默认生成一个.h一个.cpp一个.ui就默认了这种组织形式，但文件组织是自由的，只要弄清楚ui文件的本质是什么，也就是setupUi这个函数的作用）额外上面额外提到一点是工厂类，这是team里面一个成员提出的设计原则，所有界面的创建由专门的工厂类去负责（其实也就是把new dialog()这个放入一个函数里面！）。这点到底有没有意义，我暂时持保留意见。最后由于项目本身由整个团队完成，并不是开源项目，所以代码部分不敢大张旗鼓的粘贴进来分享，有什么疑问之处可向本人联系进行交流。邮箱：861921648@qq.com." }, { "title": "Qt-统一样式爬的坑（参考统一样式的思路）", "url": "/posts/Qt-%E7%BB%9F%E4%B8%80%E6%A0%B7%E5%BC%8F%E7%88%AC%E7%9A%84%E5%9D%91-%E5%8F%82%E8%80%83%E7%BB%9F%E4%B8%80%E6%A0%B7%E5%BC%8F%E7%9A%84%E6%80%9D%E8%B7%AF/", "categories": "杂记, Qt", "tags": "记录", "date": "2020-02-10 17:23:00 +0800", "snippet": "写在前面嗯…在后后面项目经验中，这是一份已经落后的文档了。因为如果在一开始就持有保持统一的思想跟良好的设计原则，这些问题并不会出现。但也是一份经验教训吧。样式标准（参考）统一标准：字体全部设为微软雅黑，11号按钮统一大小93,28.对话框统一：标题栏需添加自定义标题栏（自定义标题栏的接口会给出，可能如MAP_GUI_MainWindowTitleBar或MAP_GUI_CustomTitleBar）（参加下图例子）设置icon和标题，同时要设置无边框；对话框要设置边界，样式同下图，把界面里定义的Frame添加到QSS（TotalQSS.qss）中,同时界面都添加该QSS文件着色。 用一个例子详细说明：如我们需要一个对话框Dialog（绝大多数我们只需要QMainWindow和Qdialog），那这个ui文件的组织形式应如下同： 第一级是新建的QDialog: SE_NZ_Dialog第二级是一个Qframe用来装要使用的控件，目的是统一最后的界面样式。第三级包括一个Layout布局和一个TitleBarWidget（这个即上面说的自定义标题栏，先拖一个Widget到顶部，然后提升为自定义标题栏的类即可）。所有界面设计放到Layout布局中即可。成品图： 其中各部分的布局的样式如下：SE_NZ_Dialog的布局： QFrame的布局： 自己的Layout的布局：此外大部分界面通用的底部按钮：由于标题栏都是统一的自定义风格，所以还要针对这个进行一些设置（自定义标题栏这里就不展示了）说完ui文件的操作流程，说说cpp里面的通用操作： ui-&gt;m_titleBar三个函数见自定义标题栏的接口，主要是调整样式跟设置icon，text。然后还要额外设置FrameLess（这样才能使用自定义标题栏）。由于设置了FrameLess的界面是不能伸缩大小的了，所以如有这个需求可在ui里面勾选一个属性： 所有需要用的样式设计（如颜色，大小调整，背景等），都通过同一个（或者同一类）qss文件进行调整，然后加载设置。QSS会给与一份较为完整的，需要调整什么控件在里面找即可，语法同CSS。通用，必须的添加则有： 如上面例子，添加的控件即m_normalFrame, 第二级的Qframe。最后，除了标准通用的模板，要做出一个好看的界面还是需要耐心一遍遍的调整：）希望有了这个通用的框架，能帮助更好的开发出非常好看的界面^_^.下面是附赠的一份QSS 汇总（CSDN的资源附带是枕芯坑…（审核通过了，附带传送门，免费的））/**********按钮**********/QPushButton{ border-radius: 4px; border: none; height: 30px;}QPushButton:enabled { background: rgb(0, 86, 135); color: white;}QPushButton:!enabled { background: rgb(120, 120, 120); color: rgb(200, 200, 200);}QPushButton:enabled:hover{ background: rgb(76, 141, 174);}QPushButton:enabled:pressed{ background: rgb(0, 51, 113);}QPushButton#m_MainWindowPropertyShowPtn, QPushButton#m_MainWindowSelectionShowPtn, QPushButton#m_MainWindowStructureShowPtn,QPushButton#m_MainWindowCalculateShowPtn,QPushButton#m_MainWindowDesignShowPtn,QPushButton#m_MainWindowTopCalculateShowPtn,QPushButton#m_MainWindowResultShowPtn,QPushButton#m_MainWindowChartShowPtn,QPushButton#m_MainWindowGeometryPropertyShowPtn,QPushButton#m_MainWindowPropertyHelpPtn, QPushButton#m_MainWindowSelectionHelpPtn, QPushButton#m_MainWindowStructureHelpPtn,QPushButton#m_MainWindowCalculateHelpPtn,QPushButton#m_MainWindowDesignHelpPtn,QPushButton#m_MainWindowTopCalculateHelpPtn,QPushButton#m_MainWindowResultHelpPtn,QPushButton#m_MainWindowChartHelpPtn,QPushButton#m_MainWindowGeometryPropertyHelpPtn,QPushButton#m_MainWindowPropertySettingPtn, QPushButton#m_MainWindowSelectionSettingPtn, QPushButton#m_MainWindowStructureSettingPtn,QPushButton#m_MainWindowCalculateSettingPtn,QPushButton#m_MainWindowDesignSettingPtn,QPushButton#m_MainWindowTopCalculateSettingPtn,QPushButton#m_MainWindowResultSettingPtn,QPushButton#m_MainWindowChartSettingPtn,QPushButton#m_MainWindowGeometryPropertySettingPtn,QPushButton#m_SubWindowPropertyHelpPtn,QPushButton#m_SubWindowSelectionHelpPtn,QPushButton#m_SubWindowStructureHelpPtn,QPushButton#m_SubWindowWeightHelpPtn,QPushButton#m_weightRecommendPtn,QPushButton#m_CalculateBottomNodeHelpPtn,QPushButton#m_CalculateTopCalculateHelpPtn,QPushButton#m_CalculateResultHelpPtn,QPushButton#m_SubWindowGeometryHelpPtn,QPushButton#m_synthesizeRecommendPtn,QPushButton#m_CalculateHighValueHelpPtn,QPushButton#m_SubWindowPropertyShowPtn,QPushButton#m_SubWindowSelectionShowPtn,QPushButton#m_SubWindowStructureShowPtn,QPushButton#m_SubWindowWeightShowPtn,QPushButton#m_CalculateBottomNodeShowPtn,QPushButton#m_CalculateTopCalculateShowPtn,QPushButton#m_CalculateResultShowPtn,QPushButton#m_SubWindowGeometryShowPtn,QPushButton#m_CalculateHighValueShowPtn,QPushButton#m_CalculateTopStandardValuePtn,QPushButton#m_CalculateTopLevelValuePtn,QPushButton#m_CalculateBottomValuePtn,QPushButton#m_CalculateBottomNodeNamePtn,QPushButton#m_CalculateTopADCShowPtn,QPushButton#m_CalculateVagueShowPtn,QPushButton#m_CalculateSEAShowPtn,QPushButton#m_CalculateTopADCValuePtn,QPushButton#m_CalculateVagueValuePtn,QPushButton#m_CalculateVagueHelpPtn,QPushButton#m_CalculateSEAHelpPtn,QPushButton#m_CalculateTopStandardShowLevelsPtn,QPushButton#m_CalculateTopShowLevelsPtn,QPushButton#m_CalculateTopsisSortPtn,QPushButton#m_CalculateTopADCHelpPtn,QPushButton#m_ModelInputShowBtn,QPushButton#m_LearningShowBtn,QPushButton#m_ParameterBtn,QPushButton#m_ModelOutputShowBtn,QPushButton#m_TestChoiceShowBtn,QPushButton#m_VARecommendPtn,QPushButton#m_ModelSaveShowBtn,QPushButton#m_SetMatrixDialogAddButton,QPushButton#m_SetMatrixDialogDeleteButtonQPushButton#pushButton_filePath { min-width: 0px; min-height: 0px; background-color: transparent;}QPushButton#m_FilePathBtn { background: rgb(180, 180, 180); border-radius: 0px; border: 2px;}QPushButton#m_FilePathBtn:hover { background: rgb(220, 220, 220); border-top: 2px solid rgb(76, 141, 174); border-left: 2px solid rgb(76, 141, 174); border-right: 2px solid rgb(76, 141, 174); border-bottom: 2px solid rgb(76, 141, 174);}QPushButton#m_FilePathBtn:pressed { background: rgb(76, 141, 174);}QPushButton#modelPathPreBtn,QPushButton#modelPathBtn { background: none;}QPushButton#modelPathPreBtn:enabled:hover,QPushButton#modelPathBtn:enabled:hover { background: rgb(76, 141, 174);}QPushButton#modelPathPreBtn:enabled:pressed,QPushButton#modelPathBtn:enabled:pressed { background: rgb(0, 51, 113);}QPushButton#m_FilePtn { color: white; background: rgb(43, 87, 154); height: 28px; min-width: 85px;}QPushButton#m_FilePtn::menu-indicator { image: none;}QPushButton#m_FilePtn:hover { background: rgb(51, 102, 153);}QPushButton#m_FilePtn:hover { background: rgb(0, 86, 135);}/**********工具按钮**********/QToolButton { border: none; color: rgb(0, 0, 0); background: transparent; }QToolButton:enabled:hover{ background: rgb(76, 141, 174); color: white;}QToolButton:enabled:pressed{ background: rgb(0, 86, 135); color: white;}/**********菜单栏**********/QMenuBar { background: rgb(0, 86, 135); border: none;}QMenuBar::item { padding: 5px 10px 5px 10px; background: transparent;}QMenuBar::item:enabled { color: rgb(227, 234, 242);}QMenuBar::item:!enabled { color: rgb(155, 155, 155);}QMenuBar::item:enabled:selected { background: rgba(255, 255, 255, 40);}/**********文本编辑框**********/QTextEdit { border-radius: 2px; height: 25px; border: 1px solid rgb(100, 100, 100);}QTextEdit:enabled { color: rgb(0, 0, 0);}QTextEdit:enabled:hover, QLineEdit:enabled:focus { color: rgb(0, 0, 0);}QTextEdit:!enabled { color: rgb(155, 155, 155);}/**********输入框**********/QLineEdit { border-radius: 2px; height: 25px; color: black; border: 1px solid rgb(100, 100, 100);}QLineEdit:enabled:focus { color: rgb(0, 0, 0);}QLineEdit:!enabled { color: rgb(155, 155, 155);}/**********导航表格**********/QTreeWidget{ background-color:rgba(245, 245, 245); color: black; border: none;}QTreeWidget::Item:hover { background: rgb(51, 102, 153); color: rgb(252, 252, 252);}QTreeWidget::item:selected { background: rgb(0, 86, 135); color: rgb(252, 252, 252);}/**********下拉列表**********/QComboBox { height: 25px; border-radius: 4px; border: 1px solid rgb(100, 100, 100); color: rgb(0, 0, 0);}QComboBox::drop-down { width: 10px; border: none; background: rgba(0, 86, 135); border-radius:3px;}QComboBox::drop-down:hover { background: rgba(76, 141, 174);}QComboBox QAbstractItemView { border: 3px solid rgb(200, 200, 200); background: rgb(245, 247, 248); outline: none; color: rgb(0, 0, 0);}QComboBox QAbstractItemView::item { height: 25px; color: rgb(175, 175, 175);}QComboBox QAbstractItemView::item:selected { background: rgba(0, 86, 135); color: rgb(242, 242, 242);}/**********表格**********/QTableWidget { border: 1px solid rgb(45, 45, 45); background: rgb(245, 245, 245); alternate-background-color: white;}QTableView { border: 1px solid rgb(45, 45, 45); background: rgb(245, 245, 245); alternate-background-color: white;}/**********表头**********/QHeaderView{ border-bottom: 1px solid rgb(45, 45, 45); background: rgb(235, 235, 235);}QHeaderView::section:horizontal { background: rgb(235, 235, 235); border-bottom: 1px solid rgb(45, 45, 45);}QHeaderView::section:vertical { background: rgb(235, 235, 235); border-bottom: 1px solid rgb(45, 45, 45);}/**********左上角按钮**********/QTableCornerButton::section{ background: rgba(235, 235, 235);}/**********菜单**********/QMenu{\t\tbackground: rgb(236, 237, 238);}QMenu::item:enabled { color:rgb(0, 0, 0);}QMenu::item:!enabled {\t\tcolor: rgb(155, 155, 155);}QMenu::item:enabled:selected {\t\tcolor:rgb(255,255,255);\t\tbackground: rgb(76, 141, 174);}/**********对话框**********/QDialog {\t\tbackground: rgb(245, 245, 247);}/**********浮动窗口**********/QDockWidget&gt;QWidget{ background: rgb(236, 237, 238); }/**********日记列表**********/QListWidget {\tborder:1px solid gray; color:black; }QListWidget::Item {\tpadding-top:-2px; padding-bottom:-1px;}/*QListWidget::Item:hover {\tbackground:skyblue;padding-top:0px; padding-bottom:0px; }QListWidget::item:selected {\tbackground:yellow; color:red;}QListWidget::item:selected:!active {\tborder-width:0px;background:lightGray;}*//**********微调器**********//*QSpinBox { border-radius: 4px; background: rgb(252, 252, 252);}QSpinBox:enabled { color: rgb(252, 252, 252);}QSpinBox:enabled:hover, :enabled:focus { color: rgb(255, 255, 255);}QSpinBox:!enabled { color: rgb(65, 65, 65); background: transparent;}QSpinBox::up-button { width: 18px; height: 12px; border-top-right-radius: 4px; background: transparent; border-image: url(:/new/icon/icon/arrow up.png);}QSpinBox::up-button:!enabled { border-left: 1px solid gray; background: transparent;}QSpinBox::up-button:enabled:hover { background: rgb(76, 141, 174);}QSpinBox::down-button { width: 18px; height: 12px; border-bottom-right-radius: 4px; border-image: url(:/new/icon/icon/arrow down.png);}QSpinBox::down-button:!enabled { border-left: 1px solid gray; background: transparent;}QSpinBox::down-button:enabled:hover { background: rgb(76, 141, 174);}*//**********主页面**********/QMainWindow { background: rgb(225, 225, 225);}/**********主窗体**********/QGraphicsView { background: rgb(200, 200, 200);}/**********状态栏**********/QStatusBar { background: rgb(241, 241, 241);}/**********属性栏**********/QFrame#m_SubWindowPropertyFrame,QFrame#m_SubWindowSelectionFrame,QFrame#m_SubWindowStructureFrame,QFrame#m_SubWindowWeightFrame,QFrame#m_SubWindowGeometryFrame,QFrame#m_CalculateTopCalculateFrame,QFrame#m_CalculateTopADCFrame,QFrame#m_CalculateVagueFrame,QFrame#m_CalculateSEAFrame,QFrame#m_CalculateBottomNodeFrame,QFrame#m_CalculateResultFrame,QFrame#m_CalculateHighValueFrame,QFrame#m_TestChoiceFrame,QFrame#m_ParameterFrame,QFrame#m_LearningFrame,QFrame#m_ModelOutputFrame,QFrame#m_ModelInputFrame,QFrame#m_ModelSaveFrame { background: rgba(210, 210, 210);}QFrame#m_SubWindowProperty,QFrame#m_SubWindowPropertyWidget,QFrame#m_SubWindowSelectionWidget,QFrame#m_SubWindowStructureWidget,QFrame#m_SubWindowWeightWidget,QFrame#m_SubWindowGeometryWidget,QFrame#m_CalculatePropertyFrame,QFrame#m_CalculateTopCalculateWidget,QFrame#m_CalculateTopADCWidget,QFrame#m_CalculateBottomNodeWidget,QFrame#m_CalculateResultWidget,QFrame#m_CalculateHighValueWidget,QFrame#m_TestChoiceWidget,QFrame#m_ParameterWidget,QFrame#m_LearningWidget,QFrame#m_ModelOutputWidget,QFrame#m_ModelInputWidget,QFrame#m_ModelSaveWidget { background: rgba(245, 245, 245);}/************普通Frame***********/QFrame#SE_DLG_DatabaseWizardImport,QFrame#SE_DLG_DatabaseWizardImportDataTable,QFrame#SE_DLG_DatabaseWizardSetting,QFrame#SE_DLG_ImportFromTXT_Step1,QFrame#SE_DLG_ImportFromTXT_Step2,QFrame#SE_DLG_ImportFromTXT_Step3,QFrame#SE_DLG_MessageBoxFrame { border: 0.5px solid rgb(43, 57, 157); background: rgb(235, 235, 235);}/**********bannerPixmap**********/QFrame#bannerPixmap2 { border: none; background: rgb(225, 225, 225);}QFrame#SQLFrame { background: rgb(240, 240, 240);}/********所有对话框的border设置*************/QFrame#m_newProjectFrame,QFrame#m_addDataBaseFrame,QFrame#m_openDataBaseFrame,QFrame#m_editDataBaseFrame,QFrame#m_newDataTableFrame,QFrame#m_editDataTableFrame,QFrame#m_overViewFrame,QFrame#m_AHPFrame,QFrame#m_expertFrame,QFrame#m_ChainFrame,QFrame#m_CriticFrame,QFrame#m_SubObjectiveFrame,QFrame#m_normalFrame,QFrame#m_levelSettingFrame,QFrame#m_ppFrame,QFrame#m_matrixFrame,QFrame#m_recommendManageFrame,QFrame#m_recommendPrePocessFrame,QFrame#m_subjectiveFrame,QFrame#m_linearInterFrame,QFrame#m_vagueFrame,QFrame#m_standardLevelFrame,QFrame#m_powerFrame,QFrame#m_ADCFrame,QFrame#m_distributionPlotFrame,QFrame#m_nodeViewConfigFrame,QFrame#m_reportFrame,QFrame#m_ganttFrame { border-left: 2px solid rgb(43, 57, 157); border-right: 2px solid rgb(43, 57, 157); border-bottom: 2px solid rgb(43, 57, 157); background: rgb(236, 237, 238); }/**********弹出对话框*********/QFrame#bottomFrame { border: none; background: rgb(225, 225, 225);}/**********进度条**********//*QProgressBar::chunk { color: rgb(255, 255, 255); background: rgb(30, 144, 255);}*//**********页签项**********/QTabWidget::pane { border: none; background: rgb(236, 237, 238);}QTabWidget::tab-bar { border: none;}QFrame#m_RibbornBar { border: none; background: rgb(43, 87, 154); height: 10px;}QTabBar#m_RibbornTab::tab { border: none; color: white; background: rgb(43, 87, 154); height: 28px; min-width: 75px; padding-left: 5px; padding-right: 5px;} QTabBar#m_RibbornTab::tab:hover {background: rgb(51, 102, 153);} QTabBar#m_RibbornTab::tab:selected {color:rgb(43, 87, 154); background: rgb(225, 225, 225);}/*********抽象模板********/QAbstractItemView::item { height: 25px; color: rgb(0, 0, 0);}QAbstractItemView::item!enabled { height: 25px; color: rgb(175, 175, 175);}/**********工具栏********/QToolBar { spacing: 10px;}QToolBar::separator{ background: rgb(200, 200, 200); width: 2px;}QToolButton[popupMode=\"1\"] { padding-right: 2px;}/**********表格**********/QTableWidget { border: 1px solid rgb(45, 45, 45); background: rgb(245, 245, 245); alternate-background-color: white;}" }, { "title": "SVN-版本控制：深入浅出入门SVN使用", "url": "/posts/SVN-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A5%E9%97%A8SVN%E4%BD%BF%E7%94%A8/", "categories": "教程", "tags": "SVN", "date": "2020-02-10 17:10:00 +0800", "snippet": "说在前面首先讨论一下版本控制的重要性： 每一个小版本只更新了一个或两个功能，那后面如果出错了，排查错误、进行回滚就可以根据message方便的进行； 团队协作的时候，必然会出现合作、共同使用代码的情况，比如我们两个人一同更新mainwindow这个文件，那就极可能出现冲突，像我们都在第1000行新写了一个函数，那版本就无法识别到底最后选择哪个，而当这些情况积累起来之后要处理就很困难而且容易出错了，甚至导致覆盖了别人的代码，而覆盖的情况下没有以往多个小版本的信息又很难恢复，所以合作的时候一定要多点merge，多写message，也就相当于交流沟通了； 所以正常的工作流程就应该是，工作前update同步到最新进度，每工作一会把阶段性成果先add、commit到本地保存，工作结束后再把所有本地版本merge到master中，然后就可以今晚吃鸡啦。当然，如果遇到大规模重构、大范围更新，导致短期你的代码暂时无法运行，可暂时不merge到master，但也要及时保存到本地，以及update同步master。update、merge的过程其实也是实时地交流、了解团队进度的一个过程、实战演习下面就是常规的操作内容： 我们共享，进行版本控制仅为源代码，请理解这一点。所以编译，调试的部分不要上传到云端，更不要merge到master中。同理，一些不需要的文件，如xxx.user该类文件记录特定用户的属性，不需要进行共享。不需要共享，又出现在仓库目录下的东西添加到ignorelist即可，参考项目说明文档。 可以看到这里的.user是没有绿色下标的 因为我添加到了ignore list 。至于添加ignore的方法，鼠标右键要忽略的文件，找到ignore： 每个人仓库根目录应该至于有这两个文件夹，其他文件夹可以删除，也可以不管。注意，在我们每个人眼里只有两个文件夹，自己的文件夹和master。我们从master同步所有人的更改，再在自己分支上进行修改，最后合并到master上。至于从master建立自己分支的方法： 每天的工作就是一来先到master update 然后推到你自己的分支 然后在你分支干活 一天结束 然后把你的分支的修改merge 进入 master 大概就是这样：注意上述仓库路径。 关于merge，按照上述图示即可，选择all revisions会拉取对方的所有版本，specific range则挑选具体的版本。每次我们把一次更改推送到云端，就会产生一个版本。 注意：请妥善处理冲突！有冲突时搞清楚原因，与产生冲突文件的更改者协商，谨慎处理，切勿把别人的工作全部删除。当然删除了之后还可以恢复，不用过于担心。 请每次Merge到master时填写message，以便大家拉取时能够理解。 正式开始工作，（我建议用Qt creator进行编码工作而不是VS，只要下载了Qt都会自带Qt creator，使用VS在目录与组织形式会麻烦很多，涉及大量的ignore，更可能遇到一些不可抗逆的bug…）点击.pro文件，第一次打开要配置kit，直接点确定即可，然后qmake,run即可运行。然后愉快地进行打码即可。运行有错误时，记住clean,qmake,run三连。完成阶段性工作后即时commit，merge到master。注意，当添加了新文件后，记得先add，再commit（或者在commit时选择All）。希望大家习惯这种控制方式.写在后面有机会的会再写一篇git和svn的区别（当然这种教程要多少有多少啦），把自己的经验教训总结一下。嗯，继续埋坑。" }, { "title": "OSG学习之路", "url": "/posts/OSG%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/", "categories": "杂记, OSG", "tags": "记录", "date": "2020-02-09 20:10:00 +0800", "snippet": "osg入门的时候材料教程真的是特别少，而且很多都特别老的。这里分享一下个人学习过程的项目，会持续更新。里面暂时包括有：Array大佬《osg程序设计》所有源码的整理，配置好环境后可以直接运行；osg_earth官方例子的一些整理；osg+qt的实现；以及一些经验教训总结等。项目地址：https://github.com/kkkiitty/learnOSG当时整理的时候就想着能整理出一套教程来，但由于项目需要赶着学，很多东西都是填鸭子似的看过，一知半解，而且集中应用也是在osgEarth上，所以后面有时间再仔细学习一下框架再说吧。挖的坑会填的~结果过了两年还没填。。" }, { "title": "C++隐式类型转换 operator T()", "url": "/posts/C++%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-operator-T()/", "categories": "杂记, C++", "tags": "记录", "date": "2020-02-09 19:51:00 +0800", "snippet": "最近研究智能指针，osg::ref_ptr的机制时候发现一个有趣的问题。就是C++智能指针都会提到一点： 由于智能指针是一个对象，所以if (my_smart_object)永远为真，要判断智能指针的裸指针是否为空，需要这样判断：if (my_smart_object.get())。但是我在写osg的时候，下意识都是直接判定的if(myPtr)也没碰到问题。研究后发现原来是osg::ref_ptr重载了一个函数： operator T*() const { return _ptr; }仔细一看，emmm，发现没看懂这是啥。百度之后发现这是隐式类型转换的重载，即使用到osg::ref_ptr对象时，可以把对象隐式转换成T*类型。继而仔细思考了一下，上面第一段引用的那段话 由于智能指针是一个对象，所以if (my_smart_object)永远为真觉得非常不合理，因为如果普通的类的对象，根本就不能判断if(my_smart_object)，因为这个对象不能隐式转换成boo类型的值，所以上述判断又从何而来呢？比如：而一旦可以用if判断，那其实就是重载了隐式转换，既然重载了，为什么要转换成毫无意义的this指针？而不是内部保存的指针。基于使用纯C++的智能指针较少（指STL或BOOST），暂时不能下什么结论。先 Mark一下。" }, { "title": "OSG智能指针：osg::ref_ptr", "url": "/posts/OSG%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/", "categories": "杂记, OSG", "tags": "记录", "date": "2020-02-08 16:06:00 +0800", "snippet": "在osg开发时（特别是刚上手），有一点比较重要然后容易忽略的是，在osg程序开发中，要尽量使用osg::ref_ptr&lt;T*&gt;。这个智能指针构建起osg的对象树（绝大部分osg类都是继承于osg::Referenced，即可计数对象），类似于Qt的对象树，负责其内存的管理。当然其内存管理策略不是我们关心的，我们使用它的原因是基于其内存管理策略，大部分类的析构函数都是受保护的，意味着我们并不能直接维持对象的内存，就必须用到osg::ref_ptr（当然这个必须是相对的，举个例子，如果我们new了一个osg::Node，然后把它addChild()进mapNode，那当removeChild的时候，这块内存其实也是会被释放掉的。但这责任分配很奇怪不是吗？）根据部分教材的说法：这种时候就必须由我们来负责内存释放，而这是必须通过osg::ref_ptr完成。至于我们怎么释放？很简单，举例：osg::ref_ptr&lt;osg::Node&gt; myNode;直接myNode = nullptr;这块内存就会被释放（基于计数原则），同时把myNode reset为空。osg::ref_ptr本身非常简单，除了上面所说基本没有其他内容（而正是基于这么简单的内容就构建起整个内存管理系统）。有一个小地方可能比较引人注目，就是osg::ref_ptr&lt;T*&gt;::release()，这个函数的名字非常让人迷惑，但是相信我，基本上用不到这个函数的。根据官方的注释：和具体实现：重点在于“local”，经过实验，它唯一会使用到的地方就是类似于下面的代码：#include &lt;osgDB/ReadFile&gt;#include &lt;osgViewer/Viewer&gt;#include &lt;osg/Node&gt;#include &lt;osg/Geode&gt;#include &lt;osg/Geometry&gt;#include &lt;osgViewer/ViewerEventHandlers&gt;#include &lt;QDebug&gt;osg::Geometry *createGeometry();int main(){ osgViewer::Viewer viewer; osg::Group * root = new osg::Group() ; osg::Geometry *geometry = createGeometry(); osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; geode-&gt;addDrawable( geometry); root -&gt;addChild(geode.get()) ; viewer.setSceneData(root); //窗口大小变化事件 viewer.addEventHandler(new osgViewer::WindowSizeHandler); //添加一些常用状态设置 viewer.addEventHandler(new osgViewer::StatsHandler); viewer.realize(); viewer.run();}osg::Geometry *createGeometry(){ osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; //首先定义四个点 { osg::ref_ptr&lt;osg::Vec3Array&gt; v = new osg::Vec3Array; geom-&gt;setVertexArray( v.get() ); v-&gt;push_back( osg::Vec3( -1.f, 0.f, -1.f ) ); v-&gt;push_back( osg::Vec3( 1.f, 0.f, -1.f ) ); v-&gt;push_back( osg::Vec3( 1.f, 0.f, 1.f ) ); v-&gt;push_back( osg::Vec3( -1.f, 0.f, 1.f ) ); } //定义颜色数组 { osg::ref_ptr&lt;osg::Vec4Array&gt; c = new osg::Vec4Array; geom-&gt;setColorArray( c.get() ); geom-&gt;setColorBinding( osg::Geometry::BIND_PER_VERTEX ); c-&gt;push_back( osg::Vec4( 1.f, 1.f, 1.f, 1.f ) ); c-&gt;push_back( osg::Vec4( 1.f, 1.f, 1.f, 1.f ) ); c-&gt;push_back( osg::Vec4( 1.f, 1.f, 1.f, 1.f ) ); c-&gt;push_back( osg::Vec4( 1.f, 1.f, 1.f, 1.f ) ); } //定义法线 { osg::ref_ptr&lt;osg::Vec3Array&gt; n = new osg::Vec3Array; geom-&gt;setNormalArray( n.get() ); geom-&gt;setNormalBinding( osg::Geometry::BIND_OVERALL ); n-&gt;push_back( osg::Vec3( 0.f, -1.f, 0.f ) ); } //设置顶点关联方式 geom-&gt;addPrimitiveSet( new osg::DrawArrays( osg::PrimitiveSet::QUADS, 0, 4 ) ); return geom.release();}也就是注释中的，局部的osg::ref_ptr,以及必须返回C风格的指针（而不是ref_ptr）。稍微解释一下，因为这种情况下createGemoetry域返回时就是调用geom的析构函数，这个时候就会导致引用数为0，即释放掉geom的内存，即使返回了geom的指针，也只会是野指针，所以必须返回gemo.release。总结，总之用到osg相关的，加上osg::ref_ptr就对了。（当然说是智能指针，最终内存还是要自己管理，谨慎小心！）原本没用到的也不是一定要改，只是不好而不是不能用。" }, { "title": "编码规范汇总【持续更新】/C++/C#", "url": "/posts/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E6%B1%87%E6%80%BB-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/", "categories": "教程", "tags": "编码规范", "date": "2020-02-08 16:06:00 +0800", "snippet": "前言作为软件工程师，出产物就应该具备工程的健壮性和美观性。因此代码规范是作为软件工程师的职业素养。但总所周知，程序员的工作基本就是在维护一座屎山，这确实是现实中种种客观条件约束下导致的。记录本篇博客，也是希望本人在打码过程，能够保持负责任的初心，以及追求完美的极客精神吧。诸君共勉。愿人间没有ugly的代码。规范标准首先列出一些常见的编码规范。C++规范一．\t变量声明与命名风格（1）\t代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。但也常以双下划綫标识类内部变量。反例：_name / __name / $name / name_ / name$ / name__（2）\t代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式 也要避免采用。 正例：alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。 反例：DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3（3）\t变量名和函数名以小写字母开头，开头之后的部分每个单词以大写字母开头。正例：short counter; / char itemDelimiter = ' ';（4）\t类名以大写字母开头。正例：XmlService / User （5）\t常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。 正例：MAX_STOCK_COUNT（6）\t抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类 命名以它要测试的类的名称开始，以 Test 结尾。（7）\t避免短的或无意义的命名。使用尽量完整的单词 组合来表达其意。正例：：AtomicReferenceFieldUpdater。反例：变量 int a 的随意命名方式。（8）\t枚举成员名称需要全大写，单词间用下划线隔开。（9）\t单个字符的变量名只适用于用来计数的临时变量，因为此时该变量的用途十分明显（10）\t声明每一个变量都要用独立的一行正例：int height; / int width; （11）\t当一个变量被用到时再声明它。（12）\t对于指针或引用，在类型名和*或&amp;之间用一个空格，但是在*或&amp;和变量名之间没有空格正例：char *x; / const QString &amp;myString; / const char * const y = \"hello\";（13）\tQt的ui相关的，在ui里的变量也尽量要进行命名，特别是在代码中使用到的，反例：ui-&gt;frame，命名时注意添加该界面的标识性字段，尽量使得ui里所有变量名字在整个程序域中不重名，便于在QSS中控制。正例：如在SE_ReportDialog.ui中的命名，m_reportFrame；在SE_CalculateWindow.ui中的命名：m_calculateFrame等。（14）\t如上个例子，在特定地方声明的变量应添加适当的前缀，如类的成员变量添加m_前缀；全局变量添加g_；局部变量添加l_。（15）\t接上一点，在前缀下划线后第一个字母，常为变量类型的缩写，如int为i，double为d。正例：int m_iMonth; double l_dMoney;二．代码格式（1）\t大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果 是非空代码块统一如下例：if ( ... ){...}else{...}（2）\t左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格反例：if (空格 a == b 空格)（3）\tif/for/while/switch/do 等保留字与括号之间都必须加空格。正例：if (foo)（4）\t任何二目、三目运算符的左右两边都需要加一个空格。正例：lineF == lineN （5）\t注释的双斜线与注释内容之间有且仅有一个空格。正例： // 这是示例注释，请注意在双斜线之后有一个空格（6）\t方法参数在定义和传入时，多个参数逗号后边必须加空格。即逗号左边没有空格，逗号右边有一个空格。正例: QT_REQUIRE_VERSION(argc, argv, \"4.0.2\") （7）\t左引号的左边和右引号的右边都有一个空格，左引号的右边和右引号的左边都没有空格。如果右引号右边是右括号的话，它们之间没有空格。正例: qDebug() &lt;&lt; Q_FUNC_INFO &lt;&lt; \"was called with value1:\" &lt;&lt; value1 &lt;&lt; \"value2:\" &lt;&lt; value2; QT_REQUIRE_VERSION(argc, argv, \"4.0.2\")（8）\t不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。 （9）\t当条件语句的执行部分多于一句的时候才使用花括号。然而在if-else语句块中，如果if或else中的一个包含了多行，另一个为了对称性原则，也要用花括号。正例：if (address.isEmpty()) \t\t\treturn false;（10）\t每行代码不多于100个字符，超出需要换行。换行时：第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进。运算符与下文一起换行。方法调用的点符号与下文一起换行。方法调用中的多个参数需要换行时，在逗号后进行。正例：if (longExpression \t\t+ otherLongExpression \t\t+ otherOtherLongExpression) { }三．类相关（1）避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成 本，直接用类名来访问即可。（2）构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。（3）类内方法定义的顺序依次是：公有方法-&gt;公有槽-&gt;信号-&gt;保护方法-&gt;私有方法-&gt;私有槽。（4）当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起， 便于阅读。（5）成员变量一般为名词。函数成员一般为动词/动词+名词，当返回值为Bool型变量时，函数名一般以前缀’is’开头。\t正例：void setDirty(bool b); / bool isDirty() const;（6）每一个对象，只要它不是基础类型(int, float, bool, enum, or pointers)，都应该以常量引用的形式传递。这条使得代码运行得更快。\t正例：QString myMethod(const QString &amp;foo, const QPixmap &amp;bar, int number); （7）为了使构造函数被错误使用的可能性降到最小，每一个构造函数（除了拷贝构函数）都应该检查自己是否需要加上explicit 符号。（8）尽量减少在头文件中包含其他头文件的数量，可以用前置声明法。\t正例：class KBar; class KFoo : public KFooBase { … }; （9）假如你有一个Foo类，有Foo.h文件和Foo.cpp文件，在你的Foo.cpp文件中，要先包含Foo.h文件再包含其他头文件。\t正例：// .h文件 class Foo { …};\t\t // .cpp文件 #include \"foo.h\"#include \"bar.h\"四．\t控制相关（1）\tcase标签和switch在同一列。每一个case语句的末尾都要有一个break语句或return语句。在一个 switch 块内，都必须包含一个 default 语句并且 放在最后，即使空代码。（2）\t除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将 复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性五．\t注释相关（1）\t方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释 使用/* */注释，注意与代码对齐。（2）\t对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含 义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同 天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看 的，使其能够快速接替自己的工作。（3）\t好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的 一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。（4）\t建议每个文件、每个类、每个函数，尤其是接口API部分，使用doxygen语法标注。C#规范1.\t代码规范Unity中的C#代码，变量命名和函数命名均采用小驼峰命名法，即名称首字母小写，其余单词的首字母大写。（由于Unity内置接口以及C#的系统接口都是使用大驼峰命名法（即首字母也是大写），我们使用不同命名规则就能轻易辨认出某个函数是内置的还是我们定义的）类名和常量命名使用大驼峰命名法。Python代码，变量命名使用下划线命名法，常量命名使用大写的下划线命名法，静态变量使用大驼峰命名法，函数使用小驼峰命名法，类使用大驼峰命名法。（由于Python的变量声明不需要任何关键字，只能使用多种命名法加以区分）其他地方的命名规则均使用大驼峰（包括Unity编辑器中的对象命名、文件命名等）.\t注释要求每个类、函数前都要写注释，在Python中直接在类/函数前一行使用“#”来注释。在C#中使用以下格式的注释：/// &lt;summary&gt;/// 函数解释/// &lt;/summary&gt;类中的成员变量也需要注释，可以使用上面的格式，也可以直接在变量后用“//”注释，如果变量作用清晰，变量名能表达清楚则可以不写注释。如果需要声明多个成员变量，可以写在一起，然后在第一个成员变量前面使用上述注释方法进行分区，如以下代码所示：注：VS中，在声明的类、函数或者变量前输入“///”就会自动补全以上格式的注释。另外，在定义了很多函数的情况下，要将功能相似的函数放在一起，并使用以下语句进行代码分区：#region 区域名.... 代码段 ....#endregion这样可以在编辑器中收起一部分代码段，方便查看其他部分的代码，也能作为一个注释告诉其他人这段代码是做什么的。效果如下：最后，在代码逻辑中，也需要尽量写注释，特别是用到了其他技术（比如Unity提供的一些接口）时要注明一下。规范记录命名命名除了必须符合编码规范外，同时应尽量使其让其具备良好的可读性。关于命名（实在想不到应该叫啥，或者单词都不会翻译 ），可参考CodeLf。硬编码在代码中，我们经常会碰到硬编码，比如存取一个本地文件的名字（如：Setting.file），比如预设的一些组件的名字（如：控件1、控件2）等等。硬编码其实无法避免，举个极端的说法，在UI上每个按钮的名字都是硬编码，这个叫做“设置”，那个叫做“关闭”。但硬编码还是存在很大的问题，以上述读取一个文件的名字为例，如果代码中有多个地方访问该文件，直接使用硬编码时，每个地方都将使用一次”Setting.file”，这是让人担忧的事情！因为当这个”Setting.file”发生变更时，我们将不得不修改每一处硬编码的地方。（当然了，我们也是可以通过全局crtl+F轻松替换）。那为什么不采取一个更加漂亮的处理方式呢？个人建议，所有硬编码的地方，只要有第二处引用到同一个硬编码，则应该将该硬编码提取成一个常量变量储存，每个地方引用该变量。举例：/*test.h*/class ST_Scen_Instance{public:// 这里就有个违反规范的地方是没有全大写，主要是全大写个人觉得阅读起来比较困难 static const QString LatitudeName; static const QString LongitudeName; static const QString HeightName; inline void changeLLA(double latitude, double longitude, double height); inline double longitude() const; inline double latitude() const; inline double height() const;};void ST_Scen_Instance::changeLLA(double latitude, double longitude, double height){ for (auto &amp;para : m_lParameterValue) if (para.m_sName == QString(LongitudeName)) para.m_sInitialValue = QString::number(longitude); else if (para.m_sName == QString(LatitudeName)) para.m_sInitialValue = QString::number(latitude); else if (para.m_sName == QString(HeightName)) para.m_sInitialValue = QString::number(height);}inline double ST_Scen_Instance::longitude() const{ for (auto &amp;para : qAsConst(m_lParameterValue)) if (para.m_sName == QString(LongitudeName)) return para.m_sInitialValue.toDouble(); return 116;}inline double ST_Scen_Instance::latitude() const{ for (auto &amp;para : qAsConst(m_lParameterValue)) if (para.m_sName == QString(LatitudeName)) return para.m_sInitialValue.toDouble(); return 40;}inline double ST_Scen_Instance::height() const{ for (auto &amp;para : qAsConst(m_lParameterValue)) if (para.m_sName == QString(HeightName)) return para.m_sInitialValue.toDouble(); return 0;}/*test.cpp*/const QString ST_Scen_Instance::LatitudeName = \"m_Latitude\";const QString ST_Scen_Instance::LongitudeName = \"m_Longitude\";const QString ST_Scen_Instance::HeightName = \"m_Altitude\";单例类【线程安全】单例类可谓非常常用，但使用时容易忘记多线程访问的问题。参考：C++ 线程安全的单例模式总结。建议使用最简单的写法为：/////////////////// 内部静态变量的懒汉实现 //////////////////class Single{public: // 获取单实例对象 static Single &amp;GetInstance();\t\t// 打印实例地址 void Print();private: // 禁止外部构造 Single(); // 禁止外部析构 ~Single(); // 禁止外部复制构造 Single(const Single &amp;signal); // 禁止外部赋值操作 const Single &amp;operator=(const Single &amp;signal);};Single &amp;Single::GetInstance(){ // 局部静态特性的方式实现单实例 static Single signal; return signal;}void Single::Print(){ std::cout &lt;&lt; \"我的实例内存地址是:\" &lt;&lt; this &lt;&lt; std::endl;}Single::Single(){ std::cout &lt;&lt; \"构造函数\" &lt;&lt; std::endl;}Single::~Single(){ std::cout &lt;&lt; \"析构函数\" &lt;&lt; std::endl;}/////////////////// 内部静态变量的懒汉实现 //////////////////Qt定义类【隐式内存共享】由于Qt内建的一套隐式内存共享策略，即新对象引用共享数据只单纯让引用数+1，而不需要拷贝数据（这样使用值传递和const &amp;传递效果基本一样了），只有在写时才会发生深拷贝操作。参考：Implicit Sharing。隐式操作在绝大多数时候只会发生在后台，与程序员无关，但在少数情况下，这将会带来一定影响，甚至是致命影响。首先是官方提到的案例，迭代器：QVector&lt;int&gt; a, b;a.resize(100000); // make a big vector filled with 0.QVector&lt;int&gt;::iterator i = a.begin();// WRONG way of using the iterator i:b = a;/* Now we should be careful with iterator i since it will point to shared data If we do *i = 4 then we would change the shared instance (both vectors) The behavior differs from STL containers. Avoid doing such things in Qt.*/a[0] = 5;/* Container a is now detached from the shared data, and even though i was an iterator from the container a, it now works as an iterator in b. Here the situation is that (*i) == 0.*/b.clear(); // Now the iterator i is completely invalid.int j = *i; // Undefined behavior!/* The data from b (which i pointed to) is gone. This would be well-defined with STL containers (and (*i) == 5), but with QVector this is likely to crash.*/然后同样是迭代的问题，详见官方API： QString s = ...; for (QChar ch : s) // detaches 's' (performs a deep-copy if 's' was shared) process(ch); for (QChar ch : qAsConst(s)) // ok, no detach attempt process(ch);这将导致我们常规的for语句出现一个warning:因此必要时采用qAsConst。" }, { "title": "OpenGL矩阵变换顺序", "url": "/posts/OpenGL%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E9%A1%BA%E5%BA%8F/", "categories": "杂记", "tags": "记录", "date": "2019-12-31 13:56:00 +0800", "snippet": "问题在学习openGL变换的时候，我们知道一个规则就是：先缩放再旋转再平移，关于这个规则以及变换关系建议去看learnopengl的教程。但是我们还有另外一种情景，就是比如我们希望变换是基于某个点进行的，如一个三角形基于它的一个顶点进行缩放，那这个时候我们的做法就是先把三角形平移到原点处（假设该顶点坐标为（x,y），则平移为T(-x,-y)），然后缩放（比如，S(2,2)），然后平移回去T(x,y)。这时我产生了一个疑问就是，为什么这里的平移不会受到缩放的影响？如果按照上面规则中的相互影响，第一次平移被缩放放大了两倍，那最后平移回去是不是应该平移两倍关系（即最后一步，T(2x,2y)）？结论是，上述两种写法都是正确的，只是为了达到不同的目的而已。演示假设有$A(2,3)$，我们先让它平移再缩放，然后让它缩放再平移试试：第一，先平移$T(-1,-1)$，再缩放$S(2,2)$：$T(-1,-1)=\\begin{bmatrix} 1 &amp; 0 &amp; -1 0 &amp; 1 &amp; -1 0 &amp; 0 &amp; 1\\end{bmatrix}$$S(2,2)=\\begin{bmatrix} 2&amp; 0 &amp; 0 0 &amp; 2 &amp; 0 0 &amp; 0 &amp; 1\\end{bmatrix}$$T(-1,-1)*A(2,3)$得到$A’(1,2)$，这个跟我们平移一个点得到结果一致；$S(2,2)*A’(1,2)$得到$A’‘(2,4)$，这个跟我们直接放大$A’(1,2)$得到结果一致。第二，先缩放$S(2,2)$，再平移$T(-1,-1)$：$S(2,2)*A(2,3)$得到$A’(4,6)$，这个跟我们放大$A$ 点得到结果一致；$T(-1,-1)*A’(4,6)$得到$A’‘(3,5)$，这个跟我们直接平移$A’(4,6)$得到结果一致。上述结果至少可以明确一点，就是无论矩阵变换的顺序，矩阵本身会切实地完成我们想要的目的（只要输入的参数正确），比如我们想要平移，那用平移矩阵结果就会正确（这点应该是显然的）。我们再来模拟一下完整的平移、缩放、反向平移的过程：$T(-1,-1)A(2,3)$得到$A’(1,2)$，$S(2,2)A’(1,2)$得到$A’‘(2,4)$，$T(1,1)*A’(2,4)$得到$A’‘(3,5)$。$A’‘(3,5)$这个结果对于我们来说似乎在几何意义上并没有任何意义，原因是我们使用这种写法通常都是与把某个位置放到原点进行操作整个目的结合在一起！所以这里我们把$A(2,3)$ 改成$A(1,1)$，再重新来一遍。$T(-1,-1)A(1,1)$得到$A’(0,0)$，$S(2,2)A’(0,0)$得到$A’‘(0,0)$，$T(1,1)*A’(1,1)$得到$A’‘(1,1)$。这个过程是不是就是完美表现了我们要达到的目的？即基点本身会保持不变，而跟它相关的点（比如三角形另外的点）基于它发生变化。显然可以得出结论是上述的第二种写法是没有问题的，似乎也很显然，毕竟两次平移是互逆的，可以抵消影响。而这个又是基于上述中间的一个结论就是：矩阵变换本身的效果是不会受到其他干扰的！我们让它平移就平移了，让它旋转就旋转了。总结小结一下，第一种写法（即遵守先缩放再旋转再平移），是为了看到一个最终的效果，举个例子，比如我们建立了一个模型，想看到的结果是让它平移到某一个位置，并且旋转了90度，且比例缩放了一倍，这个时候变换的顺序就必须遵循上述规则，不然它们就可能彼此干涉。理由是它们虽然同样达到了各自独立的效果（比如平移，缩放），但是先平移的那个距离会被后续的缩放所影响，原来我们预计平移一个单位长度，但是这个1可能会被放大成2（或缩小为1/2）。即矩阵变换本身不受干扰，只是它们之间的参数发生扰动。第二种写法的目标是每一个子矩阵所产生的结果，如我们要把$A$ 平移到原点，那$T(-1,-1)$ 这个矩阵就达到了我们的目的，相应的为了抵消这个影响，我们需要$T(1,1)$ 这个矩阵的效果。总而言之，这个写法使用了每个子矩阵的效果，而这个效果显然是相互独立的。ps:似乎挺啰里啰嗦的，可是我在这该死的地方纠结了考试中的一个小时！可能就是越简单的地方越把它当做理所当然的事情越难理清楚其中的关系吧(逃" } ]
